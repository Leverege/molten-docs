{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/","title":"API","text":"<p>Api Referenece</p>"},{"location":"concepts/","title":"Concepts","text":""},{"location":"concepts/actions/","title":"Actions","text":""},{"location":"concepts/attributes/","title":"Attributes","text":"<p>Molten make use of a mechanism call <code>attributes</code> for much of its data access. An Attribute is used to access a named piece of data about an object. This piece of data may represent a unique property on the data being accesssed, or it might represent a shared idea that can be applied to many types of objects, such as a human readable name or geographic position. </p> <p>These Attributes are used in a variety of places in molten to facilitate different needs. For example, when presenting data columns in a table or information to see in a detail card, the user will pick which Attributes to use. When rendering to a geographic map, the geodetic position attribute can be used to place the object. When building a logical condition to do dynamic data styling or alerting, the Attributes can be selected to perform the conditional if/then logic.</p> <p>The Attribute is acting as a delegate between the attribute name and a particular type of object. It provides a common interface to get data and in some cases, set data. Where pieces of information represent a well known and shared concept, a well known attribute name is used. Where the data represents very specific information, a unique attribute name can be used. To demonstrate this concept, here are some example attribute names:</p> Attribute Name What is it name The user displayable name of the object. This is a shared Attribute that can be used in a generic information display or readout that tells the user what it is. Usually, every object type can have one of these, even if it just returns the objects unique id. icon Returns an image url ro font icon class name used to represent the object geoPosition This represents the latitude/longitude of an object. This could be used to map any geo spatial point object on a map, or perform a containment check against it for alert purposes. boat.bilge.status A example of a unique attribute about a boat's bilge status. When an attribute is unique to a type of object, its name should be prefixed with the object type, boat in this case. myType.myAttribute A example of a unique attribute. <p>The Attribute acts as a normalization mechanism between the name of the attribute and the type of an attribute. For example, an object of type <code>car</code> may store its geographic position in a <code>lat</code> and <code>lon</code> field, while an object of type <code>boat</code> may store it in a <code>geoPosition : { latitude, longitude }</code> subfield. The attribute for the car knows to access the lat and lon field and assemble the appropriate geoPosition object. The boat, likewise, would know to use the <code>geoPosition</code> field. </p> <p>The attribute when registered, supplies the attibrute name and type of object it works against, as well as the method to retreive the data. This allows the car and boat attribute to extract the data appropriately based on the objects data type and return the correct format of the data. </p> <p>The fields of an Attribute are:</p> Field Type Description name string Defines the name of the attribute objectType string The string name of the type of object the attribute can get/set data on. valueType string The type of object the returned from get(). The valueType must be the same for all attributes with the same name. displayName string The human display name of the attribute get function A function( object, context ) that returns the value of the attribute for the given object. If <code>Attributes.get()</code> is invoked with the objRef, the <code>data</code> portion of the obejctRef will be given to this function unless the Attribute sets <code>usesObjRef</code> to <code>true</code>. usesObjRef boolean Defaults to false. If this is true, the objRef will be given to the <code>get()</code> method canSet function Optional. A function( objRef, value, context ) the should return true or false, indicating where or not the set function is available set function Optional. A function( object, value, context ) invoked to perform the set <p>Attributes Library</p> <p>The <code>@leverege/ui-attributes</code> library contains all of the base mechanics to make this work.</p>"},{"location":"concepts/attributes/#value-types","title":"Value Types","text":"<p>There are many default valueTypes supplied. You can make your own as well. You will need to add other plugins to support other mechanism such as Details and Tables. Here is a list of the predefined valueTypes:</p> Value Type Return string string number number timestamp Date boolean boolean int number icon string of a url or a font icon class name percent number length <code>UnitType</code> speed <code>UnitType</code> acceleration <code>UnitType</code> surface <code>UnitType</code> volume <code>UnitType</code> mass <code>UnitType</code> time <code>UnitType</code> frequency <code>UnitType</code> angle <code>UnitType</code> current <code>UnitType</code> temperature <code>UnitType</code> substanceAmount <code>UnitType</code> luminousIntensity <code>UnitType</code> force <code>UnitType</code> energy <code>UnitType</code> power <code>UnitType</code> pressure <code>UnitType</code> electricCharge <code>UnitType</code> electricCapacitance <code>UnitType</code> electricPotential <code>UnitType</code> electricResistance <code>UnitType</code> electricInductance <code>UnitType</code> electricConductance <code>UnitType</code> magneticFlux <code>UnitType</code> magneticFluxDensity <code>UnitType</code> bit <code>UnitType</code> flow <code>UnitType</code> geoPoint Object containing <code>{ lat, lon }</code> where lat and lon are in degrees geoJson string containing the geoJson data relationship string (Imagine attribute type) parentRelationship string id (Imagine attribute type) enum string (Imagine attribute type) <p><code>UnitType</code> is an object that contains { type : , value, unit }."},{"location":"concepts/attributes/data-sources/","title":"Data Sources","text":"<p>DataSources act as a bridge between the data objects and their source. The data object themselves are represented by an Object Reference, or <code>objRef</code>. The <code>objRef</code> has</p> <p>DataSources are used to acquire data from a given service. This could be a remote server or a local data source as well. It is used in conjunction with the <code>ObjRef</code>, <code>Attributes</code> and <code>Relationships</code> to supply access to the given </p>"},{"location":"concepts/attributes/details/","title":"Data Sources","text":""},{"location":"concepts/attributes/formatters/","title":"Formatters","text":""},{"location":"concepts/attributes/graph/","title":"Graphing","text":""},{"location":"concepts/attributes/relationships/","title":"Relationships","text":""},{"location":"concepts/attributes/table/","title":"Data Sources","text":""},{"location":"concepts/models/","title":"Models","text":"<p>Molten uses the concept of a <code>Model</code> in much of its architecture. It is a way of transfering settings and workflows, and defining behaviors in plain JSON.</p>"},{"location":"concepts/models/#characteristics","title":"Characteristics","text":"<p>A model has several characteristics that should be enforced while using them. Following these characteristics make it easy to save them, restore them, edit them, and find handlers/executors for them. </p>"},{"location":"concepts/models/#plain-json-object","title":"Plain JSON Object","text":"<p>Models should be a simple javascript object. They should not be or contain classes, functions, or Dates anywhere in their structure. This allows them to be easy stored to a network server, or added to a Redux like mechanism.</p>"},{"location":"concepts/models/#immutable","title":"Immutable","text":"<p>Models should be considered immutable. Changing a field redirectly in a Model will break caches, Redux and UI's that rely on top level object differences.</p>"},{"location":"concepts/models/#typed","title":"Typed","text":"<p>Models should have a <code>type</code> field that defines its unique identity. Normally this is a namespaced string such as <code>myProject.MyModel</code></p>"},{"location":"concepts/models/#working-with-models","title":"Working with Models","text":"<p>There tends to be a lot of broilerplate code when it comes to mutating models. To support this, the <code>@leverege/model-util</code> library is available for use. For example, when changing a value and following the immutablitly rule above, it would look like: </p> <pre><code>import MyModel from './MyModel'\n\n// If model was defined as\nmodel = { type : 'myMode', value : 5, subValues : { sv : 1 } }\n\n// WRONG - Dont do this\nmodel.value = 42\n\n// CORRECT - Do this\nconst nModel = MyModel.setValue( model, 42 )\nmodel === nModel // =&gt; false\nmodel.subValues === nModel.subValues // =&gt; true\n</code></pre> <p>The <code>@leverege/model-util</code> will support creating getters and setters for single values in the model, for child arrays of items, and for child maps of other values. By leveraging the ModelUtil class these can be created very easily. Once created, these Model should be registered with Plugins by invoking <code>Plugins.add( 'Model', MyModel )</code>.</p> <p>Because Models have types, they are easily used with the Plugin's Factory mechanism. Setting up a mechanism that should change behaviors based on the type of model installed is just another plugin point. Mechanisms like if/then/else logic options, color or symbol selectors, filtering or exporting of data become new plugin point Factories with the Plugins bound against the Model type.</p> <p>If you need to allow the user to edit a model, going to the ModelEditorFactory to find a React component works great. Using the immutablily principle, the Model object and UI Element's eventData mechanism, change a model via a UI Element and sending the new model value to a change listener is very easy. At the controller level of the UI, the model could be stored into a Components state, or shoved into Redux, or sent across a network. </p>"},{"location":"concepts/models/editors/","title":"Model Editors","text":""},{"location":"concepts/models/editors/#modeleditorfactory","title":"ModelEditorFactory","text":"<pre><code>import { ModelEditorFactory } from '@leverege/ui-plugin'\n</code></pre> <p>The ModelEditorFactory is a great way to dynamically edit objects when you don't want to care what they are. Consider the following code:</p> PluginSetup.jsMyModel.jsMyModelEditor.jsxSettingsEditor.jsxSetting.js <pre><code>  import MyModel from './MyModel'\nimport MyModelEditor from './MyModelEditor'\n\nexport default {\ninstall : ( molten ) =&gt; {\nmolten.addPlugin( 'Model', { type : MyModel.TYPE, model : MyModel } )\n}\n}\n</code></pre> <pre><code>  import { createAllValue } from '@leverege/model-util'\nconst type = 'my.model'\nfunction create( existing ) {\nreturn {\ntype,\nage : existing?.age,\n}\n}\nexport {\ntype,\nTYPE : type,\ncreate,\n...createAllValue( 'age', 'Age' )\n}\n</code></pre> <pre><code>  import React from 'react'\nimport { PropertyGrid, NumericInput } from '@leverege/ui-elements'\nimport MyModel from './MyModel'\n\nexport default function MyModelEditor( props ) {\nconst { value } = props\n\nconst onModelChange = useValueChange( MyModel, props )\n\nreturn (\n&lt;PropertyGrid&gt;\n&lt;PropertyGrid.Item label=\"Age\"&gt;\n&lt;NumericInput\nvalue={MyModel.getAge( value )}\nhint=\"Age\"\neventData=\"setAge\"\nonChange={onModelChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;/PropertyGrid&gt;\n)\n}\n</code></pre> <pre><code>  import React from 'react'\nimport { ModelEditorFactory } from '@leverege/ui-plugin'\n\nexport default function SettingsEditor( props ) {\nconst { settingValue } = props\nconst onChange = () =&gt; {\n// make a network call to change the setting\n}\nreturn ModelEditorFactory.create( settingValue, { value : settingValue, onChange } )\n}\n</code></pre> <pre><code>  const MyModel = './MyModel'\n\nexport default MyModel.create( { age : 32 } )\n</code></pre> <p>This allows you to create a SettingsEditor that doesn't care what the setting actually looks like. Assuming any possible setting model has a registered editor in the plugins library, that setting will be editable. This powerful paradigm is used throughout molten to edit ui settings, filter objects, re-parent Leverege devices, and so much more!</p> <p>To note some additional best practices in the code above, look specifically at the MyModelEditor file. Note that to render the field editors, we're using a combination of PropertyGrid from the Leverege ui-elements library and the useValueChange hook from the Leverege ui-hooks library. These are considered the general best practices for creating model editors, since they standardize how callbacks occur between compoonents, and the styles used when editing objects.</p>"},{"location":"concepts/models/editors/#hook-useinstancecallback","title":"Hook: useInstanceCallback","text":"<p>The purpose of this hook is to generate callbacks that do not change when new props are supplied. This can prevent excess renders from occurring on subcomponents. It is useful for proxying changes to parent components</p> <p>The hook can be invoked with either a function, or an array of functions, and the variables that should be available to the currently returned callbacks (normally props).</p> <p>Each function supplied will be given the variables and the arguments that where given to the callback.</p> <pre><code> // Static function that takes ( variables, ...args )\nfunction click( props, evt ) {\n// send the click somewhere, with maybe some extra stuff\nprops.sendClick( props.model, evt )\n} // React function. The click method above will be invoked with props and the event\nfunction myEditor( props ) {\nconst [ onClick ] = useInstanceCallback( [ click ], props )\nreturn &lt;button onClick={onClick}&gt;Do Something&lt;/button&gt;\n}\n</code></pre>"},{"location":"concepts/models/editors/#hook-usemodelchange","title":"Hook: useModelChange","text":"<p>This hook is meant to be used with the model-util (or equivalent) library and ui-element events. It makes use of the useInstanceCallback hook to invoke a method on a given mutator function and forward the result to the onChange callback. The method invoked is supplied in the event's data field.</p> <p>For example, if you have a Model Class:</p> <pre><code>const ModelUtil = require( '@leverege/model-util' )\nconst { useModelChange } = require( '@leverege/ui-hooks' )\nconst TYPE = 'armedModel'\n\nmodule.exports = {\nTYPE,\ncreate : ( ) =&gt; { return { type : TYPE, armed : true } },\n...ModelUtil.createAllValue( 'armed', 'Armed' )\n}\n</code></pre> <p>In your React function, you can use this hook like this:</p> <pre><code> function myEditor( props ) {\nconst { model } = props\nconst [ onChange ] = useModelChange( ArmedModel, props )\n\nreturn &lt;ToggleButton onChange={onChange} value={ArmedModel.getArmed( model )}     eventData=\"setArmed\"&gt;Armed&lt;/ToggleButtton&gt;\n}\n</code></pre> <p>When the ui-element ToggelButton is clicked, <code>ArmedModel.setArmed( model, event.value )</code> will be invoked. The result (newModel) from that call will be sent to <code>props.onChange( { value : newModel, data : props.eventData })</code>.</p>"},{"location":"concepts/models/editors/#hook-usevaluechange","title":"Hook: useValueChange","text":"<p>useValueChange is very similar to the useModelChange hook, with the principal difference being that it expects the model value to be in the value prop rather than the model prop.</p>"},{"location":"concepts/models/editors/#function-onmodelchange","title":"Function: onModelChange","text":"<p>The <code>useModelChange</code> hook uses the <code>onModelChange</code> method to do most of the work. It can be used in a class to avoid some code. The <code>createModelChange</code> method is supplied as a convenient class method to do this.</p> <pre><code>class MyElem extends React.Component {\n\nonChange = createModelChange( ArmedModel )\n\nrender( ) {\nreturn &lt;ToggleButton onChange={onChange} value={ArmedModel.getArmed( model )}     eventData=\"setArmed\"&gt;Armed&lt;/ToggleButtton&gt;\n}\n}\n</code></pre>"},{"location":"concepts/models/model-util/","title":"Model Util","text":"<p>The Leverege model util library <code>@leverege/model-util</code> is a helpful tool for creating and managing immutable models.</p>"},{"location":"concepts/models/model-util/#example","title":"Example","text":"<p>Let's say you have an instance of a <code>pet</code> model that looks like this:</p> <pre><code>let fluffy = {\ntype : 'pet',\nname : 'Fluffy',\nspecies : 'cat',\ncolor : 'white',\n// fluffy might be immortal\nbirthDate : '1973-01-08T00:00:00.000Z'\n}\n</code></pre> <p>And you need to be able to update the <code>species</code>, <code>color</code>, and <code>birthDate</code> of Fluffy because given their apparent immortality you're no longer convinced they're a cat. You have a couple of options do so immutably. The naive (and wrong) way to do it is as follows:</p> <pre><code>fluffy = {\n...fluffy,\nspecies : 'shapeshifter',\ncolor : 'cream',\nbirthDate : '0000-01-01T00:00:00.000Z'\n}\n</code></pre> Danger <p>Don't modify models like this, its not reproducible across the code base and is prone to errors</p> <p>The better way to modify a model is like so:</p> PetModel.jsEditFluffy.js <pre><code>const { createAllValue, createAllArray, createAllMap } = require( '@leverege/model-util' )\n\nmodule.exports = {\n...createAllValue( 'name', 'Name' ),\n...createAllValue( 'species', 'Species' ),\n...createAllValue( 'color', 'Color' ),\n...createAllValue( 'birthDate', 'BirthDate' ),\n}\n</code></pre> <pre><code>const PetModel = require( './PetModel' )\n\nlet fluffy = {\ntype : 'pet',\nname : 'Fluffy',\nspecies : 'cat',\ncolor : 'white',\n// fluffy might be immortal\nbirthDate : '1973-01-08T00:00:00.000Z'\n}\n\nfluffy = PetModel.setSpecies( fluffy, 'shapeshifter' )\nfluffy = PetModel.setColor( fluffy, 'cream' )\nfluffy = PetModel.setBirthDate( fluffy, '0000-01-01T00:00:00.000Z' )\n</code></pre>"},{"location":"concepts/models/model-util/#createallvalue-key-name-setopts-getopts","title":"createAllValue( key, name, setOpts, getOpts )","text":"<p>createAllValue will return an object like the following</p> <pre><code>{\n`set${name}`( model, newVal ) { ... },\n`get${name}`( model ) { ... }\n}\n</code></pre> <p>This can be used to get and set a value at a known key in a model</p>"},{"location":"concepts/models/model-util/#createallarray-key-name-nameplural","title":"createAllArray( key, name, namePlural )","text":"<p>discussion about normalization of this into   <pre><code>{ // adds an item into the array at a given index\n`add${name}`( model, item, insertAt ) { ... },\n// remove an item (without knowing the index in the array)\n`remove${name}`( model, item ) { ... },\n// remove an item at a given index\n`remove${name}At`( model, index ) { ... },\n// set a given index to a new value\n`set${name}`( model, index, value ) { ... },\n// swap two items in the array\n`swap${namePlural}`( model, index1, index2 ) { ... },\n// move an item to a new index\n`move${name}`( model, from, to ) { ... },\n// empty the array\n`clear${namePlural}`( model ) { ... },\n// set the whole array\n`set${namePlural}`( model, value ) { ... },\n// get an item at a known index\n`get${name}`( model, index ) { ... },\n// get the whole array\n`get${namePlural}`( model ) { ... },\n// get the index of a given item in the array (-1 if its not in the array)\n`indexOf${name}`( model, item ) { ... },\n}\n</code></pre></p>"},{"location":"concepts/models/model-util/#createallmap-key-name-nameplural","title":"createAllMap( key, name, namePlural)","text":"<p>discussion about normalization of this into   <pre><code>{\n// set a known key to a new value\n`set${name}`( model, itemKey, item ) { ... },\n// get the value at a known key\n`get${name}`( model, itemKey ) { ... },\n// check if the map has a value at a known key\n`contains${name}`( model, itemKey ) { ... },\n// remove the value at a known key\n`remove${name}`( model, itemKey ) { ... },\n// set the whole map to a new object\n`set${namePlural}`( model, object ) { ... },\n// get the whole map\n`get${namePlural}`( model ) { ... },\n// get all the entries in the map\n`get${name}Entries`( model ) {... },\n// remove all keys from the map\n`clear${namePlural}`( model ) { ... },\n}\n</code></pre></p>"},{"location":"concepts/plugins/","title":"Plugins","text":"<p>Molten makes heavy use of the <code>@leverege/plugins</code> library. This library supplies a central registration mechanism in which various classes, functions, and objects can be declared to participate in other framework's interfaces. Often this binding can occur without the need for a direct dependency on target framework. The uses for this 'repository of things' can very greatly: from dynamic url routing, to custom contextual actions, to attribute definition, to logic intercept mechanisms, to initializers, to UI editor lookups, to colorizers, to name just a few. </p>"},{"location":"concepts/plugins/#use","title":"Use","text":"<p>The use of this library can be very simple and the requirements are very few:</p> <ul> <li>Including the library in your own code</li> <li>Defining an interface for your custom plugin mechanism (sometimes called Plugin Points)</li> <li>Picking a unique plugin name for your mechanism (usually namespaced, like . ) <pre><code>import { Plugins } from '@leverege/plugin' // 1\n\nconst plgs = Plugins.get( 'myProject.Initializer' ) // 2\nplgs.forEach( ( initializer ) =&gt; { initializer.init() // 3\n} )\n</code></pre> <p>In this example, we have defined our own custom plugin point that will invoke an <code>init</code> method at the appropriate time. It has imported the library (1), asked for all plugins registered as a <code>myProject.Initializer</code> plugin (2),  and used the custom plugin point's interface to invoke init() on each plugin (3). It can be that simple to define your own custom Plugins point. </p> <p>To participate in that example plugin point, simply add a plugin to the Plugin mechanism:</p> <pre><code>import { Plugins } from '@leverege/plugin' // 1\n\nMyInitializer = { init : () =&gt; { /* do something */ } }\n\n// Alternately: molten.addPlugin( 'myProject.Initializer', MyInitializer )\nPlugins.add( 'myProject.Initializer', MyInitializer )\n</code></pre> <p>This <code>Plugins.add()</code> or <code>molten.addPlugin()</code> registers the plugin for use at the specified plugins point. Adding a plugin can be as simple as this. </p> <p>Some plugin points are a little more complicated. These plugin points will often use match objects, type values, and methods to help determine whether or not a particular plugin should be used in a particular instance. Some will define sort values to help aid in ordered invokation. Some are meant to be used in Factory lookup mechanism or participate in active Views. These extra mechanisms need to be defined by the plugin points interface documentation so developers can understand how to leverage the particular plugin point. </p>"},{"location":"concepts/plugins/#observable","title":"Observable","text":"<p>The Plugins mechanism is also observable, meaning that listeners can be registered to detect when plugins are added or removed. This can help plugin endpoints respond to new plugins or avoid ordering issues cause by importation/registration order. It can also help to support dynamic loading of code. </p> <pre><code>// Add a listener to all types\nconst unsubscribeGlobal = Plugins.on( listener )\n\n// Add a listener to a specific type\nconst unsubscribeType = Plugins.on( 'myProject.Initializer', listener )\n\n// To remove a listener from all types\nPlugins.off( listener )\n// or use the returned function\nunsubscribeGlobal() // To remove a listener from a specific type\nPlugins.off( 'myProject.Initializer', listener )\n// or use the returned function\nunsubscribeType() </code></pre> <p>The listener method will be invoked with an object when an add or remove occurs:</p> <pre><code>{ type,       // either 'pluginAdded' or 'pluginRemoved', \npluginType, // The plugin type that changed\nplugin,     // The plugin that was added or removed\nplugins     // The Plugins object \n}\n</code></pre> <p>An alternative why of determining if Plugins were added or removed without listening to Plugins is to look at the version number for a type. </p> <pre><code> const version = Plugins.getVersion( 'myProject.Initializer' )\n</code></pre> <p>Anytime a plugin is added or removed, the version number will be updated. This change detection is useful when caches are being used to record previous work using the plugins. A change to the version can be used to bust the cache and cause the work to be recalculated with the current plugin set.</p> <pre><code>  const version = Plugins.getVersion( 'myProject.PluginPoint' )\n\n// React Example\nconst result = useMemo( ( ) =&gt; {\nconst p = Plugins.get( 'myProject.PluginPoint' )\n// do some work\nreturn result\n}, [ version ] )\n\n// @leverege/value-cache example\nconst result = valueCache.calc(( ) =&gt; {\nconst p = Plugins.get( 'myProject.PluginPoint' )\n// do some work\nreturn result\n}, version )\n</code></pre>"},{"location":"concepts/plugins/config/","title":"Configuration","text":"<p>The <code>Plugins</code> mechanism supplies a way registering objects for use in different mechanisms. The <code>Config</code> mechanism supplies a single location where these plugins can supply configurable options without each interface having to make its own options mechanism.</p>"},{"location":"concepts/plugins/config/#getting-config-values","title":"Getting Config Values","text":"<p>To use the Config option in your plugin, invoke the <code>get( rsource, key, defaultValue )</code> method:</p> <pre><code>import { Config } from `@leverege/plugins`\n\nconst opt1 = Config.get( 'myProject.MyPlugin', 'option1', 12 )\n</code></pre> <p>In general, you should avoid get Config options at the time you javascript is loaded, but instead delay until when the option is needed. This will avoid any ordering issues between intialization and usage of the Config options.</p>"},{"location":"concepts/plugins/config/#setting-config-values","title":"Setting Config Values","text":"<p>To set the Config option, use <code>set( rsource, key, value )</code> method:</p> <pre><code>import { Config } from `@leverege/plugins`\n\nConfig.set( 'myProject.MyPlugin', 'option1', 42 )\n</code></pre> <p>On Molten startup, the <code>LoadConfig</code> plugin will take all options stored in Molten's config object at the path 'plugins/config' and set them on the Plugin's Config object.</p>"},{"location":"concepts/plugins/factories/","title":"Factories","text":"<p>The Factory concept encapsulates the \"I have a object, give me a way to do X with it\". This 'way' can be represented by a Class, a function or object, and is defined by the plugin point making use of the factory. What the intent of this mechanism is ( the X ), is left up to the plugin point. Examples include but are in no way limited to:</p> <ul> <li>Finding a processor for an incoming message object</li> <li>Presenting a React editor or view for an object</li> <li>Exporting an XML node that represents the object</li> <li>Finding a formatting object to convert the object to a string</li> <li>Configuring a cache mechanism to use a different backend</li> <li>Finding and configuring a color calculator for objects   </li> </ul> <p>In order to find or lookup the appropriate handling mechanism from the Factory, the object must have a <code>type</code> associated with it. By default, the factories look for the 'type' field on the object and use it to look up the mechanism registered in the factory.</p> <p>Tip</p> <p>If you are unhappy with a registered factory object (like an Editor for a Model), you can replace the install one with you own. It will be use in place of the original. Make sure your object implements all the requirements defined by the plugin point.</p>"},{"location":"concepts/plugins/factories/#creation-and-registration","title":"Creation and Registration","text":"<p>For a plugin point to use a Factory, it should use the <code>createFactory( type, options, throwError = false )</code> method to obtain and/or create it.</p> <pre><code>const factory = Plugins.createFactory( 'myProject.MyLookupType',\n{\nname : 'default',\npluginKey : 'processor',\nstrategy : Plugins.ALL\n}\n)\n</code></pre> <p>The first argument identifies the plugin point type that the Factory is using in its lookups, the second object is the options used to configure the factory:</p> Option Field Default Description name default The name of the Factory. This is used to cache the factory so it can be returned from a repeated <code>createFactory()</code> or <code>getFactory()</code> call. pluginKey plugin The key in the registered plugin that defines the item the Factory will use. pluginKeyType type The type key name used by <code>Factory.create()</code> and <code>Factory.get()</code> when finding a factory item. strategy Plugins.ALL This determines how to treat the item found in create() before it is returned. See below for strategy descriptions. defaultObject null If no look up is found for a type, this object will be used registry null The default objects in the lookup <p>To register a Plugins for use in the factory describe above:</p> <pre><code>const myFactoryPlugin = { type : 'myObjectType',\nprocessor : ( obj ) =&gt; { /* do something */ }\n}\nPlugins.add( `myProject.MyLookupType`, myFactoryPlugin )\n</code></pre> <p>In this case, the <code>type</code> defines what kind of object this processor will be used for. Because the Factory options specified <code>processor</code> as the <code>pluginKey</code>, the actual object is registered using that key. If the factory is invoked like this</p> <pre><code>const msg = { type : 'myObjectType', /* more values */ }\nconst result = factory.create( msg )\n</code></pre> <p>the <code>myFactoryPlugin.processor( msg )</code> will be invoked and its result returned. Because the stategy is <code>ALL</code> and the processor is a function, the function will be invoked will all parameters given to the <code>create()</code>.</p> <p>Different Strategy objects can be set on a Factory to allow different behaviors to occur.  When <code>create( obj, ...rest )</code> is invoked, the strategies will behave in the following ways:</p> Strategy Result Plugins.ALL This is the default strategy. If the registered item is a function, it will be invoked with <code>f( obj, ...rest )</code> and the result returned. If the registered item is a Class, <code>new Clzz( obj, ...args )</code> will be returned. Plugins.NONE If the registered item is a function, it will be invoked with no options. If the registered item is a Class, <code>new Clzz( )</code> will be returned. Plugins.ARGS If the registered item is a function, it will be invoked with <code>f( ...rest )</code> and the result returned. If the registered item is a Class, <code>new Clzz( ...args )</code> will be returned. Plugins.MERGE If the registered item is a function, it will be invoked with <code>f( { model : msg, ...rest } )</code> and the result returned. If the registered item is a Class, <code>new Clzz( { model : msg, ...args } )</code> will be returned. The <code>Plugins.mergeStrategy()</code> call can be used to create a merge strategy that will use a different key. Plugins.LOOKUP In this case, the registered object is simply returned Plugins.reactStrategy( React, propKey = 'model' ) This strategy will call React.createElement() with the registered item as the component function or class. The <code>...rest</code> object will be supplied as props to the component. If propKey is a string, the <code>obj</code> object will be given as a prop as well, using the <code>propKey</code> as the prop name. function A custom <code>function( factory, registeredItem, typeOrObject, props )</code> can be set as the strategy object as well."},{"location":"concepts/plugins/factories/#dynamic-factories","title":"Dynamic Factories","text":"<p>The Factory mechanism used in the plugin library is backed by <code>@leverege/factory</code> and augmented to include automatic registration and deregistration of plugins as they are added and removed.</p> <p>The factory mechanism can be used independently of Plugins as well - See <code>@leverege/factory</code>.</p>"},{"location":"concepts/plugins/layout/","title":"Layout","text":"<p>Sometimes, especially for UI Plugins, the Plugins need to be ordered and arranged into a tree like structure. This can be true of actions in a menu, creators in a selector, and other such mechanisms. The <code>Layout</code> is supplied as a common way to do this ordering.</p> <p>To use it:</p> <pre><code>import { Layout } from '@leverege/plugins'\n\nconst tree = Layout.create( arrayOfItems /*, { buildTree : true } */ )\n</code></pre> <p>This <code>create</code> call will look at every item in the array for a <code>layout</code> object. This object can have the following options:</p> Field Default Description sort item.name or item.type or '_z' This string is used to organize the objects into priorities. Items sorted with small sort values are higher in the list, so an 'a' will occur before a 'z' in sort order. group [] An array of strings representing groups. In a tree, items that share the group path will end up in the same node in hierarchy. groupNames [] The name of the group elements, used for human consumption. Only one item will contribute this value (the first one defining it) groupIcons [] The icon (either url or font icon) of the groups, used for human consumption. Only one item will contribute this value (the first one defining it) <p>If <code>create()</code> is called with the <code>buildTree</code> option set to false, and array of objects containing <code>{ sort, group, groupKey, groupNames, groupIcons, item }</code> will be returned.</p> <p>If <code>buildTree</code> is not set or is true, the array will be turned into a tree, where the root and groups in the tree look like:</p> <pre><code>{\ntype : 'layoutNode',\nname,\nicon,\nitems : [ ]\n}\n</code></pre> <p>The items array will contain items from the original array and other layout nodes, created in order to support the hierarchy.</p>"},{"location":"concepts/plugins/refinement/","title":"Plugin Refinement","text":"<p>There are many situations where the Plugins registered at a given plugin point are further analyzed before being used. An example of this are Actions that are presented in a toolbar or context menu. In this situation, there are many Action plugins registered, but we only want to use the Actions that desired to be seen on a particular screen or when the target object is of a particular type. This refinement can occur in different ways depending on the plugin point, but two common paradigms often occur: <code>matches</code> objects and <code>handles()</code> functions. </p> <p>Match vs Handles</p> <p>Ultimately, how plugins are selected for use depends on the plugin point. There are situations when both <code>matches</code> and <code>handles()</code> are used. When this occurs, it is usually an indication of broad stroke filter(the matches) and then a finer grain mechanism to really decide whether or not the plugin should used. An example of this is Actions in a toolbar, where the matches is used to identify the client and particular toolbar, and the handles() is use to indicate that it can be used if a particular object is selected in the context given to handles(). The client will feed different contexts to the toolbars based on which objects are selected in table, map, list or other UI mechanism.</p>"},{"location":"concepts/plugins/refinement/#matches-paradigm","title":"Matches Paradigm","text":"<p>Sometimes a plugin point will use the Matches paradigme to filter Plugins. This is often used as static, cacheable filter for all possible things that might show up in a plugin point. This paradigm has two sides: one advertised by the plugin point indicating what and/or where it is, and one on the Plugin that indicates its specific requirements. In order for a Plugin to be used, all the required fields in the Plugin's <code>matches</code> object must be met by the plugin point's <code>matchContext</code>. For example:</p> <pre><code>export default MyAction {\nmatches : {\nuse : 'actionBar',\nclient : 'MyScreen'\n}\n// ...\n}\n</code></pre> <p>This plugin is specifying that it should be used only when the plugin point specifies that the plugins are being used for an <code>actionBar</code> and the plugin point is in client called <code>MyScreen</code>. How plugin point specifies this filtered set of plugins can vary, but a simple example is to use the filter parameter on Plugins.get()</p> <pre><code>import { Plugins, Context } from '@leverege/plugin'\n\nconst matchContext = { use : 'actionBar', client :'MyScreen', mobile : false, otherParam : 'yes' }\nconst actions = Plugins.get( 'Actions', Context.createMatch( matchContext ) )\n</code></pre> <p>In this particualr case, MyAction's <code>matches.use</code> would be compared against <code>matchContext.use</code>, and <code>matches.client</code> would be compared to <code>matchContext.client</code>. Since both fields match, the Action would pass the filter an be used. The other fields in the matchContext are unused in the case of MyAction, but other plugins might use them. It is important for the plugin point creator to document the contents of the matchContext. Some common matchContext parameters are represent here, but any keys can be supplied by the plugin point. </p> Field Example client The overal type of screen or client. clientType A refinement of the client. Is sometimes the same as client mobile Is this client being used for a mobile presentation objectType The type of object being represented path The relationship path relationship A Relationship object <p>Example Note</p> <p>In the above case, the Plugins.get() is not caching its results so the filter will occur every time. This is for example purposes only, and a Plugin View should really be used instead. The Context.createMatch() is a convenience function that calls  <pre><code>plg =&gt; Match.isMatch( clientMatch, plg.matches )\n</code></pre></p>"},{"location":"concepts/plugins/refinement/#match-syntax","title":"Match Syntax","text":"<p>The <code>Match.isMatch( context, matches )</code> function has several rules it follows.</p> If matches is Result null return true. All requirements are met. Array <code>isMatch()</code> is called for each element in the array. If any ony return true, the outer <code>isMatch()</code> will return true as well. function The result of calling <code>matches( context )</code> will be returned. (it should return true or false) Object Each <code>key</code> in <code>matches</code> is evaluated against the <code>context</code>. If any one returns false, false is returned. Otherwise return true. See below for Field rules. else \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 return false. <p>Tip</p> <p>In general, it is best to use the Array or the Object when ever possible and avoid the complicated function at the field level. However, setting matches to a function and console logging the <code>context</code> is a quick way to see debug the <code>matchesContext</code> being used to evaluate your Plugin. </p> <p>When isMatch compares the fields in the matches object to the context object, it will use the following rules to evaluate each field key. The <code>matches[field]</code> and <code>context[field]</code> maybe both be arrays, in which cases each item in the <code>matches</code> is compared to each value in the <code>context</code>, and if any result in a true evaluation, the field will be considered matching.</p> <p>(For this description, V is the field value supplied in the matches object from the Plugin, and CV is the value of the field in the matchContext. R is used to indicate a recursive invokation of this rule.)</p> If the field value V Result is an Array Return true if <code>R( V[n], CV)</code> is true equals CV return true * return true if CV is non-null Starts with '!' return true if <code>V.substring(1)</code> is not equal to CV Starts with '&gt;', '&gt;=', '&lt;', '&lt;=' returns true if mathematically CV is greater than, greater than or equal to, less then, less than or equal to the V minues the comparator null return true if CV is null or undefined Object if <code>V.not</code> exists, return false if <code>R( V.not, CV)</code> returns true. If <code>V.and</code> exists, return <code>R( V.and, CV)</code>. Otherwise return true function return result of V( context, CV ) return false"},{"location":"concepts/plugins/refinement/#handles-paradigm","title":"Handles Paradigm","text":"<p>In this paradigm, the Plugin will have a <code>handle( cxt )</code> method that can return either true or false. If true, the Plugin should be used. This is very similar to Matches paradigm, though the intent is different, and these two paradigms are often used together on the same plugin point. Where the Matches paradigm may statically filter the set of Plugins down to all possible ones that might be used in this particular plugin point, the <code>handles( cxt )</code> is meant to look deeper at what is happening in that particular case to determine if the plugin can or wants participate. The context object <code>cxt</code> supplied to this method contains entries that represent the current state of the plugin point: are certain objects checked, is the user right clicking on a particular item, is an item in a list selected, etc.</p> <p>As an example, a Contextual Action Menu plugin might want to work in a table of objects of type \"vehicle\", but only want that vehicle is in an alert state and the user has permissions to send an sms message to its owner. The Matches might match against client equaling 'TableView' and its path equaling 'dealer.vehicles', while the <code>handles( cxt )</code> would check that the target object is a vehicle and the user is permissioned to send an sms. </p>"},{"location":"concepts/plugins/refinement/#context","title":"Context","text":"<p>The plugins library includes a <code>Context</code> class meant to aid in the evaluation of the <code>handles()</code> context object. On primary support supplied is in regards to the target of the given context. It can be one object or many. There could also be a secondary target, or many secondary targets. It is up to your Plugin to decide when it should participate using the given context. In the case of a Action, some can support many targets, like perhaps a bulk remove. Some may require a single primary and a single secondary target, like a pair A to B. Some may allow many targets and many secondary targets. And some may not require targets at all, but some other field in the context. </p> <p>The following methods in <code>Context</code> can help your Plugin evaluate this context object. The following target methods below will look at the 'target' key in the Context object. Normally, objects are expected to have a <code>{ type : &lt;objectType&gt; }</code> field. When this is not possible, the context can be constructed with a <code>targetType</code> field that indicates the type of targets in the target list.</p> Method Description getTarget( cxt ) Returns the first object in the target field getTargets( cxt ) Returns an Array of objects in the target field getTargetTypes( cxt ) Returns an Array of objectTypes in the target field isTargetOfType( cxt, type, only\u00a0=\u00a0true\u00a0) Returns true if the target is of the given type. When <code>isOnly</code> is true, this will also return false when there are more than one target. getTargetOfType( cxt, type, only\u00a0=\u00a0true\u00a0) Returns the object or null in the target if it is of the given type. When <code>isOnly</code> is true, this will also return null when there are more than one target. hasTargetsOfType( cxt, type, arrayCondition\u00a0=\u00a0'any\u00a0) This will return true if there are any targets in the list of the specified type. Possible options for <code>arrayCondition</code> inclue 'any', 'onlyOne', 'one', and 'all'. Using 'onlyOne' means there is only one target in the list and it is of the given type. Using 'one' means there is only one target in the list of the type. Using 'all' means all trargets must be of the specified type. getTargetsOfType( cxt, type, arrayCondition\u00a0=\u00a0'any\u00a0) This is like <code>hasTargetsOfType()</code> but an array of the targets are actually returned. <p>For secondary target evaluation, the same methods above exist but with the addition of 'Secondary' in the method name: <code>getSecondaryTargetTypes</code>, <code>isSecondaryTargetOfType</code>, <code>getSecondaryTargetOfType</code>, <code>hasSecondaryTargetsOfType</code>, <code>getSecondaryTargetsOfType</code>. These methods will use the fields called <code>secondaryTarget</code> and <code>`secondaryTargetType</code>.</p> <p>These methods are also available in a generic form where you can supply the keys to evaluate: <code>getObject</code>, <code>getObjects</code>, <code>getOfType</code>, <code>getObjectTypes</code>, <code>isObjectOfType</code>, <code>getObjectOfType</code>, <code>hasObjectsOfType</code>.</p>"},{"location":"concepts/plugins/views/","title":"Views","text":"<p>As mentioned earlier, the <code>Plugins.get( type, filter )</code> call can return a filtered set of plugins of a given type. Sometimes, however, these plugins are evaluated and organized into a more complicated structure that allows for easier and quicker access. This is where the <code>View</code> comes into play. The <code>View</code> will watch the Plugin mechanisms for Plugins that are added and removed, and mark its view as dirty when appropriate. When the View is nexted ask for its value, it can either recalculate the value or return a cached one.</p> <p>For a plugin point to use a Factory, it should use the <code>createView( type, options, throwError = false )</code> method to obtain and/or create it.</p> <pre><code>const view = Plugins.createView( 'myProject.MyLookupType', options )\n</code></pre> <p>The first argument identifies the plugin point type that the View is using , the second object is the options used to configure the factory:</p> Option Field Default Description name default The name of the View. This is used to cache the View so it can be returned from a repeated <code>createFactory()</code> or <code>getFactory()</code> call. sort defaultSort This defines the sort function used to sort the plugins. By default, the sort function uses a string sorting mechanism on the 'sort' key, but alternates functions can be used. If this is 'byNumber', a sort using a number will be installed. filter null The filter used to prune plugins from the View. If <code>processor</code> is supplied, this is not used. processor null A function that, if supplied, this is invoked with an Array of sorted  plugins. The result of this function is returned from <code>View.get()</code>. If this is not supplied, the <code>filter</code> options will be used. <p>If a processor is not supplied, <code>view.get()</code> will return an array of plugins, sorted and filtered according to those options. If the processor is given, the result from the processor defines the shape of the return value of <code>view.get()</code>.</p> <p>When a Plugin of the View's type is added or removed, the view is marked as dirty and is recalculated vi <code>processor</code> or <code>filter</code> on the next invokation of <code>view.get()</code>.</p>"},{"location":"config/","title":"Configuration","text":"<p>This describes the values in the Molten Confg.js file.</p>"},{"location":"config/#showhide-the-layout-controller","title":"Show/Hide the Layout Controller","text":"Path Description plugins/config/LayoutViewerSelector <p>Allows visibility control of the layout button in GroupScreen and ItemInfoScreen.</p> <pre><code>{\n  allowEditing : &lt;boolean&gt;;|&lt;string&gt;|&lt;function&gt;\n}\n</code></pre>         for example:         <pre><code>{\n  allowEditing : \"Installer, Admin\"\n}\n</code></pre>         Would allow user in the persona of Installer or Admin to see the buttons                 plugins/config/mapBoxPosition                 Sets default position and zoom.          <ul> <li>selectedRezoomThreshold: Indicates at what range (or less ) the view should recenter/zoom in on the selected object.</li> <li>selectedZoom: target zoom when selection occurs and rezoom threshold is exceeded. ( Negative one means dont zoom )</li> <li>pathOptions: an object where the keys are the blueprint paths to allow customization of selectedRezoom options.</li> </ul> <pre><code>{\n  center : [ -77.1902656, 39.1081595 ],\n  zoom : 18,\n  selectedRezoomThreshold : 12, // if we re beyond this range, selection will cause rezoom/center\n  selectedZoom : 18, // this is the target range to go to on selection. \n  pathOptions : {\n    building : { selectedRezoomThreshold : 10, selectedZoom : 18 }\n  }\n}\n</code></pre>"},{"location":"config/#usermanagement-resourceuser-screen","title":"UserManagement / ResourceUser Screen","text":"<p>Under plugins/config/ResourceUsers, the following keys can be set to change properties:</p> Key Default activateAccountFieldValidators null activateAccountPreSubmitComponents null activateAccountValidator () =&gt; true activateAccountCustomOnSubmit () =&gt; activateAccountSupportsLogin true userSelectorUsernameLabel Email or Username* userSelectorUsernameHint Enter Email or Username userSelectorUsernameInstructions Enter user's email or username and hit enter or next to continue. addUserTitle Add User editUserTitle Edit User addUserOkay Next editUserUpdate Update allowCreateUser true allowInviteUser true inviteEmailLabel Email* inviteEmailHint Enter Email createEmailLabel Account Email* createEmailHint ex. johnsmith@example.com createUsernameLabel Username createUsernameHint Enter Username activateEmailLabel Account Email* createNameLabel Name* createNameHint ex. John Smith createPhoneLabel Phone Number createPhoneHint ex. (555) 555-5555 createPasswordLabel Password createPasswordHint Enter password createConfirmPasswordLabel Confirm Password createConfirmPasswordHint Re-enter password screenIcon null addDialogIcon null editDialogIcon null removeUserDialogIcon null"},{"location":"config/#404-lostscreen","title":"404 / LostScreen","text":"<p>Under plugins/config/LostScreen, the following keys can be set to change properties:</p> Key Default Description title Oops! The title to put on the page message We couldn't find this page - our apologies! The sub text to display to the user button Let's find our way The label of the button on the \u2018home\u2019 link link '/' The location to take the user when the button is pressed image fa fa-meh-o The font icon or image url to display. This can also be an array of font icons and image urls. If it is an Array, one will randomly be selected and used. <p>These images are supplied as good initial resources:</p> <pre><code>LostScreen : {\n  image : [\n    'https://molten-ui-assets.storage.googleapis.com/404-UFO.png',\n    'https://molten-ui-assets.storage.googleapis.com/404-Earth.png',\n    'https://molten-ui-assets.storage.googleapis.com/404-Page.png',\n    'https://molten-ui-assets.storage.googleapis.com/404-Ghost.png'\n  ]\n}\n</code></pre>"},{"location":"config/#networkoffline","title":"NetworkOffline","text":"<p>Under plugins/config/NetworkOffline, the following keys can be set to change properties:</p> Key Default Description message Your Network connection has been lost. The message to display when network connection is lost. icon fa fa-exclamation-triangle The font icon class or image url to display with the text, when the connection is lost."},{"location":"config/#blueprintactions","title":"BlueprintActions","text":"<p>Under plugins/config/BlueprintActions, the following keys can be set to change properties:</p> Key Default Description updateIcon fa fa-pencil fa-fw The font icon class or image url to display for a blueprint update action. createIcon fa fa-plus fa-fw The font icon class or image url to display for a blueprint create action. bulkCreateIcon fa fa-plus fa-fw The font icon class or image url to display for a blueprint bulk create action. removeIcon fa fa-trash fa-fw The font icon class or image url to display for a blueprint remove action."},{"location":"config/#no-datano-search-results-views","title":"No Data/No Search Results Views","text":"<p>Under plugins/config/ where  is one of ListDataViewer or TableDataViewer the following keys can be set to change the no data/no search results views: <p>| Key | Default | Description | | noDataMessage | The class found in molten at: src/screens/shared/group/noData/NoDataView.jsx | The string or React Component/Function to render when there is no data in the table/list |</p> <p>Under plugins/config/NoDataView the following keys can be set to configure the NoDataView that is used by default</p> Key Default Description noDataTitle the name of the blueprint Can be overridden by a string in the blueprint or attribute noDataBody Looks like there's nothing here, try creating something! Can be overridden by a string in the blueprint or attribute noDataIcon https://molten-ui-assets.storage.googleapis.com/no-data.svg Can be overridden by a string in the blueprint or attribute noDataIconDimensions <code>{ height : 224, width : 224 }</code> Can be overridden by a string in the blueprint or attribute noDataDocLink null Can be overridden by a string in the blueprint or attribute noSearchResultsTitle We couldn't find any matches for that Can be overridden by a string in the blueprint or attribute noSearchResultsBody Please try searching for another item Can be overridden by a string in the blueprint or attribute noSearchResultsIcon https://molten-ui-assets.storage.googleapis.com/no-search-results.svg Can be overridden by a string in the blueprint or attribute noSearchResultsIconDimensions <code>{ height : 224, width : 224 }</code> Can be overridden by a string in the blueprint or attribute"},{"location":"config/#group-screen","title":"Group Screen","text":"Key Default Description refreshTime 30000 Number of milliseconds between data refreshes on all group screens /defaultPerPage 200 Default per page for a given relationship path defaultPerPage 200 Default per page for all GroupScreens (used as a fallback if no value specified for a specific path)"},{"location":"docs/custom-data/","title":"Adding Custom Data","text":"<p>A common need in molten is the consumption of data that is external to the leverege platform. That data might be stored locally in files, accessible through a 3rd party API, or elsewhere. Assuming the data is roughly structured as a group of items with individual items within it, the process for consuming and displaying this data on custom pages within a molten application are as follows:</p> <ol> <li>Create actions classes that mirror the Group and Item Actions</li> <li>Create a DataSource object to make those actions available</li> <li>Add custom Atrribute plugins to let the ui configure viewing the data</li> <li>Make a custom route that uses GroupScreen to view the data</li> <li>Add custom actions to CRUD the data (optional)</li> <li>Customize the search features (optional)</li> </ol> <p>This section of the documentation will serve as a tutorial for how to perform these actions and, in particular, how to set up a pet shop demo in molten that manages a list of pets</p>"},{"location":"docs/custom-data/actions/","title":"Creating Custom Actions","text":"<p>The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API.</p> <p>Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc.</p> <p>Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism)</p> <p>An example of what custom actions look like is located below</p> <p>These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the <code>src/dataSource</code> folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional.</p> <p>For the purpose of this tutorial, the most relevant functions are:</p> <p>PetsActions:</p> <ul> <li> <p>item - gets a PetActions instance relevant to a single Pet</p> </li> <li> <p>create - creates a pet in the pets list</p> </li> <li> <p>list/search - goes and gets a list of pets that match a filter object</p> </li> <li> <p>update - updates a specified pet in the list</p> </li> <li> <p>delete - deletes a specified pet from the list</p> </li> <li> <p>getList - gets the list that was requested by list/search from local state</p> </li> </ul> <p>PetActions: - parent - gets a PetsActions instance</p> <ul> <li> <p>get - goes and gets the state of a given pet</p> </li> <li> <p>update - updates the pet specified by this actions class</p> </li> <li> <p>delete - deletes the pet specified by this actions class</p> </li> <li> <p>getItem - gets the item specified by this actions class from local state</p> </li> </ul>"},{"location":"docs/custom-data/actions/#action-files","title":"Action Files","text":"PetActionsPetsActions.js <pre><code>  import { GlobalState } from '@leverege/ui-redux'\nimport { DataSources } from '@leverege/ui-attributes/lib/dataSource'\nimport ItemActions from '../../../src/dataSource/ItemActions'\n// eslint-disable-next-line import/no-cycle\nimport PetsActions from './PetsActions'\nimport PetApi from './PetApi'\n\nexport default class PetActions extends ItemActions {\n\nstatic getItem( state = GlobalState.get() ) {\nreturn PetApi.get( this.id )\n}\n\nconstructor( { match, relationship, id } ) {\nsuper()\nthis.match = match\nthis.relationship = relationship\nthis.systemId = relationship?.systemId\nthis.id = id\n}\n\ngetGroup() {\nreturn this.parent()\n}\n\n/**\n    * Returns the parent's action object. \n    */\nparent( ) {\nreturn new PetsActions( {} )\n}\n\ngetInterfaceUrl() {\nreturn this.getUrl()\n}\n\n/**\n    * Returns the url for this group action object\n    */\ngetUrl() {\nreturn `pets/${this.id}`\n}\n\n/**\n    * Returns a redux action that will call api to read a child of the current path\n    * @param {object} data values of the item to be changed\n    * @param {object} options api options\n    * @returns {function} redux thunk function\n    */\nget( ) {\n// looks like an action but doesn't touch redux\nreturn async () =&gt; {\nreturn PetApi.get( this.id )\n}\n}\n\n/**\n    * Returns a redux action that will call the api to create an item at the current path\n    * @param {object} data the data of the item to create\n    * @param {object} options a set of options\n    */\ncreate( data ) {\nreturn async () =&gt; {\nreturn PetApi.create( data )\n}\n}\n\n/**\n    * Returns a redux action that will call api to update a child of the current path\n    * @param {object} data values of the item to be changed\n    * @param {object} options api options\n    * @returns {function} redux thunk function\n    */\nupdate( data ) {\nreturn async () =&gt; {\nconst pds = DataSources.DataSourceFactory.get( 'petApi.pet' )\nconst entry = pds.getData( { id : this.id } )\nreturn PetApi.set( this.id, { ...entry, ...data } )\n}\n}\n\n/**\n    * Returns a redux action that will call api to delete a child of the current path\n    * @param {object} options api options\n    * @returns {function} redux thunk function\n    */\ndelete() {\nreturn () =&gt; {\nreturn PetApi.delete( this.id )\n}\n}\n\n// local access\ngetItem() {\nreturn PetApi.get( this.id )\n}\n\nisLoading() {\nreturn false\n}\n\nisDone() {\nreturn true\n}\n\n}\n</code></pre> <pre><code>  import { GlobalState } from '@leverege/ui-redux'\nimport PetActions from './PetActions'\nimport GroupActions from '../../../src/dataSource/GroupActions'\nimport PetApi from './PetApi'\n\nexport default class PetsAction extends GroupActions {\n\nconstructor( opts ) {\nsuper()\nthis.opts = opts\nthis.searches = {}\nthis.queryName = 'default'\n}\n\ngetGroup() {\nreturn this\n}\n\ngetInterfaceUrl() {\nreturn this.getUrl()\n}\n\n/**\n     * Returns the url for this group action object\n     */\ngetUrl() {\nreturn 'pets'\n}\n\n/**\n     * Creates a item action for the id in the group.\n     */\nitem( id ) {\nreturn new PetActions( { id } )\n}\n\nitemRef( id ) {\nreturn {\ntype : this.relationship.blueprint.type,\nref : this.getUrl(),\nid\n}\n}\n\n/**\n     * Returns a redux action that will call api to create an item as a child of the current path\n     * @param {object} obj item to be created\n     * @param {object} options api options\n     * @returns {function} redux thunk function \n     */\ncreate( obj, options ) {\nreturn async () =&gt; {\nreturn PetApi.create( obj )\n}\n}\n\n/**\n     * Create a dispatch action for a request of a list of objects\n     */\nlist( options ) {\nreturn this.search( options )\n}\n\nsearch( obj, options ) {\nreturn async ( dispatch, getState, { api } ) =&gt; {\nconst search = obj?.filter?.value\nconst queryName = options?.queryName || this.queryName\nconst perPage = obj?.perPage || obj?.limit || 200\nthis.searches[queryName] = { perPage, search }\nconst res = await PetApi.search( this.searches[queryName] )\nreturn res\n}\n}\n\n/**\n     * Returns a redux action that will call api to update a child of the current path\n     * @param {string} id id of the item to be updated\n     * @param {object} data values of the item to be changed\n     * @param {object} options api options\n     * @returns {function} redux thunk function\n     */\nupdate( id, data, options ) {\nreturn this.item( id ).update( data, options )\n}\n\n/**\n     * Returns a redux action that will call api to delete a child of the current path\n     * @param {string} id id of the item to be deleted\n     * @param {object} options api options\n     * @returns {function} redux thunk function\n     */\ndelete( id, body, options, reducerOptions ) {\nreturn this.item( id ).delete( body, options, reducerOptions )\n}\n\ngetList( state = GlobalState.get(), options ) {\nconst queryName = options?.queryName || this.queryName\nconst res = PetApi.search( this.searches[queryName] )\nreturn res\n}\n\nisLoading( state = GlobalState.get() ) {\nreturn false\n}\n\nisDone( state = GlobalState.get() ) {\nreturn true\n}\n}\n</code></pre>"},{"location":"docs/custom-data/actions/#mock-pet-api","title":"Mock Pet API","text":"<p>The mock api below simulates normal functions of an API without requiring an externally running api.  </p> <pre><code>  import B62 from '@leverege/base62-util'\nimport Gen from 'project-name-generator'\nimport { UI, GlobalState } from '@leverege/ui-redux'\nimport { Attributes } from '@leverege/ui-attributes'\n\nfunction createPet( data ) {\nreturn {\nid : B62.v4(),\ntype : 'petApi.pet',\nname : data?.name == null ? Gen().spaced : data?.name,\nage : data?.age == null ? Math.ceil( Math.random() * 20 ) : data?.age,\nposition : data?.position == null ? {\nlat : 38 + ( Math.random() - 0.5 ),\nlon : -76 + ( Math.random() - 0.5 )\n} : data?.position\n}\n}\n\n/**\n  * This is a mock of an api and thus makes no requests, in a real\n  * situation this would reach out to external data.\n  */\nclass PetApi {\n\ngenerateData = ( count = 200 ) =&gt; {\nconst data = {}\nconst list = []\nfor ( let n = 0; n &lt; count; n++ ) {\nconst p = createPet()\ndata[p.id] = p\nlist.push( p )\n}\nGlobalState.dispatch( UI.multiSet( { petList : list, petData : data } ) )\n}\n\nget( id ) {\nconst state = GlobalState.get()\nconst data = state?.ui?.petData\nreturn data?.[id]\n}\n\nset( id, newValue ) {\nconst state = GlobalState.get()\nconst data = state?.ui?.petData\nconst list = state?.ui?.petList\n\nif ( !data[id] ) {\nreturn null\n}\nconst index = list.findIndex( item =&gt; item.id === id )\n\nconst nList = [\n...list.slice( 0, index ),\nnewValue,\n...list.slice( index + 1 )\n]\nconst nData = {\n...data,\n[id] : newValue\n}\nGlobalState.dispatch( UI.multiSet( { petList : nList, petData : nData } ) )\nreturn nList\n}\n\ndelete( id ) {\nconst state = GlobalState.get()\nconst data = state?.ui?.petData\nconst list = state?.ui?.petList\n\nconst nData = { ...data }\ndelete nData[id]\nconst nList = list.filter( entry =&gt; entry.id !== id )\nGlobalState.dispatch( UI.multiSet( { petList : nList, petData : nData } ) )\n}\n\ncreate( newData ) {\nconst state = GlobalState.get()\nconst data = state?.ui?.petData\nconst list = state?.ui?.petList\n\nconst newPet = createPet( newData )\nconst nData = { ...data }\nconst nList = [ ...list ]\nnData[newPet.id] = newPet\nnList.unshift( newPet )\nGlobalState.dispatch( UI.multiSet( { petList : nList, petData : nData } ) )\n}\n\nsearch( { perPage, search } = { perPage : 200, search : null } ) {\nconst state = GlobalState.get()\nlet list = state?.ui?.petList\n\nif ( !list &amp;&amp; !this.loaded ) {\nthis.loaded = true\nprocess.nextTick( () =&gt; this.generateData() )\nreturn null\n}\n\nif ( !list ) {\nreturn null\n}\n\nconst res = list\nconst items = {}\nconst toCheck = search?.replace( /[*]/g, '' )\nif ( toCheck ) {\nconst attrs = Attributes.getAttributesFor( 'petApi.pet' )\nattrs.forEach( ( attr ) =&gt; {\nif ( attr.valueType !== 'string' ) {\nreturn\n}\nres?.forEach( ( i ) =&gt; {\nconst val = attr.get( i )\nif ( typeof val === 'string' &amp;&amp; val.toLowerCase().includes( toCheck.toLowerCase() ) ) {\nitems[i.id] = i\n}\n} )\n} )\nlist = Object.values( items )\n}\n\nreturn {\ntotal : list.length,\nstart : 0,\nperPage,\ncount : list.length,\nitems : list\n}\n}\n\n}\n\nexport default new PetApi()\n</code></pre>"},{"location":"docs/custom-data/attributes/","title":"Making Custom Attributes","text":"<p>Pets have 3 attributes (besides their id): Name, Age, and Position.</p> <p>To be able to view these attributes in a table, update form, or creation form, <code>Attribute</code> plugins must be created for them.</p> <p>Attributes plugins have a few required fields, namely:</p> <ul> <li> <p>name - The name of the Attribute, which is used to look it up along with objectType to perform common operations</p> </li> <li> <p>objectType - The type of object this Attribute is relevant to, which is used along with name to look it up to perform common operations</p> </li> <li> <p>valueType - The type of the attribute, which can be anything, but common types include <code>strings</code>, <code>numbers</code>, <code>integers</code>, <code>geoPoints</code>, <code>geoJson</code>, and <code>Timestamp</code>.</p> </li> <li> <p>get - This function is used by display and update mechanisms to get the current value of this attribute given an instance of the objectType it pertains to and some context</p> </li> <li> <p>displayName - A field of the Attribute used to display the attribute in lists for configuration or default titles</p> </li> </ul> Name AttributeAge AttributePosition AttributeSetup <pre><code>  {\nname : 'name',\nobjectType : 'petApi.pet',\nvalueType : 'string',\nget : ( data, cxt ) =&gt; { return data?.name\n},\ndisplayName : 'Name'\n}\n</code></pre> <pre><code>  {\nname : 'age',\nobjectType : 'petApi.pet',\nvalueType : 'number',\nget : ( data, cxt ) =&gt; { return data?.age\n},\ndisplayName : 'Age'\n}\n</code></pre> <pre><code>  {\nname : 'geoPosition',\nobjectType : 'petApi.pet',\nvalueType : 'geoPoint',\nget : ( data, cxt ) =&gt; { return data?.position\n},\ndisplayName : 'Position'\n}\n</code></pre> <pre><code>  molten.addPlugin( 'Attribute', NameAttribute )\nmolten.addPlugin( 'Attribute', AgeAttribute )\nmolten.addPlugin( 'Attribute', PositionAttribute )\n</code></pre>"},{"location":"docs/custom-data/data-source/","title":"Creating a DataSource","text":"<p>The second step of consuming custom data in your molten application is creating a DataSource. More general DataSource documentation can be found here</p> <p>For our use case, of creating a list of pets, the DataSource might look like this:</p> <pre><code>import { GlobalState } from '@leverege/ui-redux'\nimport PetsActions from './PetsActions'\nimport PetActions from './PetActions'\n\nexport default class PetDataSource {\n\ndataSource() {\nreturn 'petApi.pets'\n}\n\ngetData( objRef ) {\nconst state = GlobalState.get()\nconst data = state?.ui?.petData\nreturn data?.[objRef.id]\n}\n\ngetActions( objRef ) {\nif ( objRef?.id ) {\nreturn new PetActions( { item : objRef, id : objRef?.id } )\n}\nreturn new PetsActions()\n}\n\n}\n</code></pre> <p>Notice that in the getActions function we are returning instances of our PetActions and PetsActions classes as implemented in the previous step.</p>"},{"location":"docs/custom-data/molten-actions/","title":"Adding CRUD Actions","text":"<p>Beyond basic list functionality, it's easy in molten to add actions to Create, Update, and Delete items in your list if those are things your API supports.</p> <p>Below is the code for basic actions to perform these operations continuing the pet shop example.</p>"},{"location":"docs/custom-data/molten-actions/#create-action","title":"Create Action","text":"PluginCreate Pet ComponentShared Create/Edit Form <p>File CreateAction.js <pre><code>  import { Dialogs } from '@leverege/ui-elements'\nimport { Config } from '@leverege/plugin'\nimport CreatePet from '../views/CreatePet'\n\n// given a Relationship instance, make a create action that can be installed into molten\nexport default relationship =&gt; ( { id : 'action.pet.CreateItem',\nname : 'Create Pet Item',\nlayout : { sort : 'item.add' },\nhandles : cxt =&gt; true,\nappearance : ( ) =&gt; {\nreturn { name : 'Create Pet', icon : Config.get(\n'BlueprintActions',\n'createIcon',\n'https://storage.googleapis.com/molten-ui-assets/create-action.png'\n)\n}\n},\nperform : ( { context } ) =&gt; {\nconst { clientProps : { actions }, reloadData } = context\n\nDialogs.show( {\ncomponent : CreatePet,\nprops : { reloadData, actions, relationship }\n} )\n}\n} )\n</code></pre></p> <p>File CreatePet.jsx <pre><code>  import React from 'react'\nimport { Dialog, Toast } from '@leverege/ui-elements'\nimport { GlobalState } from '@leverege/ui-redux'\n\nimport CreateEditForm from './CreateEditForm'\n\nexport default function CreatePet( props ) {\nconst { show, onClose, actions, value, reloadData } = props\n\nconst onSubmit = async ( { value } ) =&gt; {\ntry {\nawait GlobalState.dispatch( actions.create( value ) )\nToast.success( 'Successfully Created Pet' )\n} catch ( err ) {\nconsole.error( err )\nToast.error( 'Failed to Create Pet' )\n}\nawait reloadData?.()\nonClose()\n}\n\nreturn (\n&lt;Dialog show={show} onClose={onClose}&gt;\n&lt;CreateEditForm\n{...props}\nvalue={value}\ntitle=\"Create Pet\"\nsubmitText=\"Submit\"\nonSubmit={onSubmit}\nonCancel={onClose} /&gt;\n&lt;/Dialog&gt;\n)\n}  </code></pre></p> <p>File CreateEditForm.jsx <pre><code>  import React from 'react'\nimport { Pane, Button, TextInput, NumericInput, PropertyGrid, Content } from '@leverege/ui-elements'\nimport { TitleBar } from '@leverege/ui-plugin'\nimport { GeoPointEditor } from '@leverege/ui-geo-elements'\n\nexport default class CreateEditForm extends React.Component {\n\nconstructor( props ) {\nsuper( props )\nconst { value } = props\nthis.state = {\nnewValue : value\n}\n}\n\nonCancel = ( evt ) =&gt; {\nconst { onCancel, eventData } = this.props\nreturn onCancel?.( { data : eventData, value : null, originalEvent : evt } )\n}\n\nonSubmit = ( evt ) =&gt; {\nconst { onSubmit, eventData } = this.props\nconst { newValue } = this.state\n\nreturn onSubmit?.( { data : eventData, value : newValue, originalEvent : evt } )\n}\n\nonAgeChange = ( evt ) =&gt; {\nconst { newValue } = this.state\nthis.setState( {\nnewValue : { ...newValue, age : evt?.value }\n} )\n}\n\nonNameChange = ( evt ) =&gt; {\nconst { newValue } = this.state\nthis.setState( {\nnewValue : { ...newValue, name : evt?.value }\n} )\n}\n\nonPositionChange = ( evt ) =&gt; {\nconst { newValue } = this.state\nthis.setState( {\nnewValue : { ...newValue, position : evt?.value }\n} )\n}\n\nrender() {\nconst { value, submitText, title, titleIcon } = this.props\nconst { newValue } = this.state\nreturn (\n&lt;Content relative&gt;\n&lt;Content.Header variant=\"formHeader\"&gt;\n&lt;TitleBar variant=\"dialogTitle\" title={title} icon={titleIcon} /&gt;\n&lt;/Content.Header&gt;\n&lt;Content.Area variant=\"formBody\"&gt;\n&lt;Pane&gt;\n&lt;PropertyGrid&gt;\n&lt;PropertyGrid.Item label=\"Name\"&gt;\n&lt;TextInput value={newValue?.name} onChange={this.onNameChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;PropertyGrid.Item label=\"Age\"&gt;\n&lt;NumericInput value={newValue?.age} onChange={this.onAgeChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;PropertyGrid.Item label=\"Position\"&gt;\n&lt;GeoPointEditor value={newValue?.position} onChange={this.onPositionChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;/PropertyGrid&gt;\n&lt;/Pane&gt;\n&lt;/Content.Area&gt;\n&lt;Content.Footer variant=\"formButtons\" layout=\"flex:rowMEnd\"&gt;\n&lt;Pane layout=\"flex:rowM\"&gt;\n&lt;Button variant=\"secondary\" onClick={this.onCancel}&gt;Cancel&lt;/Button&gt;\n&lt;Button disabled={newValue === value} variant=\"primary\" onClick={this.onSubmit}&gt;{submitText}&lt;/Button&gt;\n&lt;/Pane&gt;\n&lt;/Content.Footer&gt;\n&lt;/Content&gt;\n\n)\n}\n}\n</code></pre></p>"},{"location":"docs/custom-data/molten-actions/#update-action","title":"Update Action","text":"PluginUpdate Pet ComponentShared Create/Edit Form <p>File UpdateAction.js <pre><code>  import { Dialogs } from '@leverege/ui-elements'\nimport { Config, Context } from '@leverege/plugin'\nimport { DataSources } from '@leverege/ui-attributes'\nimport UpdatePet from '../views/UpdatePet'\n\n// given a Relationship instance, make an update action that can be installed into molten\nexport default relationship =&gt; ( { id : 'blueprint.action.pet.UpdateItem',\nname : 'Update Pet Item',\nlayout : { sort : 'item.update' },\nhandles : ( cxt ) =&gt; { const targets = Context.getTargetsOfType( cxt, 'petApi.pet' )\nreturn !( targets == null || targets.length === 0 || targets.length &gt; 1 )\n},\nappearance : ( ) =&gt; {\nreturn { name : 'Update Pet', icon : Config.get(\n'BlueprintActions',\n'updateIcon',\n'https://storage.googleapis.com/molten-ui-assets/update-action.png'\n)\n}\n},\nperform : ( { context } ) =&gt; {\nconst { reloadData } = context\nconst target = Context.getTargetOfType( context, 'petApi.pet' )\nconst actions = DataSources.getActions( target )\n\nDialogs.show( {\ncomponent : UpdatePet,\nprops : { reloadData, actions, relationship, value : target?.data }\n} )\n}\n} )\n</code></pre></p> <p>File UpdatePet.jsx <pre><code>  import React from 'react'\nimport { GlobalState } from '@leverege/ui-redux'\nimport { Dialog, Toast } from '@leverege/ui-elements'\n\nimport CreateEditForm from './CreateEditForm'\n\nexport default function UpdatePet( props ) {\nconst { show, onClose, actions, value, reloadData } = props\n\nconst onSubmit = async ( { value } ) =&gt; {\ntry {\nawait GlobalState.dispatch( actions.update( value ) )\nToast.success( 'Successfully Updated Pet' )\n} catch ( err ) {\nconsole.error( err )\nToast.error( 'Failed to Update Pet' )\n}\nawait reloadData?.()\nonClose()\n}\n\nreturn (\n&lt;Dialog show={show} onClose={onClose}&gt;\n&lt;CreateEditForm\n{...props}\nvalue={value}\ntitle=\"Update Pet\"\nsubmitText=\"Update\"\nonSubmit={onSubmit}\nonCancel={onClose} /&gt;\n&lt;/Dialog&gt;\n)\n}\n</code></pre></p> <p>File CreateEditForm.jsx <pre><code>  import React from 'react'\nimport { Pane, Button, TextInput, NumericInput, PropertyGrid, Content } from '@leverege/ui-elements'\nimport { TitleBar } from '@leverege/ui-plugin'\nimport { GeoPointEditor } from '@leverege/ui-geo-elements'\n\nexport default class CreateEditForm extends React.Component {\n\nconstructor( props ) {\nsuper( props )\nconst { value } = props\nthis.state = {\nnewValue : value\n}\n}\n\nonCancel = ( evt ) =&gt; {\nconst { onCancel, eventData } = this.props\nreturn onCancel?.( { data : eventData, value : null, originalEvent : evt } )\n}\n\nonSubmit = ( evt ) =&gt; {\nconst { onSubmit, eventData } = this.props\nconst { newValue } = this.state\n\nreturn onSubmit?.( { data : eventData, value : newValue, originalEvent : evt } )\n}\n\nonAgeChange = ( evt ) =&gt; {\nconst { newValue } = this.state\nthis.setState( {\nnewValue : { ...newValue, age : evt?.value }\n} )\n}\n\nonNameChange = ( evt ) =&gt; {\nconst { newValue } = this.state\nthis.setState( {\nnewValue : { ...newValue, name : evt?.value }\n} )\n}\n\nonPositionChange = ( evt ) =&gt; {\nconst { newValue } = this.state\nthis.setState( {\nnewValue : { ...newValue, position : evt?.value }\n} )\n}\n\nrender() {\nconst { value, submitText, title, titleIcon } = this.props\nconst { newValue } = this.state\nreturn (\n&lt;Content relative&gt;\n&lt;Content.Header variant=\"formHeader\"&gt;\n&lt;TitleBar variant=\"dialogTitle\" title={title} icon={titleIcon} /&gt;\n&lt;/Content.Header&gt;\n&lt;Content.Area variant=\"formBody\"&gt;\n&lt;Pane&gt;\n&lt;PropertyGrid&gt;\n&lt;PropertyGrid.Item label=\"Name\"&gt;\n&lt;TextInput value={newValue?.name} onChange={this.onNameChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;PropertyGrid.Item label=\"Age\"&gt;\n&lt;NumericInput value={newValue?.age} onChange={this.onAgeChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;PropertyGrid.Item label=\"Position\"&gt;\n&lt;GeoPointEditor value={newValue?.position} onChange={this.onPositionChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;/PropertyGrid&gt;\n&lt;/Pane&gt;\n&lt;/Content.Area&gt;\n&lt;Content.Footer variant=\"formButtons\" layout=\"flex:rowMEnd\"&gt;\n&lt;Pane layout=\"flex:rowM\"&gt;\n&lt;Button variant=\"secondary\" onClick={this.onCancel}&gt;Cancel&lt;/Button&gt;\n&lt;Button disabled={newValue === value} variant=\"primary\" onClick={this.onSubmit}&gt;{submitText}&lt;/Button&gt;\n&lt;/Pane&gt;\n&lt;/Content.Footer&gt;\n&lt;/Content&gt;\n\n)\n}\n}\n</code></pre></p>"},{"location":"docs/custom-data/molten-actions/#delete-action","title":"Delete Action","text":"PluginDelete Pet Component <p>File DeleteAction.js <pre><code>import { Context, Config } from '@leverege/plugin'\nimport { Dialogs } from '@leverege/ui-elements'\nimport DeletePet from '../views/DeletePet'\n\nexport default ( relationship, { objectType, name, namePlural } ) =&gt; {\nconst { path, attribute } = relationship\nconst sectionName = `${name} Actions`\n\nreturn {\nid : `action.${path}.DeleteItem`,\nname : `Delete ${namePlural} Items`,\nlayout : { sort : 'item.zzz', sectionName },\nhandles : ( cxt ) =&gt; { const targets = Context.getTargetsOfType( cxt, objectType )\nreturn !( targets == null || targets.length === 0 )\n},\nappearance : ( { context, action } ) =&gt; { const targets = Context.getTargetsOfType( context, objectType )\nconst num = targets.length\nreturn { name : num &lt; 2 ? `Delete ${name}` : `Delete ${num} ${namePlural}`,\nicon : Config.get(\n'PetActions',\n'deleteIcon',\n'https://storage.googleapis.com/molten-ui-assets/delete-action.png'\n),\ndisabled : num === 0\n}\n},\nperform : ( { context } ) =&gt; { const { clientProps : { actions, targetKey } } = context\nconst targets = Context.getTargetsOfType( context, objectType )\nif ( targets.length === 0 ) {\nreturn\n}\nDialogs.show( {\ncomponent : DeletePet,\nprops : {\ntargets,\nactions,\nattribute,\nisItem : false,\nselectionKey : targetKey,\n} } )\n}\n}\n}\n</code></pre></p> <p>File DeletePet.jsx <pre><code>  /* eslint-disable no-await-in-loop */\nimport React from 'react'\nimport { DataSources } from '@leverege/ui-attributes'\nimport { GlobalState, Selection } from '@leverege/ui-redux'\nimport { Dialog, Toast } from '@leverege/ui-elements'\n\n/**\n  * Removes the userIds from the given action.\n  */\nasync function onRemove( { data } ) {\n\n// Get parameters\nconst { targets, selectionKey, onClose } = data\nconst num = targets.length\nif ( num === 0 ) {\nonClose()\nreturn\n}\n// Try to remove users\nlet success = 0\nlet failure = 0\nlet err = null\n\nfor ( let n = 0; n &lt; num; n++ ) {\ntry { const tgt = targets[n]\nconst actions = DataSources.getActions( tgt )\nawait GlobalState.dispatch( actions.delete() )\nsuccess++\nif ( selectionKey ) {\nGlobalState.dispatch( Selection.remove( selectionKey, tgt.id ) )\n}\n} catch ( error ) {\nfailure++\nif ( err == null ) {\nerr = error\n}\n// eslint-disable-next-line no-console\nconsole.error( error )\n}\n}\n\n// Successfully removed\nif ( failure === 0 ) {\nToast.success( `${success === 1 ? '' : num} Pet${num === 1 ? '' : 's'} Deleted` )\n} else if ( success === 0 ) {\nToast.error( [ `Failed to Delete ${failure === 1 ? '' : num} Pet`, err.message ] )\n} else {\nToast.warn( [ `Deleted ${success}/${num} Pet. Failed to delete ${failure}.`, err.message ] )\n}\nonClose()\n}\n\n/**\n  * Remove users dialog.\n  */\nexport default function DeletePet( props ) {\n\n// Get parameters\nconst { onClose, show, targets } = props\n\nconst num = targets?.length || 0\nconst title = num &lt; 2 ? 'Pet' : `${num} Pets`\nconst button = 'Delete'\nconst titleType = 'Delete'\nconst extra = `This will permanently delete the ${title} and cannot be undone.`\n\n// Render component\nreturn (\n&lt;Dialog.Question\nshow={show}\neventData={props}\ntitle={`${titleType} ${title}?`}\nmessage={`Are you sure you want to DELETE ${num} Pet${num === 1 ? '' : 's'}? ${extra}`}\nokay={button}\nokayVariant=\"primaryDestructive\"\nonCancel={onClose}\nonOkay={onRemove}/&gt;\n)\n}\n</code></pre></p>"},{"location":"docs/custom-data/molten-actions/#setup","title":"Setup","text":"<p>File PluginSetup.js <pre><code>import DeleteAction from './DeleteAction'\nimport CreateAction from './CreateAction'\nimport UpdateAction from './UpdateAction'\nimport Relationship from '../../../src/dataSource/Relationship'\n\nconst objectType = 'petApi.pet'\nconst name = 'Pet'\nconst namePlural = 'Pets'\n\nexports.install = ( molten ) =&gt; {\n\nconst relationship = new Relationship( { apiName : 'petApi',\nname : 'pets',\nobjectType,\npath : 'petApi.pets',\nrefPath : '/pets',\nurlPath : '/pets',\n} )\n\nmolten.addPlugin( 'Action', DeleteAction( relationship, { objectType, name, namePlural } ) )\nmolten.addPlugin( 'Action', CreateAction( relationship, { objectType, name, namePlural } ) )\nmolten.addPlugin( 'Action', UpdateAction( relationship, { objectType, name, namePlural } ) )\n}\n</code></pre></p>"},{"location":"docs/custom-data/routes/","title":"Creating a Route","text":"<p>Once you have actions, a dataSource, and ui-attributes, the next step is to create a screen. For this example we intend to re-use the GroupScreen.</p>"},{"location":"docs/custom-data/routes/#using-groupscreen","title":"Using GroupScreen","text":"<p>If you've been following along so far, using the GroupScreen is easy! All of the hard work came from the implementation of your DataSource and Action classes earlier.</p> <p>Assuming you stuck to the interface as specified previously, all you have to do to use the GroupScreen is include it as the component in your route (seen in the next step), and pass it the right props, namely:</p> <ul> <li> <p>objectType - in this case petApi.pet, but just the type you picked for you items</p> </li> <li> <p>relationship - an instance of the Relationship class from molten</p> </li> <li> <p>actions - an instance of your PetsActions class from before</p> </li> </ul> <p>This will look like this: <pre><code>const props = {\nobjectType : 'petApi.pet',\nrelationship : new Relationship( { apiName : 'petApi',\nname : 'pets',\nobjectType : 'petApi.pet',\npath : 'petApi.pets',\nrefPath : '/pets',\nurlPath : '/pets'\n} ),\nactions : new PetsActions()\n}\n</code></pre></p>"},{"location":"docs/custom-data/routes/#installing-the-route","title":"Installing the Route","text":"<p><code>Route</code>s are another type of plugin, and have several required keys. The Pets Screen <code>Route</code> plugin looks like this:</p> <pre><code>  {\n// all plugins need a unique id\nid : 'pets.route.PetScreen',\n// what is the url of the route? This will be prefixed in the final ui\n// by the molten baseRoute, which may include additional information like\n// systemId and person\npath : '/pets/',\n// whether or not the path has to be an exact match to render\nexact : true,\n// where in the ui the route will go. This means it\n// will be rendered at the route inside the Main Screen.\n// This is common for root level ui screens.\nmatches : { client : 'Main' }, // what React component is rendered by the route (this is the molten GroupScreen)\ncomponent : GroupScreen,\n// what props should be passed to the GroupScreen\nprops : {\nobjectType : 'petApi.pet',\nrelationship : new Relationship( { apiName : 'petApi',\nname : 'pets',\nobjectType : 'petApi.pet',\npath : 'petApi.pets',\nrefPath : '/pets',\nurlPath : '/pets'\n} ),\nactions : new PetsActions()\n}\n}\n</code></pre> <p>and is installed like so: <pre><code>  molten.addPlugin( 'Route', PetRoute )\n</code></pre></p> <p>Of course without a way to get to that route in the ui, its not particularly useful! The best way to install a link to your new pet shop route is with a LinkAction, which can be created and installed like so: <pre><code>  // this import is different when working from the molten demo folder\nimport { LinkAction } from '@leverege/molten/lib/routes'\n\nconst PetLink = LinkAction.create( {\nid : 'pet.PetsLink',\nmatches : { use : 'navBar', client : 'Main' },\nname : 'Pets', icon : 'fa fa-bug fa-fw',\npath : '/pets'\n} )\n\nmolten.addPlugin( 'Action', PetLink )\n</code></pre></p>"},{"location":"docs/custom-data/search/","title":"Customizing Search","text":"<p>If optionally you wish to add the ability for users to free text search your list of items (and your API supports such functionality), you can add just a couple of plugins to do so.</p> <p>The first thing you need to add is a SearchBar plugin, which will look something like this:</p>"},{"location":"docs/custom-data/search/#searchbar-plugin-installation","title":"SearchBar Plugin installation","text":"<p>A SearchBar at its core is a DataViewer, so it's installed using that plugin type, but specifically tuned to be used as a search plugin on GroupScreen's</p> <pre><code>molten.addPlugin( 'DataViewer', {\nid : 'molten.dataViewer.search.PetSearchBar',\ntype : 'molten.Search',\nname : 'Search Bar',\nicon : 'fa fa-search fa-fw',\n// this is what tells the GroupScreen where to put this plugin\nlocation : [ 'search' ],\n// this search bar can only be used against group screens of petApi.pet's\nmatches : {\ntype : 'GroupDataViewer',\nobjectType : 'petApi.pet'\n},\ncomponent : SearchBar,\n} )\n</code></pre>"},{"location":"docs/custom-data/search/#searchbar-component","title":"SearchBar Component","text":"<p>For the ease of the pet shop demo, we opted to use the SearchBar from molten, and simply wrap it to adjust some of its props</p> <pre><code>import React from 'react'\nimport ResponsiveSearchBar from '../../../src/screens/group/search/SearchBar'\n\nexport default function SearchBar( props ) {\nconst { objectType, path } = props\nconst client = 'molten.group.SearchBar'\n// changing the use prevents Imagine API suggestions from being rendered, which would break\nconst suggestionsMatchContext = { use : 'petApi.suggestions', client, objectType, path }\nreturn &lt;ResponsiveSearchBar {...props} suggestionsMatchContext={suggestionsMatchContext} /&gt;\n}\n</code></pre>"},{"location":"docs/custom-data/search/#suggestions-plugin-installation","title":"Suggestions Plugin Installation","text":"<p>SearchSuggesters are a specialized plugin that allows you to tack additional suggestions onto any search bar (not just the pet shop one!)</p> <pre><code>molten.addPlugin( 'SearchSuggester', {\nid : 'petApi.Suggestions',\nname : 'API Suggestions',\n// NOTE: this use matches the use from the SearchBar component suggestionsMatchContext\nmatches : { use : 'petApi.suggestions', client : 'molten.group.SearchBar' },\nhandles : () =&gt; true,\n// could be useful for storing recent searches\nonSearchChange : ( { search } ) =&gt; {},\nsuggestions : Suggestions\n} )\n</code></pre>"},{"location":"docs/custom-data/search/#suggestions-component","title":"Suggestions Component","text":"<p>This component as a note is very similar to the ApiSuggestions in the molten library, but with some changes to make it work with the pet shop example.</p>"},{"location":"docs/custom-data/search/#get-suggestions-function","title":"Get Suggestions Function","text":"<pre><code>import { GlobalState } from '@leverege/ui-redux'\nimport { Attributes } from '@leverege/ui-attributes'\nimport Path from '@leverege/path'\nimport { Config } from '@leverege/plugin'\nimport Model from '../../../src/screens/group/search/filter/GroupedTextFilterModel'\n\nconst getSuggestions = async ( actions, filter, search, objectType, api ) =&gt; {\nconst f = filter\nconst res = await GlobalState.dispatch( actions.search( {\nfilter : f ? { ...f, value : Model.toImagineValue( search, filter, objectType ) } : null,\nlimit : 100\n}, { queryName : 'searchSuggestions' } ) )\nconst items = {}\nconst toCheck = Model.getLastToken( search ).toLowerCase()\nif ( f?.fields &amp;&amp; f.fields.length &gt; 0 ) {\nf.fields.forEach( ( field ) =&gt; {\nlet accessor = () =&gt; null\nif ( typeof field === 'string' ) {\naccessor = Path( field ) } else if ( typeof field === 'object' &amp;&amp; field?.field ) {\naccessor = Path( field.field )\n}\nres?.items.forEach( ( i ) =&gt; {\nconst val = accessor.get( i )\nif ( typeof val === 'string' &amp;&amp; val.toLowerCase().includes( toCheck ) ) {\nitems[val] = true\n}\n} )\n} )\n} else {\nconst attrs = Attributes.getAttributesFor( objectType )\nattrs.forEach( ( attr ) =&gt; {\nif ( attr.valueType !== 'string' ) {\nreturn\n}\nres?.items.forEach( ( i ) =&gt; {\nconst val = attr.get( i )\nif ( typeof val === 'string' &amp;&amp; val.toLowerCase().includes( toCheck ) ) {\nitems[val] = true\n}\n} )\n} )\n}\nreturn Object.keys( items )\n}\n\nconst updateSuggestions = ( opts ) =&gt; {\nconst { actions, filterModel, search, objectType } = opts\nconst filter = Model.toImagineFilter( filterModel, objectType )\nif ( !search || Model.getLastToken( search ).length &lt; Config.get( 'ApiSuggestions', 'minSuggestionLength', 3 ) ) {\nopts.setItems( [] )\nreturn Promise.resolve( [] )\n}\n// do this so we can get at the raw api object and not touch api-redux\nreturn new Promise( ( resolve ) =&gt; {\nprocess.nextTick(\nGlobalState.dispatch,\nasync ( dispatch, getState, { api } ) =&gt; {\nconst items = await getSuggestions( actions, filter, search, objectType, api )\nopts.setItems( items )\nresolve( items )\n}\n)\n} )\n}\n\nexport {\nupdateSuggestions,\ngetSuggestions\n}\n</code></pre>"},{"location":"docs/custom-data/search/#suggestion-component","title":"Suggestion Component","text":"<pre><code>import React from 'react'\nimport Suggestion from '../../../src/screens/group/search/suggestions/Suggestion'\n\n// an individual suggestion\nexport default function PetSuggestion( props ) {\nconst { item, search } = props\nconst match = item?.toLowerCase().lastIndexOf( search?.toLowerCase() )\n\nif (\n!item ||\nmatch &lt; 0 ||\nitem?.toLowerCase() === search?.toLowerCase() ||\nsearch?.toLowerCase().endsWith( item?.toLowerCase() )\n) {\nreturn null\n}\n\nconst contents = (\n&lt;&gt;\n{item.slice( 0, match )}\n&lt;b&gt;{item.slice( match, match + search.length )}&lt;/b&gt;\n{item.slice( match + search.length )}\n&lt;/&gt;\n)\n\nreturn (\n&lt;Suggestion {...props} newSearch={item} contents={contents} /&gt;\n)\n}\n</code></pre>"},{"location":"docs/custom-data/search/#suggestions-component_1","title":"Suggestions Component","text":"<pre><code>import React from 'react'\nimport { Config } from '@leverege/plugin'\n\nimport Suggestion from './Suggestion'\nimport Suggestions from '../../../src/screens/group/search/suggestions/Suggestions'\nimport { updateSuggestions } from './Util'\n\nconst searchLongEnough = ( search ) =&gt; {\nreturn search?.length &gt;= Config.get( 'ApiSuggestions', 'minSuggestionLength', 3 )\n}\n\n// a list of suggestions\nexport default function PetSuggestions( props ) {\nreturn (\n&lt;Suggestions\n{...props}\nupdateSuggestions={updateSuggestions}\nsearchLongEnough={searchLongEnough}\nsuggestionClass={Suggestion}\nminSuggestionLength={Config.get( 'ApiSuggestions', 'minSuggestionLength', 3 )}\nsearchDebounceMs={Config.get( 'ApiSuggestions', 'searchDebounceMs', 100 )} /&gt;\n)\n}\n</code></pre>"},{"location":"docs/data-sources/","title":"Data Sources","text":"<p>The purpose of a DataSource plugin is to provide a mechanism by which molten can access data about and acquire \"actions\" against a particular type of object.</p> <p>Data Sources themselves are a @leverege/ui-attributes concept, and more information can be found about them here An example of a fleshed out DataSource class can be found at <code>src/blueprints/dataSource/BlueprintDataSource.js</code> or <code>demo/pets/dataSource/PetDataSource.js</code></p>"},{"location":"docs/data-viewers/","title":"Data Viewers","text":"<p>Data Viewers are widgets that are used to display viewers and editors about a certain data set. The root controller will load the base data and supply it to the data viewers as props. The root controller will manage the layout and its models, which allows data viewers to be added and removed in particular locations. The root Layout consists of two main sections and four surrounding auxilary sections ( top, bottom, left, right ). These sections are fixed to the screen current screen size, meaning that they do now scroll off the screen: the top is fixed to the top of the area, the bottom to the bottom, left and right to the sides, and the remaining section is divided amongst the two main sections. Any one of these sections can be null, and its space is given to the other data viewers. A special DashboardDataViewer that support Cards allows these sections to be further divided and scrolled.</p> <p>DataViewers are made available for use via the Plugins mechanism under the key <code>DataViewer</code>. DataViewer plugins will act handle to the various parts of the DataViewer: the name/usage, the DataViewer's settings model, and the React component used to display the data to the user. The DataViewer's interface looks like this:</p> Filed Type Description id string The unique DataViewer plugin id type string The unique type of the DataViewer. name string The human readable name of the plugin icon string The url or font icon class name of the image used to represent the icon. location string or array of strings Specifies where in the layout the DataViewer is usable. See Locations matches object or function This is used to determine if the DataViewer should be used in controllers layout. See below. createSettings function(props) Creates and returns the DataViewer's Settings model. updateSettings funciton Optional function( { settings, props } ) to allow upgrading of the settings model. component React.Component A react component to use to render. Only this or <code>render</code> should be supplied. render function A function given props. It should return the create react component. Only this or <code>component</code> should be supplied. getCardTitle function Used with <code>card</code> location. A <code>function( model, dashboardContext )</code> that returns the card's title, if it is visible getCardIcon function Used with <code>card</code> location. A <code>function( model, dashboardContext )</code> that returns the card's icon, if it is visible getCardRequired function Used with <code>card</code> location. This <code>( model, factory, dashboardContext )</code> returns the required support models/editors that should be present at the dashboards root. getCardMenuEditor function Used with <code>card</code> location. A <code>function( props )</code> that returns an editor for the card's editor menu. getCardFooterEditor function Used with <code>card</code> location. A <code>function( props )</code> that returns an editor for the card footer. getDefaultCardContentOptions object or function Used with <code>card</code> location. A <code>function( props, dashboardContext )</code> that returns an object that can specify the card contents height, minHeight, and maxHeight. or an object such as { height : '300px' }. The props are the same as the dashboardContext.sharedProps object, which will the props given to the DataViewer. getDefaultCardOptions object or function Used with <code>card</code> location. A <code>function( props, dashboardContext )</code> that returns an object that can specify the card default card options, such as width (span), height (span), style, titleVisible or or an object such as { width : 2 } The props are the same as the dashboardContext.sharedProps object, which will the props given to the DataViewer"},{"location":"docs/data-viewers/#match-context","title":"Match Context","text":"<p>Not all DataViewers will work with all root controllers. The DataViewers will use the match mechanism to determine if the root controller supplies the appropriated context that will allow the DataViewer to work. The root controller defines the match context used when determining the possible DataViewers to use and can consist any fields. In Molten, the GroupScreen and ItemInfoScreen are used alot. Their match contexts look like this:</p> Match Field Value Meaning type 'GroupDataViewer' or 'ItemInfoDataViewer' This is legacy, and defines a similar concept as the client below. client 'GroupScreen' or 'ItemInfoScreen' This is the type of the root controller. clientType string The specific client type. If the implementation does not supply this, it will be either 'GroupScreen' or 'ItemInfoScreen' path string The relationship path objectType string The type of objects at the relationship path relationship Relationship The relationship object mobile boolean True or false depending on if this is a mobile client or desktop client"},{"location":"docs/data-viewers/#location-strings","title":"Location Strings","text":"<p>DataViewers can restrict where they can be used via its location field:</p> Location String Meaning main This DataViewer can be used the two center layout sections. aux This DataViewer can be used the on of the four auxilary sections. card This DataViewer can be used as a card in the DashboardDataViewer. Its DataViewer can have card specific functions. any This is the same as [ 'main', 'aux', 'card' ] hidden All hidden data viewers are loaded for the layout, but will not be seen. The purpose of hidden DataViewers is to load or prepare other data. It should be a viewless component, meaning its render function returns null. support Not for use by the root controller, but meant as support for other DataViewers."},{"location":"docs/data-viewers/#example","title":"Example","text":"DataViewerSetup <p>File MyDataViewer.js. <pre><code>  import I18N from '@leverege/i18n'\nconst { tf, tfIcon } = I18N.ns( 'my.MyDataViewer' )\n\nexport default {\nid : 'my.MyDataViewer',\ntype : 'my.MyDataViewer',\nname : tf( 'name' ),\nicon : tfIcon( 'configIcon' ),\nlocation : [ 'main' ],\nmatches : { client : 'GroupScreen },\ncreateSettings : ( props ) =&gt; {\nreturn MyDataViewerModel.create()\n},\nsettingsUpdaters : ( { settings, ...opts } ) =&gt; { },\ncomponent : MyDataView,\n}\n</code></pre></p> <p>Be sure to install your plugin in your PluginSetup.js file. <pre><code>  molten.addPlugin( 'DataViewer', MyDataViewer )\n</code></pre></p>"},{"location":"docs/data-viewers/#groupscreen-and-iteminfoscreen-dataviewer-props","title":"GroupScreen and ItemInfoScreen DataViewer Props","text":"<p>When a DataViewer is used in a GroupScreen or ItemInfoScreen, the following props will be supplied the Component or render function.</p> Prop Type Description ... All of the fields in the match context actions object Deprecated. The Delegate object data object The current data. The data.items maybe sparce if multiple non-sequential pages have been loaded. Use the pagination to access a single page. The values in data are dataViewer DataViewer The DataViewer dataViewerId string The id of the data from the LayoutModel dataViewerInstanceId string An id tied to the current incarnation of the data viewer component. Useful as a key in dashboard style layouts. Using dataViewerId in a situation like this can lead to duplicate ids when a data viewer's model is copied dataViewerModel object The DataViewerModel dataViewers DataViewer Object containing the available data viewers and context. { context : {...}, dataViewers : [...] } delegate object An object used to request creations, delections, etc from the server. The actions should be dispatched. dispatch object The redux dispatch filter object The FilterSourceModel. This is only present in the GroupScreen. filterName string The key used to store the filter object within the FilterSourcesModel. Used as then <code>data</code> property when calling the onFilterChange function. This is only present in the GroupScreen. filters object The FiltersSourceModel. This is only present in the GroupScreen. history object The connected react router history object isMobile boolean True or false depending on if this is a mobile client or desktop client. repeat of mobile. item ObjRef The current object ref. This is only present in the ItemInfoScreen. layout object The root layout model. (GroupScreen only) loading boolean True if the data is being loaded location object The connected react router location object match object The connected react router match object model boolean The <code>settings</code> component of the dataViewerModel objectType string The object type, which is the blueprint's alias or id onFilterChange function Invoke this when the data screen wishes to change its contribution to the filter and sort. The argument should be an event contining { data : filterName, value : newFilterModelObject }. This is only present in the GroupScreen. onSettingsChange function the function to call to modify the settings object. overrideModel Obejct The current overrides for this data viewer. May be null. Key value pairs set using overrides. overrides Obejct Use overrides.set( dataViewerId, key, value ) to store settings outside of settings model. paginator object The object used to manage pagination. parentItem ObjRef The parent object ref, if available. path string The data path of the current screen (e.g. location.vehicles) profile object The current users profile reloadData function A function to call to retrigger data loading rolloverKey string The key used with Selections to manage objects that are rolled over selectionKey string The key used with Selections to manage objects that are selected settings object The DataViewer's settings model: settingsData any DataViewers must give this as the data option to the change event fired in onSettingChanged settingsPath string The path used with UserSettings to save data. targetKey string The key used with Selections to manage objects that are targeted vertical boolean If the DataViewer is used in a header/footer capacity, this will indicate the direction the component will be layed out. This is undefined for primary DataViewers."},{"location":"docs/editors/","title":"Editors","text":"<p>In order to edit any type of data, it is important to provide an editing UI and optionally some data validation. Molten provides a default set of editors and validators for most data types (string, number, int, boolean, etc.), but sometimes it is desirable to add a new data type OR to override the default editor/validator type for a particular object Attribute. These aims can be accomplished through the use of only 3 plugin types, <code>AttributeValueEditor</code>, <code>AttributeValueValidator</code> and <code>AttributeObjectValidator</code>.</p>"},{"location":"docs/editors/#attributevalueeditor","title":"AttributeValueEditor","text":"<p>Attributes can be edited in Tables, Detail Blocks and in dedicated Forms. In all of these cases, the form fields will be rendered using the single <code>AttributeValueEditor</code> plugin point. <code>AttributeValueEditor</code> plugins consist of a valueType (string, number, int, boolean, etc.), an optional name and objectType, which is the name of the attribute that the editor should be tied to (e.g. location.position) and it's objectType (e.g. location), a getOptions function for supplying and additional options to the component and a create function, which is given props and context for the editor and should return a React element. Here is a simple example which is the built-in string editor: <pre><code>const opts = { table : { embed : true, isRenderer : false },\ndetail : { embed : true, isRenderer : false }\n}\n\nexport default {\nvalueType : 'string',\ngetOptions : ( usage ) =&gt; { return Config.get( 'AttributeStringEditor', usage, opts[usage] ) },\ncreate : ( opts ) =&gt; {\nconst { usage, style, context, attribute, editable, canSet, variant, ...options } = opts\n\nreturn (\n&lt;TextInput\nstyle={style} // This makes it follow colorizers\nvariant={EditorUtil.getVariant( usage, 'string', 'editor' )}\n{...options}\nautoFocus={usage !== 'form'}\nonDoubleClick={stopProp} /&gt;\n)\n}\n}\n</code></pre></p>"},{"location":"docs/editors/#getoptions","title":"getOptions","text":"<p>The getOptions function here is returning an object keyed by <code>usage</code> string (more on that below). The options here are embed and isRenderer. The <code>embed</code> option controls whether the editor should be shown in place in a table or detail as opposed to being popped out into a dialog view. <code>isRenderer</code> controls whether this view should be used regardless of whether the <code>editable</code> flag (more on this below) is set to true or false (ie whether this editor should also serve as a \"viewer\"). This is sometimes advantageous when the data that is being shown is slightly more complex than a basic value type. For instance, the stored value of an enum field would be a simple string value, but the display value for the enum should be another, more human readable string value that is stored with the enum definition. Defining an enum editor as a renderer as well gives you the oportunity to fetch that data (if necessary) and map the label string to the value string for display.</p>"},{"location":"docs/editors/#create","title":"create","text":"<p>The <code>create</code> function here returns a simple TextInput element which allows the user to edit the value of this string field. Important properties that are passed to this create function are:</p> Field Description usage The usage field will contain a string value representing where this editor is being renderered. Examples include <code>table</code>, <code>detail</code> and <code>form</code>. In this simple case, the usage field is not used, but for some editors, it might be important or desirable to render the editor differently depending on which of these different places it is appearing. The usage field allows a developer to branch their rendering logic in this way. style In molten, users are able to configure options for how they would like their data to appear. This may be as simple as the color of text but may change all sorts of different aspects of a fields appearance. The style field is an object of style attributes, appropriate for passing to a React component that has been extracted from a user's configuration for this field. It is good practice to try to apply these styles so that the value of the field appears as a user expects. context The context property passes many useful other properties from the parent rendering context. Generally, these are the props that are passed down to a GroupScreen or ItemScreen attribute The Attribute object that is being edited editable Whether or not editing mode has been turned on for this view. Note that some types of views, like forms, are always in edit mode. This property will always be true in that case. In the case where an editor is not a renderer as well, the editable property needn't be used since a different view will be rendered when not in edit mode canSet Whether the user has permission to edit this field. variant Like the style attribute, the variant attribute is a value resolved from user preferences and configuration and when possible should be passed to the underlying React component to allow proper styling eventData Event data is generally a string indicating which field the editor is editing. It should be passed to the editor component and if the editor is not a standard editor component from the @leverege/ui-elements library, it should be passed as the <code>data</code> field when calling the <code>onChange</code> function. onChange A function to be called when the value of the field changes. The format for the call should be: <code>{ data : eventData, value : newValue }</code>. If multiple fields are being changed, an object version of the change event can be used: <pre><code>{ { data : {  [attribute.name] : attribute.name,  [otherAttribute.name] : otherAttribute.name  }, value : {  [attribute.name] : attributeValue,  [otherAttribute.name] : otherAttributeValue  } } }</code>"},{"location":"docs/editors/#attributevaluevalidator","title":"AttributeValueValidator","text":"<p>It is often important that validation occur on an attribute when it is being edited. Molten provides a set of default validators that ensure that values fall broadly in line with their declared value types (a string field should accept only string values, for instance). Further field validation can be achieved using an <code>AttributeValueValidator</code>. These plugins are passed to an ObjectValidator instance from the @leverege/object-validator library. Documentation on how to create a validator can be found in that library's README.md. In order to register an AttributeValueValidator for a particular object field in molten, you would do something similar to the included-by-default AlphaNumeric validator that molten provides:\n<pre><code>import { z } from 'zod'\n\nconst ALPHA_REGEX = /^[0-9a-zA-Z\\s]+$/\n\nconst validator = ( value ) =&gt; {\nif ( value == null ) {\nreturn true\n}\n\nif ( Array.isArray( value ) ) {\nreturn value.every( val =&gt; ALPHA_REGEX.test( val ) )\n}\n\nreturn ALPHA_REGEX.test( value )\n}\n\nmolten.addPlugin( 'AttributeValueValidator', {\nname,\nobjectType,\nvalueValidator : z.custom( validator, opts )\n} )\n</code></pre>\nHere the validator is registered to a particular attribute name and objectType, for instance <code>location.name</code> and <code>location</code>, respectively. This ensures that whenever a user attrmpts to change the name of a location (whether in a form, a table, or anywhere else), that input will be validated using this validator (and indeed, any additional registered validators). Additional options, such as custom validation failure messages can be explored in the documentation for the @leverege/object-validator library.</p>"},{"location":"docs/editors/#labeldecorator","title":"labelDecorator","text":"<p>One addtional useful feature of the <code>AttributeValueValidator</code> is the optional <code>labelDecorator</code> field. The <code>labelDecorator</code> is a function that is called with the original label value for a form field (if the field is being displayed in a form) and from which you can return an altered or \"decorated\" label. A common use of this option would be to add an asterix to any field that is required, as molten does in its default RequiredValidator:\n<pre><code>molten.addPlugin( 'AttributeValueValidator', {\nname,\nobjectType,\nlabelDecorator : ( value ) =&gt; {\nreturn `${value} *`\n},\nvalueValidator : z.custom( ( val ) =&gt; {\nif ( val == null ) {\nreturn false\n}\n\nif ( typeof val === 'string' &amp;&amp; val.trim().length === 0 ) {\nreturn false\n}\n\nreturn true\n}, { message : t( 'message', { name : attr.displayName || 'Field' } ) } )\n} )\n</code></pre>\nThe return value of this function can be any valid React element.</p>"},{"location":"docs/editors/#attributeobjectvalidator","title":"AttributeObjectValidator","text":"<p>In some cases, it is important to validate multiple fields in conjunction with each other. For this task, you will require an <code>AttributeObjectValidator</code>. These plugins will run whenever any field on a particular object is changed and will be passed the entire object's state, including updates. This allows validation of fields whose validity is dependent on the value of another field. For instance, if an \"Other\" option is chosen in an enum dropdown, an object validator can validate that an additional \"Explanation\" field is also filled out. If any other option is chosen from the dropdown, we can ignore validation of the \"Explanation\" field. Another example from the documentation of the @leverege/object-validator library is that of a password and confirmPassword field:\n<pre><code>const opts = {\nobjectValidators : z.custom( ( val ) =&gt; {\nif ( val?.confirmPassword &amp;&amp; val.password !== val.confirmPassword ) {\nreturn false\n}\nreturn true\n}, { message : 'Password and confirm password must match' } )\n}\n</code></pre>\nHere we validate that if the confirmPassword field has been filled out, it also must match what is filled in the password field.</p>"},{"location":"docs/editors/#forms","title":"Forms","text":"<p>In addition to substituting custom form fields for attributes, the entire create or edit form for an objectType can be replaced using the <code>AttributeValueEditorForm</code> plugin.\n<pre><code>molten.addPlugin( 'AttributeValueEditorForm', {\ntype : 'blueprint.location',\nform : LocationFormComponent\n} )\n</code></pre>\nThis would, for example, replace the create/edit form entirely for all \"location\" objects.</p>"},{"location":"docs/filtering/","title":"Filtering and Sorting","text":"<p>In Molten, we use the related concepts of filtering and sorting to expose data to users in an organized way.</p>"},{"location":"docs/filtering/filter/","title":"Filtering","text":"<p>At a high level, the concept of filtering in Molten can be seen as follows:</p> flowchart LR   A[Condition Filter Model] --&gt; B[Condition Filter Converter] --&gt; C[Data Source Specific Filtering Model]  <p>In its simplest form, the Condition Filter Model can be exactly the same as the Data Source Specific Filtering Model and the Condition Filter Converter can simply return the original model rather than doing any translation. However, separating the two models allows us to reuse the same Condition Filter Model and its editor in multiple places in Molten where similar logic is needed. For instance, the same Condition Model with a different Condition Filter Converter can be used to edit filters for querying sets of data, to edit where clauses for querying historical data or for conditional colorization of a table cell.</p> <p>Filtering in Molten is tied closely to the concept of Data Sources. For each data source that is introduced in molten, a corresponding set of delegates (for group data and item data) must also be configured to provide an interface for interacting with the data source (creating, reading, updating, deleting, etc.). Each delegate has a <code>type</code> property, and for each <code>type</code> of delegate, a Condition Filter Model and Condition Filter Model Editor must be registered in order to support filtering. A Condition Filter Converter must also be registered. Each time filters are applied by a user using the Condition Filter Model Editor, the registered Condition Filter Converter will be called and the resulting Data Source Specific Filtering Model will be passed in the options to the search method of the delegate as the <code>filter</code> property. The delegate can then use that object, specific to its querying capabilities, to query for data.</p> <p>For further information on filtering custom data, see the Custom Data section.</p>"},{"location":"docs/filtering/filter/attribute-conditions/","title":"Attribute Conditions","text":"<p>The Attribute Condition type leverages the concept of Attributes to create a generic model representing the comparison of an Attribute's value to some other static value. Attribute Conditions can be composed using the Logic Condition in order to group several sets of Attribute Conditions in AND and OR clauses.</p> <p>The basic anatomy of the Attribute Condition is as follows: <pre><code>{\ntype : TYPE,\nattrName : opts.attrName || null,\ncomparator : null\n}\n</code></pre> where attrName is the unique name of the attribute and comparator is a Comparator model. A Comparator is a brief encapsulation of logic, such as \"equals 5\" or \"greater than 10\" or \"contains 'happy'\". Put together, these concepts allow us to construct logic such as \"Height is greater than 62 inches\", \"Name contains Jen\" or \"Position is within 5 miles of -80 lat, 110 lon\".</p> <p>There are many comparator types included in the <code>@leverege/ui-attributes</code> library and installed by default in Molten. These comparators are installed using a NameValueView, meaning that in order to determine which comparators are available for a given attribute, first the editor will look to see if any comparators are registered against the specific and unique name of the Attribute being edited, then fall back to see if any comparators are registered that can handle that Attribute's valueType.</p> <p>Built in comparators are all registered using valueType, so by default any attribute which has been declared with a valueType of \"string\" will have access to all of the built in comparator types appropriate for strings (such as equals, starts with, ends with, contains, etc.). Allowing registration by name though allows the ability to override the valueType comparators for a given attribute. Perhaps in a particular case you have defined a custom Attribute on the UI side which is a roll-up of various other Attributes but has no direct equivalent data field on the server side. A great example of this are \"Alerts\" which are often based on complex logic such as \"has moved since last position report and is low on battery\". For such an Attribute, it would be possible to register a cusom comparator which could generate a complex filter for each alert state but present a simple UI which uses alert \"names\" to represent each complex filter.</p>"},{"location":"docs/filtering/filter/attribute-conditions/#generating-a-data-source-specific-filter-model","title":"Generating a Data Source Specific Filter Model","text":"<p>It was mentioned in the introduction to this section that the high level concept of filtering in Molten can be seen as follows:</p> flowchart LR   A[Condition Filter Model] --&gt; B[Condition Filter Converter] --&gt; C[Data Source Specific Filtering Model]  <p>Here we see no mention of comparators. How then do comparators work to generate a Data Source Specific Filtering Model? The answer is that the Condition Filter Converters for Imagine group data delegate the responsibility of generating a Data Source Specific Filtering Model to their children. In the case of the Logic ConditionFilterConverter, the work of generating filters for its child Attribute Conditions is delegated to the registered ConditionFilterConverters of those child Attribute Conditions. The Attribute ConditionFilterConverter in turn delegates its filter creation to its child comparator's ComparatorFilterConverter. This is all possible through the use of Molten's ConditionFilterConverterFactory and ComparatorFilterConverterFactory which are factories capable of creating all of all of the converters that have been registered. Let's take a look at a brief example:</p> <p><pre><code>import ConditionFilterModel from '../../../filters/filter/ConditionFilterModel'\nimport ConditionFilterConverterFactory from '../../../filters/filter/ConditionFilterConverterFactory'\nimport Util from '../../../filters/filter/Util'\n\nexport default {\ntype : 'groupDelegate.imagine.condition.Filter.ConditionFilterConverter',\nconvert : ( type, conditionModel, context ) =&gt; {\nconst { clientProps : { actions } } = context\nconst rootCondition = ConditionFilterModel.getRootCondition( conditionModel )\n\nreturn ConditionFilterConverterFactory.create(\nUtil.getFilterConverterTypeForType( actions.type, rootCondition.type ),\nrootCondition,\ncontext\n)\n}\n}\n</code></pre> Here the ConditionFilterConverter takes the rootCondition from the ConditionFilter and checks the ConditionFilterConverterFactory to see if it has a ConditionFilterConverter for the rootCondition (in this case, a LogicCondition). Don't worry about the call to <code>Util.getFilterConverterTypeForType</code>. It is simply a convenience function for appending the condition's type to the delegate's type for lookup in the factory.</p> <p>Next, the Logic Condition's ConditionFilterConverter constructs a small part of the resulting filter and delegates what it does not know about back to the factory:</p> <p><pre><code>import ConditionFilterConverterFactory from '../../../filters/filter/ConditionFilterConverterFactory'\nimport Util from '../../../filters/filter/Util'\n\nexport default {\ntype : 'groupDelegate.imagine.condition.Logical.ConditionFilterConverter',\nconvert : ( type, condition, context ) =&gt; {\nconst { clientProps : { actions } } = context\n\nconst conditions = condition.conditions\n.map( c =&gt; ConditionFilterConverterFactory.create(\nUtil.getFilterConverterTypeForType( actions.type, c.type ),\nc,\ncontext\n) )\n.filter( c =&gt; c != null )\n\nif ( conditions.length === 0 ) {\nreturn null\n}\n\nreturn {\ntype : 'logical',\nconditions,\noperator : condition.operator\n}\n}\n}\n</code></pre> The Attribute ConditionFilterConverter delegates the creation of its part of the final filter model to a ComparatorFilterConverter, passing itself so as to give the comparator converter the context it needs to build a filter for its parent AttributeCondition: <pre><code>import { Attributes } from '@leverege/ui-attributes'\nimport ComparatorFilterConverterFactory from '../../../filters/filter/comparator/ComparatorFilterConverterFactory'\nimport Util from '../../../filters/filter/comparator/Util'\n\nexport default {\ntype : 'groupDelegate.imagine.condition.Attribute.ConditionFilterConverter',\nconvert : ( type, condition, context ) =&gt; {\nconst { attrName } = condition\nconst { objectType, clientProps } = context\nconst { actions } = clientProps\n\nconst attribute = Attributes.getAttribute( attrName, objectType )\n\nif ( !condition?.comparator ) {\nreturn null\n}\n\nreturn ComparatorFilterConverterFactory.create(\nUtil.getComparatorConverterTypeForType( actions.type, condition.comparator.type ),\ncondition.comparator,\nattribute\n)\n}\n}\n</code></pre> And finally, a compartor converter handles the creation of a single part of the overall filter. For instance, the StringEqualsComparatorFilterConverter works like this: <pre><code>export default {\nid : 'molten.string.Equals.ComparatorFilterConverter',\ntype : 'groupDelegate.imagine.string.Equals.ComparatorFilterConverter',\nconvert : ( type, cmp, attribute ) =&gt; {\nif ( cmp?.value1 == null ) {\nreturn null\n}\n\nreturn {\ntype : 'equals',\nvalue : cmp.value1,\nfield : attribute.blueprint.field\n}\n}\n}\n</code></pre></p> <p>Now that we have a better understanding of how AttributeConditions work to create Data Source Specific Filtering Models, we'll take a look at how one would add a custom Comparator for a custom Attribute.</p>"},{"location":"docs/filtering/filter/custom-comparators/","title":"Custom Filters","text":"<p>Imagine a scenario where you've created a custom Attribute that is the concatenation of two other imagine device Attributes generated automatically by Molten. For instance, a Full Name field which concatenates First Name and Last Name attributes together: <pre><code>import { Attributes } from '@leverege/ui-attributes'\n\nconst options = {\nfilterable : true,\nsortable : true\n}\n\nexport default {\nid : 'person.fullName',\nname : 'person.fullName',\ndisplayName : 'Full Name',\nobjectType : 'person',\nvalueType : 'string',\nget : ( obj ) =&gt; {\nreturn `${Attributes.get( 'person.firstName', 'person', obj )} ${Attributes.get( 'person.lastName', 'person', obj )}`\n},\ngetOption : ( key ) =&gt; {\nreturn options[key]\n}\n}\n</code></pre> We will now be able to view our new custom attribute in tables and in detail cards throughout our UI. Our first name and last name attributes are already filterable because they were generated by Molten and our api has some knowledge of how to filter those fields. However, our new Full Name attribute only exists on the UI side and has no equivelant on the server side. This does not stop us from being able to filter it though.</p> <p>First, we will need to register a custom comparator against our new Attribute:</p> <p><pre><code>import {StringEqualsComparatorEditor} from '@leverege/ui-attributes';\n\nconst TYPE = 'person.fullName.equals'\n\nconst FullNameEqualsModel = {\ncreate() {\nreturn {\ntype : TYPE,\nvalue1 : null\n}\n},\nTYPE,\n...ModelUtil.createAllValue( 'value1' ),\nname : 'equals'\n}\n\nmolten.addPlugin( 'AttributeConditionComparator', {\ntype : FullNameEqualsModel.TYPE,\nmodel : FullNameEqualsModel,\nname : FullNameEqualsModel.name,\nattrName : 'person.fullName'\n} )\n\nmolten.addPlugin( 'AttributeConditionComparatorEditor', { type : FullNameEqualsModel.type, editor : StringEqualsComparatorEditor } )\n</code></pre> Registering this comparator using attrName will ensure that when editing AttributeConditions for this Attribute, only comparators registered against the attribute name (this comparator, for instance) and not the more generic built-in valueType comparators will be available for selection.</p> <p>Note</p> <p>Here we are using the StringEqualsComparatorEditor from the <code>@leverege/ui-attribute</code> library as an editor for our comparator's model since the two models are essentially identical and this saves us a bit of work.</p> <p>However, this comparator won't show up in our condition editor just yet, and that is because we need to regsiter a ComparatorSearchConverter to convert this comparator model into a Data Source Specific Filter Model.</p> <p><pre><code>import { Attributes } from '@leverege/ui-attributes'\n\nexport default {\nid : 'custom.person.fullName.Equals.ComparatorFilterConverter',\ntype : 'groupDelegate.imagine.person.fullName.equals.ComparatorFilterConverter',\nconvert : ( type, cmp, attribute ) =&gt; {\nif ( cmp?.value1 == null ) {\nreturn null\n}\n\nconst firstNameAttr = Attributes.getAttribute( 'person.firstName', 'person' )\nconst lastNameAttr = Attributes.getAttribute( 'person.lastName', 'person' )\n\nconst [ firstName, lastName ] = cmp.value1.split( ' ' )\n\nreturn {\ntype : 'logical',\noperator : 'and',\nconditions : [ {\ntype : 'equals',\nvalue : firstName,\nfield : firstNameAttr.blueprint.field\n}, {\ntype : 'equals',\nvalue : lastName,\nfield : lastNameAttr.blueprint.field\n} ]\n}\n}\n}\n</code></pre> This ConditionFilterConverter creates a complex filter which ensures that both the first name and last name components of our custom attribute match the first and last name fields on the Imagine device.</p>"},{"location":"docs/filtering/filter/custom-data/","title":"Custom Data","text":"<p>Implementing filtering using custom data can essentially take three forms, each more custom (and perhaps more difficult to implement as a result) than the last.</p> <p>For the purposes of this guide, we will assume that you have already created your own custom Data Source and corresponding delegate (or \"actions\"). Your delegate should have a static delegateType string property and each instance should have the same value as its delegateType property as well.</p>"},{"location":"docs/filtering/filter/custom-data/#the-happy-path","title":"The Happy Path","text":"<p>Perhaps the easiest way to implement filtering for a custom data source is to reuse the existing Condition Attribute, Attribute Condition, and Comparator Condition infrastructure provided by molten. To start, you will need to register the Condition Filter as the base condition for your delegate type like this: <pre><code>import { ConditionFilterModel } from '@leverege/molten/filters'\n\nmolten.addPlugin( 'ConditionFilterModel', {\ntype : PetsAction.TYPE,\nmodel : ConditionFilterModel\n} )\n</code></pre> where PetsAction is your group delegate class described above. this will provide the built-in Condition Filter editor for each of your custom data group screens exactly as Imagine based group screens have. It will also provide all of the built-in comparator types that Molten supports for each of your Attributes.</p> <p>Because the default ConditionFilterModel has an empty <code>rootCondition</code>, you will need to provide at least one Condition Filter Model Configurer. Here we will reuse the built in Imagine configurer:</p> <p><pre><code>import { LogicCondition } from '@leverege/condition'\nimport { ModelFactory } from '@leverege/ui-plugin'\n\nexport default {\nid : 'molten.filter.condition.configurer.pets',\nmatches : {\ndelegateType : 'groupDelegate.pets'\n},\nconfigure : ( model, ...rest ) =&gt; {\nconst Model = ModelFactory.get( model )\n\nreturn Model.setRootCondition( model, LogicCondition.create( { operator : 'and' } ) )\n}\n}\n</code></pre> Because the <code>match</code> on this configurer specifies only <code>delegateType</code>, it will match all group screens using your PetsAction delegate. You can register more specific configurerers using properties such as objectType and path to configure default models for particular screens. You can also supply a <code>sort</code> property to customize the order in which your configurers are called.</p> <p>Because your particular backing Data Store may not support filtering on all attributes, all comparator types, or using all operators supplied by the Logic Condition, you will also need to supply a Condition Filter Options Creator:</p> <p><pre><code>import { ConditionCreators } from '@leverege/ui-condition'\nimport { AttributeCondition } from '@leverege/ui-attributes'\n\nconst conditionOptions = {}\nconst conditions = [ AttributeCondition ]\n\nexport default {\nid : 'molten.filter.condition.optionsCreator.pets',\ntype : 'groupDelegate.pets',\ngetOptions : ( delegateType, props ) =&gt; {\n\nif ( !conditionOptions[delegateType] ) {\nconditionOptions[delegateType] = {\nlogicalOperators : [ 'and' ],\nattributeCondition : {\nattributeFilter : ( attr ) =&gt; {\nreturn attr.name === 'name'\n},\ncomparatorFilter : ( plg ) =&gt; {\nreturn plg.type === 'string.Contains'\n}\n}\n}\n}\n\nconst creators = ConditionCreators.toCreators( conditions )\n\nreturn {\ncreators,\nconditionOptions : conditionOptions[delegateType]\n}\n}\n}\n</code></pre> Here we use some very basic caching to ensure we don't create a new set of options every time our condition creator is called. The props object passed to the getOptions method will allow you to cache and customize these options based on things like objectType, path or relationship as well. We are only allowing filtering on one attribute here, only allowing a single root 'and' condition and only allowing comparison using the \"Contains\" comparator. You will best know the characteristics of your data to be able to customize these options.</p> <p>Finally, for each comparator type that we plan to support, we need to register a custom ComparatorFilterConverter:</p> <p><pre><code>/* PetsContainsComparatorFilterConverter.js */\nexport default {\nid : 'molten.string.Contains.ComparatorFilterConverter',\ntype : 'groupDelegate.pets.string.Contains.ComparatorFilterConverter',\nconvert : ( type, cmp, attribute ) =&gt; {\nreturn cmp\n}\n}\n\n/* PluginSetup.js */\nmolten.addPlugin( 'ComparatorFilterConverter', PetsContainsComparatorFilterConverter )\n</code></pre> We register the comparator using a type key of the pattern <code>${delegateType}.${comparatorType}.ComparatorFilterConverter</code>. For a complete set of comparator types, see the <code>@leverege/ui-attributes</code> library.</p> <p>This comparator converter simply returns the condition model, assuming that our PetsAction delegate will understand that format natively, but your can perform any type of conversion necessary here.</p>"},{"location":"docs/filtering/filter/custom-data/#semi-custom-filtering","title":"Semi-Custom Filtering","text":"<p>The second available method to implement filtering in Molten for custom data types is to register a Condition Filter Model Configurer which sets as its rootCondition an entirely custom Condition. In this case, you will also need to register your custom Condition as a Condition as well as with the Model factory and register a custom editor with the ModelEditor factory:</p> <p><pre><code>Plugins.add( 'Condition', PetsCondition )\nPlugins.add( 'Model', { type : PetsCondition.TYPE, model : PetsCondition } )\nPlugins.add( 'ModelEditor', { type : PetsCondition.TYPE, editor : PetsConditionEditor } )\n</code></pre> You would register the ConditionFilterModel as the Condition Filter Model for your delegate type as above: <pre><code>molten.addPlugin( 'ConditionFilterModel', {\ntype : PetsAction.TYPE,\nmodel : ConditionFilterModel\n} )\n</code></pre> And a Condition Model Configurer similar to the one above but set an instance of this PetsCondition as your rootCondition.</p> <p>You can then register a Condition Filter Converter for this condition which will be called each time the condition model is changed by the user using your editor:</p> <pre><code>molten.addPlugin( 'ConditionFilterConverter', PetsConditionFilterConverter )\n</code></pre> <p>With this method, you can still register an options creator and the creators and conditionOptions you create will be provided to your editor and its children through a SharedContext object. You will be </p>"},{"location":"docs/filtering/filter/custom-data/#total-custom-filtering","title":"Total Custom Filtering","text":"<p>The final method of implementing filtering in Molten is to register a completely custom model as the Condition Filter Model for your delegate type: <pre><code>molten.addPlugin( 'ConditionFilterModel', {\ntype : PetsAction.TYPE,\nmodel : PetsFilterModel\n} )\n</code></pre> Going this route allows you to create your own editor for filters. You will not be passed Condition Filter Options in a SharedContext automatically and all filtering methodology will be up to you.</p>"},{"location":"docs/filtering/filter/custom-suggestors/","title":"Custom Suggestors","text":"<p>Key to the Attribute Condition editor is the ability to provide value suggestions for the Attribute as a user types.</p> <p>Molten provides several built-in Suggestors for Imagine based Attributes that provide values for a given Attribute valueType. For instance, the StringAttributeValueSuggestor provides auto-suggest results based on the existing values for the Attribute among existing devices filtered by the user's text input. The UnitAttributeValueSuggestor provides suggestions for all of the available unit types for a particular unit (e.g. temperature Attributes are given suggestions for C, F, K, and R unit types).</p> <p>When registering a custom Attribute, it is necessary to also register a custom Suggestor to provide possible values for the user to select from. A Suggestor is simple an instance of a class that provides a <code>suggest</code> method which takes a single argument, the value that the user has entered. Take for example the Full Name Attribute example from the previous section. An implementation of a suggestor for that Attribute might look like this:</p> <p><pre><code>import { Attributes } from '@leverege/ui-attributes'\nimport { GlobalState } from '@leverege/ui-redux'\n\nexport default class MakeModelYearValueSuggestor {\nconstructor( type, opts = {} ) {\nthis.attribute = opts.attribute\nthis.actions = opts.actions\nthis.relationship = opts.relationship\nthis.objectType = opts.objectType\nthis.firtNameAttribute = Attributes.getAttribute( 'person.firstName', 'person' )\nthis.lastNameAttribute = Attributes.getAttribute( 'person.lastName', 'person' )\n}\n\nasync suggest( value ) {\nconst [ firstName, lastName ] = ( value || '' ).split( ' ' )\n\nconst filters = []\n\nif ( firstName ) {\nfilters.push( {\ntype : 'expression',\nvalue : `*${firstName}*`,\nfield : this.firstNameAttribute.blueprint.field,\nkind : 'queryString',\nanalyzeWildcard : true\n} )\n}\n\nif ( lastName ) {\nfilters.push( {\ntype : 'expression',\nvalue : `*${lastName}*`,\nfield : this.lastNameAttribute.blueprint.field,\nkind : 'queryString',\nanalyzeWildcard : true\n} )\n}\n\nconst results = await GlobalState.dispatch(\nthis.actions.search( {\nfilter : {\ntype : 'logical',\noperator : 'or',\nconditions : filters\n},\nqueryName : 'search.FullNameValueSuggestor'\n} )\n)\n\nconst suggestions = results.items.map( ( item ) =&gt; {\nreturn `${this.firstNameAttribute.get( item )} ${this.lastNameAttribute.get( item )}`\n} )\n\nif ( suggestions &amp;&amp; suggestions.length &gt; 0 ) {\nreturn suggestions\n}\n\nreturn []\n}\n}\n</code></pre> As you can see, the options that are passed to a suggestor upon construction include the attribute being searched, the delegate (or actions) for the group, the relationship and the objectType. This allows us to search the delegate for entries where first name and last name match our user's input and return suggestions. Suggestions can be an array of strings or an array of objects with name and value keys in the event that you want to use a different display value to represent a backing value. If no results are available, simply return null or an empty array.</p>"},{"location":"docs/filtering/filter/imagine/","title":"Imagine Filtering","text":"<p>By default, filtering for Imagine group data parts of the <code>@leverege/condition</code> and <code>@leverege/ui-attributes</code> libraries to create a Condition Filter Model to query for its data. The base Condition Filter Model for Imagine data is called ConditionFilterModel and is registered for Imagine group data as follows:</p> <pre><code>...\nimport GroupActions from '../../dataSource/GroupActions'\n\nexport default {\ninstall( molten ) {\n...\nmolten.addPlugin( 'ConditionFilterModel', { type : GroupActions.TYPE, model : ConditionFilterModel } )\n...\n}\n}\n</code></pre> <p>The ConditionFilterModel itself is quite simple and consists only of a type and a rootCondition property: <pre><code>const TYPE = 'condition.Filter'\n\nfunction create( extra ) {\nreturn {\nrootCondition : null,\n...extra,\ntype : TYPE,\n}\n}\n</code></pre></p>"},{"location":"docs/filtering/filter/imagine/#default-model-configuration","title":"Default Model Configuration","text":"<p>This model is purposely generic in order to allow reuse by other, non-Imagine data types. To configure the default condition model for Imagine data further, a Condition Filter Model Configurer is registered. It is passed an instance of a Condition Filter Model and is expected to return another Condition Filter Model. Condition Filter Model Configurers can be registered against specific paths and object types in order to make customization on a per device type basis simple. Configurers can be registered with a sort priority to ensure the order in which they are called to configure the defauly model. The default imagine Condition Filter Model Configurer simply adds a LogicCondition as the rootCondition property: <pre><code>import { LogicCondition } from '@leverege/condition'\nimport { ModelFactory } from '@leverege/ui-plugin'\n\nexport default {\nid : 'molten.filter.condition.configurer.imagine',\nmatches : {\ndelegateType : 'groupDelegate.imagine'\n},\nconfigure : ( model, ...rest ) =&gt; {\nconst Model = ModelFactory.get( model )\n\nreturn Model.setRootCondition( model, LogicCondition.create( { operator : 'and' } ) )\n}\n}\n</code></pre></p>"},{"location":"docs/filtering/filter/imagine/#condition-options-configuration","title":"Condition Options Configuration","text":"<p>Because various Data Sources may support varying complexities and varieties of query, the behavior of Conditions and their editors is highly configurable. For instance, by default the LogicCondition editor supports the AND, OR, XOR, NOR, XNOR and NAND operators, but Imagine's data source only supports AND and OR queries. As a result, further configuration is required. To accomplish this, we register a Condition Filter Options Creator using our delegate's type as a key like this:</p> <p><pre><code>/* PluginSetup.js */\nmolten.addPlugin( 'ConditionFilterOptionsCreator', ImagineConditionFilterOptionsCreator )\n\n/* ImagineConditionFilterOptionsCreator.js */\n\nimport { ConditionCreators } from '@leverege/ui-condition'\nimport { LogicCondition } from '@leverege/condition'\nimport { AttributeCondition } from '@leverege/ui-attributes'\n\nimport ComparatorFilterConverterFactory from '../../../filters/filter/comparator/ComparatorFilterConverterFactory'\nimport ComparatorUtil from '../../../filters/filter/comparator/Util'\n\nconst conditionOptions = {}\nconst conditions = [ LogicCondition, AttributeCondition ]\n\nexport default {\nid : 'molten.filter.condition.optionsCreator.imagine',\ntype : 'groupDelegate.imagine',\ngetOptions : ( delegateType, props ) =&gt; {\n\nif ( !conditionOptions[delegateType] ) {\nconditionOptions[delegateType] = {\nlogicalOperators : [ 'and', 'or' ],\nattributeCondition : {\nattributeFilter : ( attr ) =&gt; {\n// TODO: MOLTEN-594 Rename 'blueprint' attribute on the imagine attributes to source, and given them a type\nreturn attr?.getOption?.( 'filterable' ) === true\n},\ncomparatorFilter : ( plg ) =&gt; {\nconst converter = ComparatorFilterConverterFactory.get(\nComparatorUtil.getComparatorConverterTypeForType( delegateType, plg.type )\n)\n\nreturn converter != null\n}\n}\n}\n}\n\nconst creators = ConditionCreators.toCreators( conditions )\n\nreturn {\ncreators,\nconditionOptions : conditionOptions[delegateType]\n}\n}\n}\n</code></pre> Registering this options creator will ensure that these options are passed to condition editors for our delegate type in a SharedContext.</p> <p>At first this may seem a bit complicated, but the important parts to note are the <code>logicalOperators</code> property, which signals to the LogicCondition editor that it should only allow selection of those two types of operators and the <code>attributeFilter</code> property, which tells the AttributeCondition editor to filter the available UI Attributes so that attributes which do not support filtering (perhaps attributes that are client side only with no server backing) are not presented to be selected by the user.</p> <p>Also important are the <code>creators</code> that are returned. These creators are presented by the condition editor for addition by the user. By default, Imagine supports only the LogicCondition and AttributeCondition types, but custom Conditions can be added if needed.</p> <p>You may also notice the <code>comparatorFilter</code> property which is particular to the AttributeCondition type and is further explained in the Attribute Conditions section of this documentation.</p>"},{"location":"docs/filtering/sort/","title":"Sorting","text":"<p>Sorting in Molten follows a very similar model to filtering and can be seen as follows:</p> flowchart LR   A[Sorting Model] --&gt; B[Sort Converter] --&gt; C[Data Source Specific Sorting Model]  <p>The sorting model is simply an ordered list of data fields, specified by attribute name, a sort direction (either ascending or descending) and a missing flag (either first or last) to indicate if missing values should be sorted to the top or bottom of a data list.</p> <p>To leverage Molten's built in sorting capabilities for a custom data type, simply register the default SortModel provided by molten as the model for your delegate type:</p> <p><pre><code>molten.addPlugin( 'SortModel', { type : PetsAction.TYPE, model : AttributeSortModel } )\n</code></pre> Where PetsAction is your group data delegate class and TYPE is its unique type key.</p> <p>This will provide the default Molten sort editor as your sorting UI.</p> <p>In addition, you'll need to register an AttributeSortConverter plugin which will take an instance of the SortModel and translate it into an object or other representation that makes sense to your group data delegate and backend data store:</p> <pre><code>/* PluginSetup.js */\nmolten.addPlugin( 'AttributeSortConverter', PetsAttributeSortConverter )\n/* PetsAttributeSortConverter.js */\nimport { Attributes } from '@leverege/ui-attributes'\n\nimport AttributeSortModel from '../../../filters/sort/AttributeSortModel'\n\nexport default {\ntype : 'groupDelegate.pets.AttributeSortConverter',\nconvert : ( type, sortModel, context ) =&gt; {\nconst { objectType } = context\nconst fields = AttributeSortModel.getFields( sortModel )\n\nconst sort = fields.map( ( field ) =&gt; {\nconst attribute = Attributes.getAttribute( field.attrName, objectType )\n\nif ( !attribute ) {\nreturn null\n}\n\nreturn {\nfield : attribute.blueprint?.field,\nmissing : field.order === 'asc' ? '_first' : '_last',\norder : field.order\n}\n} )\n.filter( field =&gt; field != null )\n\nif ( sort.length &gt; 0 ) {\nreturn sort\n}\n\nreturn null\n}\n}\n</code></pre>"},{"location":"docs/filtering/sort/#customized-sorting","title":"Customized Sorting","text":"<p>If you require further customization of your SortModel, you can simply register a different model for your delegate with the SortModel plugin point and provide an editor to the ModelEditor plugin point.</p>"},{"location":"docs/graphs/","title":"Graphs and Charts","text":"<p>Graphs are a type of plugin that allow a user to visualize various attributes (both attributes of devices and attributes derived from devices, like aggregations). Graphs are broken into types (the first and presently the only of which is XYChart) and within each type, there are various plugin points that a allow a developer to customize the look and feel of their graph or chart.</p>"},{"location":"docs/graphs/getting-started/","title":"Getting Started","text":"<p>First, install the ui-attributes-graphs library: <pre><code>npm i @leverege/ui-attributes-graphs\n</code></pre></p> <p>Next, define UI Attributes for the data that you are hoping to graph. For instance, the below example defines three attributes for a fictitious 'test.history' data type. If you are using Molten, you may already have a number of UI Attributes defined for you based on your Imagine project's blueprints: <pre><code>Plugins.add( 'Attribute', {\nname : 'name',\ndisplayName : 'Name',\nvalueType : 'string',\nobjectType : 'test.history',\nplacement : {\ngroup : [ ]\n},\nget : ( obj ) =&gt; {\nreturn obj?.name\n}\n} )\nPlugins.add( 'Attribute', {\nname : 'test.history.time',\ndisplayName : 'Time',\nvalueType : 'timestamp',\nobjectType : 'test.history',\nplacement : {\ngroup : [ ]\n},\nget : ( obj ) =&gt; {\nconst time = obj &amp;&amp; obj.time\n\nreturn time == null ? null : new Date( time )\n}\n} )\n\nPlugins.add( 'Attribute', {\nname : 'test.history.temperature',\ndisplayName : 'Temperature',\nvalueType : 'temperature',\nobjectType : 'test.history',\nbaseUnit : 'degC',\nplacement : {\ngroup : [ ]\n},\nget : ( obj ) =&gt; {\nconst temp = obj?.data?.temperature\n\nreturn temp == null ? null : {\ntype : 'temperature',\nvalue : temp,\nunit : 'degC'\n}\n}\n} )\n</code></pre></p> <p>In this case, time and temperature will be the two data points that we will be graphing against one another. Name is (in this case) a unique identifier for the objects that these data represent and will be used to key the data into series to facilitate graphing.</p> <p>Using the <code>useSeriesData</code> hook or the <code>withSeriesData</code> HOC exported by this library, prepare your data for graphing. The hook/HOC expect to be passed an array of data that you want to be graphed, an attribute name that will be used to chunk that data, and an options object with possible properties of obejctType and sortAttribute. The hook/HOC will transform and memoize this data into an object keyed on the values of the chunk attribute that you have passed. If you pass an objectType in the options, it will be used to help disambiguate the chunk and sort attributes rather than using the first attribute registered with that particular name. If you pass a sortAttribute in the options, it will be used to sort the data in your series.</p>"},{"location":"docs/graphs/getting-started/#example","title":"Example","text":"<p><pre><code>const dataArray = [\n  {\n    \"type\": \"test.history\",\n    \"id\": \"1\",\n    \"data\": {\n      \"time\": 1642444110759,\n      \"name\": \"Device 1\",\n      \"data\": {\n        \"temperature\": 45.7891\n      }\n    }\n  },\n  {\n    \"type\": \"test.history\",\n    \"id\": \"2\",\n    \"data\": {\n      \"time\": 1642461033498,\n      \"name\": \"Device 1\",\n      \"data\": {\n        \"temperature\": 40.7705\n      }\n    }\n  },\n  {\n    \"type\": \"test.history\",\n    \"id\": \"3\",\n    \"data\": {\n      \"time\": 1642411955689,\n      \"name\": \"Device 1\",\n      \"data\": {\n        \"temperature\": 48.7092\n      }\n    }\n  },\n  {\n    \"type\": \"test.history\",\n    \"id\": \"7\",\n    \"data\": {\n      \"time\": 1642474048199,\n      \"name\": \"Device 2\",\n      \"data\": {\n        \"temperature\": 12.299\n      }\n    }\n  },\n  {\n    \"type\": \"test.history\",\n    \"id\": \"8\",\n    \"data\": {\n      \"time\": 1642407220379,\n      \"name\": \"Device 2\",\n      \"data\": {\n        \"temperature\": 5.4862\n      }\n    }\n  },\n  {\n    \"type\": \"test.history\",\n    \"id\": \"9\",\n    \"data\": {\n      \"time\": 1642478679300,\n      \"name\": \"Device 2\",\n      \"data\": {\n        \"temperature\": 4.5652\n      }\n    }\n  }\n]\n\nconst seriesData = useSeriesData( dataArray, 'name', { sortAttribute : 'test.time' } )\n\n/*\n  seriesData =&gt; {\n  \"Device 2\": [\n    {\n      \"type\": \"test.history\",\n      \"id\": \"8\",\n      \"data\": {\n        \"time\": 1642407220379,\n        \"name\": \"Device 2\",\n        \"data\": {\n          \"temperature\": 5.4862\n        }\n      }\n    },\n    {\n      \"type\": \"test.history\",\n      \"id\": \"7\",\n      \"data\": {\n        \"time\": 1642474048199,\n        \"name\": \"Device 2\",\n        \"data\": {\n          \"temperature\": 12.299\n        }\n      }\n    },\n    {\n      \"type\": \"test.history\",\n      \"id\": \"9\",\n      \"data\": {\n        \"time\": 1642478679300,\n        \"name\": \"Device 2\",\n        \"data\": {\n          \"temperature\": 4.5652\n        }\n      }\n    }\n  ],\n  \"Device 1\": [\n    {\n      \"type\": \"test.history\",\n      \"id\": \"3\",\n      \"data\": {\n        \"time\": 1642411955689,\n        \"name\": \"Device 1\",\n        \"data\": {\n          \"temperature\": 48.7092\n        }\n      }\n    },\n    {\n      \"type\": \"test.history\",\n      \"id\": \"1\",\n      \"data\": {\n        \"time\": 1642444110759,\n        \"name\": \"Device 1\",\n        \"data\": {\n          \"temperature\": 45.7891\n        }\n      }\n    },\n    {\n      \"type\": \"test.history\",\n      \"id\": \"2\",\n      \"data\": {\n        \"time\": 1642461033498,\n        \"name\": \"Device 1\",\n        \"data\": {\n          \"temperature\": 40.7705\n        }\n      }\n    }\n  ]\n}\n */\n</code></pre> This hook/HOC will format your data into series in a manner that can be used by the ui-attributes-graphs library and will memoize the data to prevent unnecessary re-renders. If you can't use the hook/HOC because of the complexity of your data or formatting needs, a normal object keyed on some unique property will work fine, just remember to memoize the data yourself. Now simply pass this data, a Model for your chart and the objectType for your data (in the above example, this would be 'test.history') to a chart renderer and watch as your data is graphed in stunning color. <pre><code>import { XYChartModel, XYChartRenderer, useSeriesData } from '@leverege/ui-attributes-graphs'\n\nconst [ model, setModel ] = useState( XYChartModel.create() )\nconst seriesData = useSeriesData( myUnformattedData, 'name', { sortAttribute : 'test.time' } )\n\nreturn (\n&lt;XYChartRenderer\ndata={seriesData}\nobjectType=\"test.history\"\nmodel={model} /&gt;\n)\n</code></pre></p>"},{"location":"docs/graphs/themeing/","title":"Themeing","text":"<p>Themeing for UI Attributes Graphs XYChart is done through UI Builder.</p> <p>Here is a list of customizable values and their corresponding color variables in UI Builder:</p> To Customize... Set this color variable in UI Builder... Series Line/Bar Color graphSeries1 - graphSeries7 Background graphBackground X-Axis Label graphXAxisLabel Y-Axis Label graphYAxisLabel X-Tick Label graphXTickLabel Y-Tick Label graphYTickLabel Threshold Line graphThreshold <p>These values can also be overridden using custom renderer plugins, such as a Custom Graph Background Renderer or Custom Series Renderer</p>"},{"location":"docs/graphs/plugin-points/colorizers/","title":"Colorizers","text":"<p>While Colorizers are not unique to the UI Attributes Graphs library, they can be used to control the color of both series point glpyhs in the Glyph Line series type and the glyph used by the rollover tooltip. Installing a Colorizer for a particular object type will cause a function that you define to be called when a color needs to be determined for a particular data point. This allows for conditional coloring based on object values. Take a look at this simple example for an Alert Colorizer, which changes the color of a line or rollover glpyh when a particular temperature value is surpassed:</p>"},{"location":"docs/graphs/plugin-points/colorizers/#example","title":"Example","text":"ColorizerEditorSetup <p>File TemperatureAlertColorizer.js. <pre><code>import ModelUtil from '@leverege/model-util'\nimport { Attributes } from '@leverege/ui-attributes'\n\nconst TYPE = 'colorizer.test.history.Alert'\n\nexport default {\ncreate() {\nreturn {\ntype : TYPE,\nvalue : 30,\ncolor : '#ff0000'\n}\n},\ncolorFor( model, obj, context ) {\nconst temp = Attributes.get( 'test.history.temperature', obj.type, obj.data )\n\nif ( temp.value &gt; model.value ) {\nreturn model.color\n}\n\nreturn context.seriesColor\n},\n...ModelUtil.createAllValue( 'value' ),\n...ModelUtil.createAllValue( 'color' ),\nTYPE\n}\n</code></pre></p> <p>File TemperatureAlertColorizerEditor.jsx. <pre><code>import { NumericInput, TextInput PropertyGrid } from '@leverege/ui-elements'\nimport { useValueChange } from '@leverege/ui-hooks'\n\nimport TemperatureAlertColorizer from './TemperatureAlertColorizer'\n\nexport default function TemperatureAlertColorizerEditor( props ) {\nconst { value } = props\n\nconst onModelChange = useValueChange( TemperatureAlertColorizer, props )\n\nreturn (\n&lt;PropertyGrid&gt;\n&lt;PropertyGrid.Item label=\"Alert Value\"&gt;\n&lt;NumericInput\nvalue={TemperatureAlertColorizer.getValue( value )}\nhint=\"Alert value\"\nfloat\neventData=\"setValue\"\nonChange={onModelChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;PropertyGrid.Item label=\"Color\"&gt;\n&lt;TextInput\nvalue={TemperatureAlertColorizer.getColor( value )}\nhint=\"Color\"\neventData=\"setColor\"\nonChange={onModelChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;/PropertyGrid&gt;\n)\n}\n</code></pre></p> <p>File PluginSetup.js. <pre><code>import TemperatureAlertColorizer from './TemperatureAlertColorizer'\nimport TemperatureAlertColorizerEditor from './TemperatureAlertColorizerEditor'\n\nexport default {\ninstall( molten ) {\nmolten.addPlugin( 'Model', { type : TemperatureAlertColorizer.TYPE, model : TemperatureAlertColorizer } )\nmolten.addPlugin( 'ModelEditor', { type : TemperatureAlertColorizer.TYPE, editor : TemperatureAlertColorizerEditor } )\nmolten.addPlugin( 'Colorizer', { type : TemperatureAlertColorizer.TYPE, name : 'Alert Colorizer', colorizer : TemperatureAlertColorizer } )\n}\n}\n</code></pre></p> <p>You are encouraged to use Colorizers in your own plugins when applicable to increase potential customization by users.</p> <p>Tip</p> <p>The wonderful thing about this Colorizer is that it can be resued anywhere that a color is needed to determine an appropriate color for the object type 'test.history'. In other words, it has no special attachment to the concept of a graph and could just as easily be used to color a table cell or a dot on a map representing the same type of object. With a bit of refactoring, this Colorizer could even be made to allow the Attribute that it is checking to be set dynamically as well.</p>"},{"location":"docs/graphs/plugin-points/graph-background/","title":"Graph Background","text":"<p>The UI Attributes Graphs Library comes with several customizable background types that may suit your needs.</p>"},{"location":"docs/graphs/plugin-points/graph-background/#solid","title":"Solid","text":"<p>The default background for new graphs, the solid background is simply a single color covering the entire background of the graph which can be customized by the user.</p>"},{"location":"docs/graphs/plugin-points/graph-background/#striped","title":"Striped","text":"<p>A striped background gives the user options to set the background color of the graph, in addition to selecting from several defined patterns of stripes to display in the inner area of the graph (inside its margin). Options include Diagonal, Diagonal (Reverse), Diagonal (Both), Horizontal, Vertical as well as Horizontal and Vertical. The color of the stripe can also be chosen.</p>"},{"location":"docs/graphs/plugin-points/graph-background/#image","title":"Image","text":"<p>An image background allows the user to supply an image url and various options such as size and position to place an image in the background of a graph. This is handy to add something like a company watermark to all graphs in a particular UI.</p>"},{"location":"docs/graphs/plugin-points/graph-background/#custom-backgrounds","title":"Custom Backgrounds","text":"<p>In order to add a custom graph background,  you will need to register a Model, a Renderer and optionally (if your background is user customizable) a Model Editor.</p>"},{"location":"docs/graphs/plugin-points/graph-background/#example","title":"Example","text":"<p>To create a Graph Background that displays one color on even days of the week and another on odd days, you would do the following:</p> ModelEditorRendererSetup <p>File SillyGraphBackgroundModel.js. <pre><code>const TYPE = 'myCustomNamespace.graph.SillyGraphBackground'\nfunction create() {\nreturn {\ntype : TYPE,\nevenDayColor : 'purple',\noddDayColor : 'black'\n}\n}\n\nexport default {\nTYPE,\ncreate,\n...ModelUtil.createAllValue( 'evenDayColor' ),\n...ModelUtil.createAllValue( 'oddDayColor' )\n}\n</code></pre></p> <p>File SillyGraphBackgroundEditor.jsx. <pre><code>...\nimport SillyGraphBackgroundModel from './SillyGraphBackgroundModel'\n\nexport default function SillyGraphBackgroundEditor( props ) {\nconst { value } = props\nconst onModelChange = useValueChange( SillyGraphBackgroundModel, props )\n\nreturn (\n&lt;Pane style={{ '--propertyGrid-numColumns' : 1 }}&gt;\n&lt;PropertyGrid variant=\"backgroundEditor|editor\"&gt;\n&lt;PropertyGrid.Item label=\"Even Day Color\"&gt;\n&lt;TextInput\nvalue={SillyGraphBackgroundModel.getEvenDayColor( value )}\neventData=\"setEvenDayColor\"\nonChange={onModelChange}\nhint=\"Even Day Color\" /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;PropertyGrid.Item label=\"Odd Day Color\"&gt;\n&lt;TextInput\nvalue={SillyGraphBackgroundModel.getOddDayColor( value )}\neventData=\"setOddDayColor\"\nonChange={onModelChange}\nhint=\"Odd Day Color\" /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;/PropertyGrid&gt;\n&lt;/Pane&gt;\n)\n}\n</code></pre></p> <p>File SillyGraphBackgroundRenderer.jsx. <pre><code>import { DataContext } from '@visx/xychart'\n\nimport SillyGraphBackgroundModel from './SillyGraphBackgroundModel'\n\nexport default function SillyGraphBackgroundRenderer( props ) {\nconst { model } = props\nconst { theme, margin, width, height } = useContext( DataContext )\n\nconst { backgroundColor } = useMemo( () =&gt; {\nconst day = new Date().getDay()\nconst isEven = day % 2 === 0\n\nconst backgroundColor = isEven ? SillyGraphBackgroundModel.getEvenColor( model ) : SillyGraphBackgroundModel.getOddColor( model )\n\nreturn {\nbackgroundColor : backgroundColor || theme?.backgroundColor || '#fff'\n}\n}, [ theme?.backgroundColor, model ] )\n\nif( width == null || height == null || margin == null || theme == null ) {\nreturn null\n}\n\nreturn (\n&lt;rect\nx={0}\ny={0}\nwidth={width}\nheight={height}\nfill={backgroundColor} /&gt;\n)\n}\n</code></pre></p> <p>File PluginSetup.js. <pre><code>export default {\ninstall( molten ) {\nmolten.addPlugin( 'GraphBackgroundModel', { type : SillyGraphBackgroundModel.TYPE, name : 'Silly Graph Background', model : SillyGraphBackgroundModel } )\nmolten.addPlugin( 'GraphBackgroundModelEditor', { type : SillyGraphBackgroundModel.TYPE, editor : SillyGraphBackgroundEditor } )\nmolten.addPlugin( 'GraphBackgroundRenderer', { type : SillyGraphBackgroundModel.TYPE, renderer : SillyGraphBackgroundRenderer } )\n}\n}\n</code></pre></p> <p>As you may have noticed, graph background are renderer as children of a visx XYChart component, and as such, they have access to the chart's context. This context contains helpful data, such as chart dimensions and all of the chart's data. See the documentation for @visx/xychart for more information.</p> <p>Tip</p> <p>Registering your model and editor using the 'GraphBackgroundModel' and 'GraphBackgroundModelEditor' will automatically register those plugins with the 'Model' and 'ModelEditor' plugin points, which is an important step that allows various generic model selectors and factories to know about your model and editor.</p>"},{"location":"docs/graphs/plugin-points/model-configurer/","title":"XYChartModelConfigurer","text":"<p>The XYChartModelConfigurer Plugin Point allows you to register a function which will generate the default XYChart model for a given matchContext. For instance, if you have an object type of \"vehicle\" in your application, you can register an XYChartModelConfigurer like this and it will be invoked for generating the default model for all XYCharts whose Match context includes <code>objectType : 'vehicle'</code>:</p> ConfigurerSetup <p>File FixedWidthXYChartModelConfigurer.js <pre><code>import { XYChartModel } from '@leverege/ui-attributes-graphs'\n\nexport default {\nid : 'fixedWidth.vehicle.XYChartModelConfigurer'\nsort : 'aaa',\nconfigure : ( xyChartModel, objectType, cxt ) =&gt; {\nlet model = XYChartModel.setWidth( xyChartModel, 500 )\nmodel = XYChartModel.setHeight( model, 500 )\n\nreturn model\n}\n}\n</code></pre></p> <p>File PluginSetup.js <pre><code>import FixedWidthXYChartModelConfigurer from './FixedWidthXYChartModelConfigurer'\n\nexport default {\ninstall( molten ) {\nmolten.addPlugin( 'XYChartModelConfigurer', FixedWidthXYChartModelConfigurer )\n}\n}\n</code></pre></p> <p>Each XYChartModelConfigurer plugin is passed the model instance from the configurer before it and is expected to return a model instance in turn. The first configurer will recieve a freshly initialized default model (the result of XYChartModel.create()). The order that each configurer is called in depends on the \"sort\" property of the plugin itself.</p> <p>Tip</p> <p>Molten comes with default XYChart model configurers for Imagine objects and aggregations.</p>"},{"location":"docs/graphs/plugin-points/scale/","title":"Scale","text":"<p>Graphs can be drawn using various scales to achieve different results, or to compliment different data sets. The most common scales are provided as built-in model and editor pairs, but adding a new scale type to be available for selection is also a fairly straighforward task.</p> <p>All scales are based on scale types available in the @visx/scale library, which are in turn based on scale types from the popular d3-scale library.</p> <p>The official d3-scales documetation can be consulted for information on any of the built-in types or as a reference when attempting to implement a custom type.</p> <ul> <li>Time Scale</li> <li>UTC Scale</li> <li>Band Scale</li> <li>Linear Scale</li> </ul> <p>To implement a new scale, add both a ScaleModel and ScaleModelEditor plugin to allow a user to customize any scale options:</p> ModelSetup <p>File LogScaleModel.js. <pre><code>const TYPE = 'graph.scale.log'\n\nfunction create() {\nreturn {\ntype : TYPE,\nvisxScaleType : 'log',\n...otherOptions\n}\n}\n\nexport default {\ncreate,\nTYPE\n}\n</code></pre></p> <p>Scale Types</p> <p>Each scale model must have a property called visxScaleType which indicates the type of scale from among the available scale types found here in the @visx/scale library.</p> <p>File PluginSetup.js <pre><code>molten.addPlugin( 'ScaleModel', { type : LogScaleModel.TYPE, name : 'Logarithmic', model : LogScaleModel } )\nmolten.addPlugin( 'ScaleModelEditor', { type : LogScaleModel.TYPE, editor : LogScaleModelEditor } )\n</code></pre></p> <p>Tip</p> <p>Adding your ScaleModel and ScaleModelEditor plugins will automatically register those plugins with the Model and ModelEditor plugin points.</p> <p>Scale Editor</p> <p>Note: Not shown above is the logarithm scale editor. You can provide an editor to allow users to set any of the available options on the particular d3-scale type you are implementing.</p>"},{"location":"docs/graphs/plugin-points/series-renderers/","title":"Series Renderers","text":"<p>A series renderer is a component that displays XY series data visually. the UI Attributes Graphs library has several built-in renderers and allows you to register your own renderer if you so desire. Most of the built-in renderers are simply wrappers around the base series renderer types supported by the @visx/xychart library, but a renderer is simple a component which is given access to the DataContext of the graph (including the graph's dimensions, it's X and Y scales, and its data) and can return any valid SVG for display.</p>"},{"location":"docs/graphs/plugin-points/series-renderers/#built-in-types","title":"Built-In Types","text":""},{"location":"docs/graphs/plugin-points/series-renderers/#line","title":"Line","text":"<p>A line series renderer renders series data using a line. The only option for the line series is stroke opacity.</p>"},{"location":"docs/graphs/plugin-points/series-renderers/#area","title":"Area","text":"<p>Similar to a line series, except that the area beneath the line is shaded the same color as the line's stroke.</p>"},{"location":"docs/graphs/plugin-points/series-renderers/#bar","title":"Bar","text":"<p>Graphs data as a series of bars.</p>"},{"location":"docs/graphs/plugin-points/series-renderers/#area-stack","title":"Area Stack","text":"<p>Similar to an Area graph, but data points from different series with the same x coordinate are stacked on top of each other for a cumulative effect. This graph type is only useful when all of your series data shares the same X coordinates.</p>"},{"location":"docs/graphs/plugin-points/series-renderers/#bar-stack","title":"Bar Stack","text":"<p>A bar graph where datum with the same X coordinate are stacked cumulatively on top of each other, just as in an AreaStack renderer.</p>"},{"location":"docs/graphs/plugin-points/series-renderers/#bar-group","title":"Bar Group","text":"<p>Also only useful for data sets that share the same set of X coordinates, the Bar Group displays series of data side-by-side grouped by their X coodrinate, rather than overlapping each other or stacking as in Bar and Bar Stack.</p>"},{"location":"docs/graphs/plugin-points/series-renderers/#glyph-line","title":"Glyph Line","text":"<p>Like a line graph, but with user-customizable glyphs at each data point.</p>"},{"location":"docs/graphs/plugin-points/series-renderers/#custom-series","title":"Custom Series","text":"<p>It is possible to create your own custom Series Renderer by registering SeriesModel, SeriesModelEditor and SeriesRender plugins for your series type. Again, a Series Renderer need only return valid svg, so any manner of visualization is possible. As an example, let's look at the Glyph Line Renderer, which is a conglomeration of LineSeries and GlyphSeries types from @visx/xychart</p> <p>Tip</p> <p>Registering your SeriesModel and SeriesModelEditor plugins will automatically register those plugins as Models and ModelEditors as well, which will make them available in UI Plugins that use the ModelFactory and ModelEditorFactory</p>"},{"location":"docs/graphs/plugin-points/series-renderers/#example","title":"Example","text":"ModelEditorRendererSetup <p>File LineGlyphModel.js. <pre><code>import ModelUtil from '@leverege/model-util'\nimport DotGlyphModel from '../glyph/DotGlyphModel'\n\nconst TYPE = 'graph.series.glyphLine'\nconst name = 'Glyph Line'\n\nfunction create( extend ) {\nreturn {\ntype : TYPE,\nname,\nstrokeOpacity : 1,\nglyph : DotGlyphModel.create(),\n...extend\n}\n}\n\nconst base = {\n...ModelUtil.createAllValue( 'strokeOpacity' ),\n...ModelUtil.createAllValue( 'glyph' )\n}\n\nexport default {\ncreate,\nTYPE,\nname,\ntype : TYPE,\ngetSeriesProps : ( model ) =&gt; {\nreturn {\nstrokeOpacity : base.getStrokeOpacity( model )\n}\n},\n...base\n}\n</code></pre></p> <p>getSeriesProps</p> <p>Note that this model type has a getSeriesProps function. This function will take an instance of your model and should return any props that should be passed to your renderer component, such as stroke colors, opacity or anything else you need to customize your renderer's look and feel. Your renderer will also be passed your entire model object as well, but getSeriesProps is designed to allow you to use components not designed with the model, editor and renderer paradigm in mind. It is, for example, how the appropriate props are passed to @visx/xychart's built-in series types without them needing to know about the model that is powering their appearance.</p> <p>Filename GlyphLineSeriesEditor.jsx. <pre><code>import React from 'react'\nimport { PropertyGrid, Pane, NumericInput } from '@leverege/ui-elements'\nimport { useValueChange } from '@leverege/ui-hooks'\nimport { ModelTypeSelector } from '@leverege/ui-plugin'\nimport { Plugins } from '@leverege/plugin'\n\nimport GlyphLineSeriesModel from '../../models/series/GlyphLineSeriesModel'\n\nexport default function GlyphLineSeriesEditor( props ) {\nconst { value, objectType } = props\nconst onModelChange = useValueChange( GlyphLineSeriesModel, props )\n\nreturn (\n&lt;Pane style={{ '--propertyGrid-numColumns' : 2 }}&gt;\n&lt;PropertyGrid variant=\"seriesEditor|editor\"&gt;\n&lt;PropertyGrid.Header title=\"Line\" /&gt;\n&lt;PropertyGrid.Item label=\"Stroke Opacity\"&gt;\n&lt;NumericInput\nvalue={GlyphLineSeriesModel.getStrokeOpacity( value )}\neventData=\"setStrokeOpacity\"\nmin={0}\nmax={1}\nfloat\nonChange={onModelChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;PropertyGrid.Header title=\"Glyph\" /&gt;\n{ ModelTypeSelector.createSelectorAndEditor( {\nvalues : Plugins.get( 'GlyphModel' ),\nvalue : GlyphLineSeriesModel.getGlyph( value ),\neventData : 'setGlyph',\nonChange : onModelChange,\nallowNone : false,\nisPropertyGrid : true,\nmodelKey : 'model',\npropertyGridOpts : {\nfill : true\n},\neditorProps : {\nobjectType\n}\n} ) }\n&lt;/PropertyGrid&gt;\n&lt;/Pane&gt;\n)\n}\n</code></pre></p> <p>Filename GlyphLineSeries.jsx. <pre><code>import React, { useCallback } from 'react'\nimport { GlyphSeries, LineSeries } from '@visx/xychart'\nimport GlyphLineSeriesModel from '../../models/series/GlyphLineSeriesModel'\nimport { GlyphRendererFactory } from '../Factory'\n\nexport default function GlyphLineSeries( props ) {\nconst { dataKey, data, xAccessor, yAccessor, strokeOpacity, model } = props\nconst glyphModel = GlyphLineSeriesModel.getGlyph( model )\n\nconst renderGlyph = useCallback( ( glyphProps ) =&gt; {\nreturn GlyphRendererFactory.create( glyphModel, {\n...glyphProps\n} )\n}, [ glyphModel ] )\n\nreturn (\n&lt;React.Fragment&gt;\n&lt;LineSeries\ndataKey={dataKey}\ndata={data}\nxAccessor={xAccessor}\nyAccessor={yAccessor}\nstrokeOpacity={strokeOpacity} /&gt;\n&lt;GlyphSeries\ndataKey={dataKey}\ndata={data}\nxAccessor={xAccessor}\nyAccessor={yAccessor}\nrenderGlyph={renderGlyph} /&gt;\n&lt;/React.Fragment&gt;\n)\n}\n</code></pre></p> <p>Filename PluginSetup.js. <pre><code>import GlyphLineSeriesModel from './GlyphLineSeriesModel'\nimport GlyphLineSeriesEditor from './GlyphLineSeriesEditor'\nimport GlyphLineSeries from './GlyphLineSeries'\n\nPlugins.add( 'SeriesModel', { type : GlyphLineSeriesModel.TYPE, name : GlyphLineSeriesModel.name, model : GlyphLineSeriesModel } )\nPlugins.add( 'SeriesModelEditor', { type : GlyphLineSeriesModel.TYPE, editor : GlyphLineSeriesEditor } )\nPlugins.add( 'SeriesRenderer', { type : GlyphLineSeriesModel.TYPE, renderer : GlyphLineSeries } )\n</code></pre></p> <p>Tip</p> <p>As you can see, this model encapsulates a Glyph Model inside of it, this editor provides the ability to edit the model using a model editor factory and this renderer uses a glyph renderer factory to render the glyph portion of the renderer. This composition is a common pattern and can save a great deal of code.</p>"},{"location":"docs/graphs/plugin-points/glyphs/","title":"Glyphs","text":"<p>Glyphs are symbols that you can use in your graphs. Like most graph components, a Glyph can be any valid svg, including shapes, images or text. UI Attribute Graphs has a number of built in Glyph types, and you can extend these types by implementing a Glyph Symbolizer or Glyph Renderer.</p>"},{"location":"docs/graphs/plugin-points/glyphs/glyph-renderers/","title":"Glyph Renderers","text":"<p>Glyph Renderers are plugins that know how to render a glyph, which is a visual indicator at a point on an XYChart. Glyphs can be shapes, text or more complex constructions. Since they are based on svg, any element type supported by that standard can be rendered as a glyph. UI Attributes Graphs comes with several built in Glyph Renderer types that can be used to render series data or rollover tooltip markers.</p>"},{"location":"docs/graphs/plugin-points/glyphs/glyph-renderers/#dot","title":"Dot","text":"<p>The Dot renderer renders a circle of a configurable size, stroke and fill at a point.</p>"},{"location":"docs/graphs/plugin-points/glyphs/glyph-renderers/#square","title":"Square","text":"<p>The Square renderer renders a square of a configurable size, stroke and fill at a point.</p>"},{"location":"docs/graphs/plugin-points/glyphs/glyph-renderers/#text","title":"Text","text":"<p>The Text renderer renders a given text string of a configurable font size and stroke at a point. The Text renderer can use Glyph Symbolizers to customize the glyph that is rendered based on object data.</p>"},{"location":"docs/graphs/plugin-points/glyphs/glyph-renderers/#custom-glyph-renderers","title":"Custom Glyph Renderers","text":"<p>Let's take a look at the library's implementation of the Dot glyph renderer as an example of how one might add their own custom Glyph type:</p> ModelEditorDotGlyphRendererSetup <p>File DotGlyphModel.js. <pre><code>import ModelUtil from '@leverege/model-util'\n\nconst TYPE = 'graph.glyph.dot'\n\nfunction create( extend ) {\nreturn {\ntype : TYPE,\nstroke : null,\nfill : null,\nsize : 14\n}\n}\n\nexport default {\nTYPE,\ncreate,\n...ModelUtil.createAllValue( 'stroke' ),\n...ModelUtil.createAllValue( 'fill' ),\n...ModelUtil.createAllValue( 'size' ),\nname : 'Dot'\n}\n</code></pre></p> <p>File DotGlyphEditor.js. <pre><code>import React from 'react'\nimport { PropertyGrid, Pane, NumericInput, Label } from '@leverege/ui-elements'\nimport { useValueChange } from '@leverege/ui-hooks'\nimport { ModelTypeSelector } from '@leverege/ui-plugin'\nimport { Colorizers } from '@leverege/ui-attributes'\n\nimport DotGlyphModel from '../../models/glyph/DotGlyphModel'\n\nexport default function DotGlyphEditor( props ) {\nconst { value, objectType } = props\nconst onModelChange = useValueChange( DotGlyphModel, props )\n\nreturn (\n&lt;Pane style={{ '--propertyGrid-numColumns' : 2 }}&gt;\n&lt;PropertyGrid variant=\"glyphEditor|editor\"&gt;\n&lt;PropertyGrid.Item label=\"Size\"&gt;\n&lt;NumericInput\nvalue={DotGlyphModel.getSize( value )}\neventData=\"setSize\"\nonChange={onModelChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n{ ModelTypeSelector.createSelectorAndEditor( { modelKey : 'colorizer',\nvalues : Colorizers.getColorizersFor( objectType ),\nvalue : DotGlyphModel.getStroke( value ), eventData : 'setStroke',\nonChange : onModelChange,\nisPropertyGrid : true,\npropertyGridOpts : {\npreLabel : &lt;Label&gt;Stroke Color&lt;/Label&gt;,\n}\n} )}\n{ ModelTypeSelector.createSelectorAndEditor( { modelKey : 'colorizer',\nvalues : Colorizers.getColorizersFor( objectType ),\nvalue : DotGlyphModel.getFill( value ), eventData : 'setFill',\nonChange : onModelChange,\nisPropertyGrid : true,\npropertyGridOpts : {\npreLabel : &lt;Label&gt;Fill Color&lt;/Label&gt;\n}\n} )}\n&lt;/PropertyGrid&gt;\n&lt;/Pane&gt;\n)\n}\n</code></pre></p> <p>File DotGlyphRenderer.jsx. <pre><code>import React from 'react'\nimport { GlyphDot } from '@visx/glyph'\nimport { Colorizers } from '@leverege/ui-attributes'\n\nimport DotGlyphModel from '../../models/glyph/DotGlyphModel'\n\nexport default function DotGlyphRenderer( props ) {\nconst { model, size : pSize, color, x, y, datum, context } = props\nconst size = DotGlyphModel.getSize( model ) || pSize\nconst strokeModel = DotGlyphModel.getStroke( model )\nconst fillModel = DotGlyphModel.getFill( model )\n\nconst stroke = Colorizers.getColor( strokeModel, datum, { ...context, seriesColor : color } ) || color\nconst fill = Colorizers.getColor( fillModel, datum, { ...context, seriesColor : color } ) || color\n\nreturn (\n&lt;GlyphDot\nleft={x}\ntop={y}\nr={size / 2}\nstroke={stroke}\nfill={fill} /&gt;\n)\n}\n</code></pre></p> <p>File PluginSetup.js. <pre><code>import DotGlyphModel from './DotGlyphModel'\nimport DotGlyphEditor from './DotGlyphEditor'\nimport DotGlyphRenderer from './DotGlyphRenderer'\n\nmolten.addPlugin( 'GlyphModel', { type : DotGlyphModel.TYPE, name : DotGlyphModel.name, model : DotGlyphModel } )\nmolten.addPlugin( 'GlyphModelEditor', { type : DotGlyphModel.TYPE, editor : DotGlyphEditor } )\nmolten.addPlugin( 'GlyphRenderer', { type : DotGlyphModel.TYPE, renderer : DotGlyphRenderer } )\n</code></pre></p> <p>Tip</p> <p>Registering your model and editor using the 'GlyphModel' and 'GlyphModelEditor' will automatically register those plugins with the 'Model' and 'ModelEditor' plugin points, which is an important step that allows various generic model selectors and factories to know about your model and editor.</p> <p>You can see that the DotGlyphRenderer returns an instance of DotGlyph from the @visx/glyph library, but that component in turn just renders plain svg and is not much more than a convenience wrapper. A Glyph Renderer can return any valid svg.</p>"},{"location":"docs/graphs/plugin-points/glyphs/glyph-symbolizers/","title":"Glyph Symbolizers","text":"<p>Similar to Colorizers, Glyph Symbolizers can be used to conditionally render a glyph at a data point based on the data data in the target object. They allow you to define a function which can return a symbol to be used by a glyph renderer (either for a series data point or a rollover tooltip indicator).</p> <p>UI Attributes Graphs comes with one built-in Glyph Symbolizer,  the Value Glyph Symbolizer which simple allows a user to choose a static string of text to be rendered at every point.</p>"},{"location":"docs/graphs/plugin-points/glyphs/glyph-symbolizers/#custom-glyph-symbolizers","title":"Custom Glyph Symbolizers","text":"<p>Here is an example of an Alert Symbolizer that shows a particular symbol when a given temperature threshold has been exceeded:</p>"},{"location":"docs/graphs/plugin-points/glyphs/glyph-symbolizers/#example","title":"Example","text":"SymbolizerEditorSetup <p>File AlertGlyphSymbolizer.js. <pre><code>import ModelUtil from '@leverege/model-util'\nimport { Attributes } from '@leverege/ui-attributes'\n\nconst TYPE = 'symbolizer.test.history.Alert'\n\nexport default {\ncreate() {\nreturn {\ntype : TYPE,\nvalue : 30,\nsymbol : '\ud83d\ude03',\nalertSymbol : '\ud83d\ude08'\n}\n},\nsymbolFor( model, obj, context ) {\nconst temp = Attributes.get( 'test.history.temperature', obj.type, obj.data )\n\nif ( temp.value &gt; model.value ) {\nreturn model.alertSymbol\n}\n\nreturn model.symbol\n},\n...ModelUtil.createAllValue( 'value' ),\n...ModelUtil.createAllValue( 'symbol' ),\n...ModelUtil.createAllValue( 'alertSymbol' ),\nTYPE\n}\n</code></pre></p> <p>File AlertSymbolizerEditor.jsx. <pre><code>import { NumericInput, TextInput, PropertyGrid } from '@leverege/ui-elements'\nimport { useValueChange } from '@leverege/ui-hooks'\n\nimport AlertGlyphSymbolizer from './AlertGlyphSymbolizer'\n\nexport default function AlertSymbolizerEditor( props ) {\nconst { value } = props\n\nconst onModelChange = useValueChange( AlertGlyphSymbolizer, props )\n\nreturn (\n&lt;PropertyGrid&gt;\n&lt;PropertyGrid.Item label=\"Alert Value\"&gt;\n&lt;NumericInput\nvalue={AlertGlyphSymbolizer.getValue( value )}\nhint=\"Alert Value\"\nfloat\neventData=\"setValue\"\nonChange={onModelChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;PropertyGrid.Item label=\"Symbol\"&gt;\n&lt;TextInput\nvalue={AlertGlyphSymbolizer.getSymbol( value )}\nhint=\"Symbol\"\neventData=\"setSymbol\"\nonChange={onModelChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;PropertyGrid.Item label=\"Alert Symbol\"&gt;\n&lt;TextInput\nvalue={AlertGlyphSymbolizer.getAlertSymbol( value )}\nhint=\"Alert Symbol\"\neventData=\"setAlertSymbol\"\nonChange={onModelChange} /&gt;\n&lt;/PropertyGrid.Item&gt;\n&lt;/PropertyGrid&gt;\n)\n}\n</code></pre></p> <p>File PluginSetup.js. <pre><code>import AlertGlyphSymbolizer from './AlertGlyphSymbolizer'\nimport AlertSymbolizerEditor from './AlertSymbolizerEditor'\n\nmolten.addPlugin( 'Model', { type : AlertGlyphSymbolizer.TYPE, model : AlertGlyphSymbolizer } )\nmolten.addPlugin( 'ModelEditor', { type : AlertGlyphSymbolizer.TYPE, editor : AlertSymbolizerEditor } )\nmolten.addPlugin( 'GlyphSymbolizer', { type : AlertGlyphSymbolizer.TYPE, name : 'Alert Symbolizer', symbolizer : AlertGlyphSymbolizer } )\n</code></pre></p> <p>This Glyph Symbolizer will render a \ud83d\ude03 when an object's temperature is less than or equal to a ceratin threshold and a \ud83d\ude08 when the temperature is greater.</p> <p>You are encouraged to use Glyph Symbolizers in your own plugins when applicable to increase potential customization by users.</p>"},{"location":"docs/graphs/xychart/","title":"XYChart","text":""},{"location":"docs/graphs/xychart/#purpose","title":"Purpose","text":"<p>An XYChart is a type of graph that renders a series or multiple series of data on an X-Y coordinate plane. It can for instance, render something like temperature or battery level of a sensor over time. To do this, the XYChart needs a model, some formatted data and a renderer.</p>"},{"location":"docs/graphs/xychart/#model","title":"Model","text":"<p>The XYChartModel describes the type of graph that the XYChart will produce, from the type of series (Line, Bar, Area, etc.) to which datum should be used for the x and y coordinates (based on UI Attributes), to the scale that each axis should be rendered on (Linear, Time, Band, etc.)</p> <p>When running in a Molten environment, attributes will be created for all Blueprint attributes in your Imagine project and the UI Attributes Graphs library will automatically create coordinate types for each of your attributes and assign them an appropriate default scale for their data type. For instance, an attribute with the value type of 'timestamp' will be graphable by default and will automatically be assigned a 'Time' scale type.</p>"},{"location":"docs/graphs/xychart/#data","title":"Data","text":"<p>Data for the XYChart graph is simply an object with unique keys and values comprised of arrays of object refs representing the various series that you wish to graph. UI Atttributes Graphs exports a <code>useSeriesData</code> hook as a convenience in order to take data in a single array format and separate it into series chunks given an attribute to chunk on. For instance, the following data array: <pre><code>const dataArray = [\n{\n\"type\": \"test.history\",\n\"id\": \"1\",\n\"data\": {\n\"time\": 1642444110759,\n\"name\": \"Device 1\",\n\"data\": {\n\"temperature\": 45.7891\n}\n}\n},\n{\n\"type\": \"test.history\",\n\"id\": \"2\",\n\"data\": {\n\"time\": 1642461033498,\n\"name\": \"Device 1\",\n\"data\": {\n\"temperature\": 40.7705\n}\n}\n},\n{\n\"type\": \"test.history\",\n\"id\": \"3\",\n\"data\": {\n\"time\": 1642411955689,\n\"name\": \"Device 1\",\n\"data\": {\n\"temperature\": 48.7092\n}\n}\n},\n{\n\"type\": \"test.history\",\n\"id\": \"7\",\n\"data\": {\n\"time\": 1642474048199,\n\"name\": \"Device 2\",\n\"data\": {\n\"temperature\": 12.299\n}\n}\n},\n{\n\"type\": \"test.history\",\n\"id\": \"8\",\n\"data\": {\n\"time\": 1642407220379,\n\"name\": \"Device 2\",\n\"data\": {\n\"temperature\": 5.4862\n}\n}\n},\n{\n\"type\": \"test.history\",\n\"id\": \"9\",\n\"data\": {\n\"time\": 1642478679300,\n\"name\": \"Device 2\",\n\"data\": {\n\"temperature\": 4.5652\n}\n}\n}\n]\n</code></pre> can be passed to the useSeriesData hook with a chunk attribute of 'name' (and an optional sortAttribute of 'test.time' in order to produce arrays sorted by that attribute) in order to produce a chunked data object like so: <pre><code>const seriesData = useSeriesData( dataArray, 'name', { sortAttribute : 'test.time' } )\n\n/*\n  seriesData =&gt; {\n  \"Device 2\": [\n    {\n      \"type\": \"test.history\",\n      \"id\": \"8\",\n      \"data\": {\n        \"time\": 1642407220379,\n        \"name\": \"Device 2\",\n        \"data\": {\n          \"temperature\": 5.4862\n        }\n      }\n    },\n    {\n      \"type\": \"test.history\",\n      \"id\": \"7\",\n      \"data\": {\n        \"time\": 1642474048199,\n        \"name\": \"Device 2\",\n        \"data\": {\n          \"temperature\": 12.299\n        }\n      }\n    },\n    {\n      \"type\": \"test.history\",\n      \"id\": \"9\",\n      \"data\": {\n        \"time\": 1642478679300,\n        \"name\": \"Device 2\",\n        \"data\": {\n          \"temperature\": 4.5652\n        }\n      }\n    }\n  ],\n  \"Device 1\": [\n    {\n      \"type\": \"test.history\",\n      \"id\": \"3\",\n      \"data\": {\n        \"time\": 1642411955689,\n        \"name\": \"Device 1\",\n        \"data\": {\n          \"temperature\": 48.7092\n        }\n      }\n    },\n    {\n      \"type\": \"test.history\",\n      \"id\": \"1\",\n      \"data\": {\n        \"time\": 1642444110759,\n        \"name\": \"Device 1\",\n        \"data\": {\n          \"temperature\": 45.7891\n        }\n      }\n    },\n    {\n      \"type\": \"test.history\",\n      \"id\": \"2\",\n      \"data\": {\n        \"time\": 1642461033498,\n        \"name\": \"Device 1\",\n        \"data\": {\n          \"temperature\": 40.7705\n        }\n      }\n    }\n  ]\n}\n */\n</code></pre> If you can't use the hook because of the complexity of your data or formatting needs, a normal object keyed on some unique property will work fine, just remember to memoize the data yourself.</p>"},{"location":"docs/graphs/xychart/#renderer","title":"Renderer","text":"<p>The last thing we need to render an XYChart is... a renderer. Luckily this is the simplest part of the equation. UI Attributes Graphs provides an XYChart component which takes a model instance, some data and an objectType string and will render your data in stunning color.</p> <pre><code>import { XYChartModel, XYChartRenderer, useSeriesData } from '@leverege/ui-attributes-graphs'\n\nconst [ model, setModel ] = useState( XYChartModel.create() )\nconst seriesData = useSeriesData( myUnformattedData, 'name', { sortAttribute : 'test.time' } )\n\nreturn (\n&lt;XYChartRenderer\ndata={seriesData}\nobjectType=\"test.history\"\nmodel={model} /&gt;\n)\n</code></pre>"},{"location":"docs/routes/","title":"Adding a Screen","text":"<p>Molten will by default, analyze your Imagine project's Blueprints and create Screens and Routes to the screens based off of their hierarchies. Custom Screens can be added, however. There are normally three parts to this process: creation of the Screen component, registering a Route to a URL, and making a Link to take the user to the URL.</p> <p>Molten uses React Router and Plugins define which screens are presented at a particular URL. The screen presented at a URL may actually be composed of several subscreens, depending on how the Routes are specific. For example, a URL of <code>/Group/5/Children</code> may actually present a screen for <code>Group/5</code>, which has some links, widgets, information, etc, but also has a Dynamic Route mechanism it it that would also present the <code>Children</code> screen.</p> <p>Route Plugins are evaluated and installed when the <code>getRoutesFor()</code> call is invoked. This can occur in multiple screens in your application. The <code>DesktopMainScreen</code>, for example calls:</p> <pre><code>  &lt;Switch&gt;\n    {Routes.getRoutesFor( 'Main', null, { client : 'Main' } )}\n  &lt;/Switch&gt;\n</code></pre> <p>This is asking for all Routes that wish to be installed at the 'Main' client level. Route Plugins should specify a <code>matches</code> object that indicates where it wishes to be installed. </p>"},{"location":"docs/routes/links/","title":"Links","text":"<p>Links to a Screen can be done in many ways. Any standard component can change the URL when told to do so by the user. In the case of the default Molten Desktop Screen, toolbars are install to allow th user to put custom actions to perform a variety of commands such as logging out, changing persona, bring up a dialog, or going to a URL. </p> <p>To got to our new Route and Screen using the toolbars, we can use the <code>LinkAction.create()</code> to create an action that will integrate with the existing menus. The following options can be given to the create function:</p> Field Type Description id String The unique plugin id matches Object An object specifying where the the Action should appear. Normally, the <code>client</code> is specified and in come cases an even finer criteria layout Object The Plugins Layout object that can specify where the action should appear, including submenuing, section names and sorting. See Layout path String The URL path to take the user to name String or funciton The name of string to show the user icon String The font icon or url to use as an icon for the action iconOn String The font icon or url to use as an icon for the action when the user is at the path. iconOff String The font icon or url to use as an icon for the action when the user is not at the path handles function The action handles method that can be used to further refined if this action is visible"},{"location":"docs/routes/links/#example","title":"Example","text":"PluginSetup <p>File IncredibleLink.js. <pre><code>  export default LinkAction.create( {\nid : 'my.link.IncredibleScreen',\nmatches : { use : 'userBar', client : 'Main' },\nname : 'Incredible', icon : 'fa fa-snowflake-o fa-fw',\npath : '/iscreen'\n} )\n</code></pre> In this case, we are going to put the link to <code>/iscreen</code> into the Main Screen's user profile toolbar (targeted by using <code>use : \"userBar\"</code>) with the name \"Incredible\" and a snowflake icon.</p> <p>Be sure to install your plugin in your PluginSetup.js file. <pre><code>  exports.install = ( molten ) =&gt; {\nmolten.addPlugin( 'Action', IncredibleLink )\n}\n</code></pre></p>"},{"location":"docs/routes/routes/","title":"Routes","text":"<p>The Routes defines what to render, where. The what is a React component, and the where is a URL. The route is a directive to tell Molten to render a particular React component at a matching url pattern when certain criteria are met. The criteria is captured in the <code>matches</code> object defined by the plugin, and follows the rules of the Plugin Matches system.</p> <p>To define a Route, add a <code>Route</code> Plugin that has the following properties:</p> Field Type Description id String The unique plugin id exact boolean If <code>true</code>, the URL must match exactly the path. This should be true in the case of a leaf screen, <code>false</code> in the case where the screen manages deeper parts of the url. For example, our <code>/Group/5</code> screen above would set this to <code>false</code> and then render its own <code>Switch</code> Component using the <code>Routes</code> object. path String or Array The path expression used to match eg. <code>/group/:groupId</code> matches Object An object specifying where the the route should appear. Normally, the <code>client</code> is specified component ReactComponent or Function The component to render render function Optional React function to render props Object or null Extra props to send into the component. These can be overridden by extra props sent into the <code>getRoutesFor</code> function strict boolean If true, the path will compare trailing slashes"},{"location":"docs/routes/routes/#example","title":"Example","text":"PluginSetup <p>File IncredibleRoute.js. <pre><code>  export default {\nid : 'my.route.IncredibleScreen',\nexact : true,\npath : '/iscreen/',\nmatches : { client : 'Main' }, component : IncredibleScreen,\nprops : {\nhello : 'world'\n}\n}\n</code></pre></p> <p>This plugin is asking Molten to render the <code>IncredibleScreen</code> when the URL path is exactly <code>/iscreen/</code>. It will only be matched at the top level Switch, managed by the <code>Main</code> client. Extra prop will be given to the screen. </p> <p>Be sure to install your plugin in your PluginSetup.js file. <pre><code>      exports.install = ( molten ) =&gt; {\nmolten.addPlugin( 'Route', IncredibleRoute )\n}\n</code></pre></p>"},{"location":"docs/routes/routes/#dynamic-plugin-addition","title":"Dynamic Plugin Addition","text":"<p>The Routing mechanism is listening for changes to the routes, so Routes added during execution will be used the next time the Switch/getRoutesFor() is called.</p> <p>The order in which the plugins are added does not matter. The order in which Routes are returned are based on a specificity. </p> <p>Sorting Paths</p> <p>The routes are turned into strings of 'A's, 'C's, 'E's and 'R's, where 'A' are explicit path components, and 'C's are variable (changeable) parameters, 'E's are extact match and 'R's indicates the rest matches too. These will then be sorted first by length, then by string sort on the ACER strings.</p>"},{"location":"docs/routes/screens/","title":"Screens","text":"<p>A Screen is just a React Component. It can pretty much do what it wants. It can connect to Redux, it can call external APIs, it can use its own custom Plugins, it can other Plugins mechanism that already exist such as attributes or toolbars, it can use <code>Routes.getRoutesFor()</code> to have its own sub registered Routes/Screens with a custom navigation mechanism.</p> <p>The only real consideration is that the screen will be given an area to render in, and it should manage it own rendering and scroll areas. This is good place to use ui-elements' <code>Content</code>,  but other mechanism can work as well.</p> <p>React Components</p> <p>We highly recommend using <code>@leverege/ui-elements</code> for your components, as they will inherit the theme used for the rest of the screens. You can also use the css variables that the theme exports to aid with this theme consistency if using the ui-elements library is not feasible.</p>"},{"location":"docs/routes/screens/#example","title":"Example","text":"<p>In the following example, our IncredibleScreen will have a title bar, and action toolbar to accept plugins, and a greeting.</p> <p>File IncredibleRoute.js. <pre><code>import React from 'react'\nimport { connect } from 'react-redux'\nimport { Text, Content } from '@leverege/ui-elements'\nimport { Config } from '@leverege/plugin'\nimport { TitleBar, Toolbar } from '@leverege/ui-plugin'\n\nclass IncredibleScreen extends React.Component {\n\nrender() {\nconst { hello = '-' } = this.props\n// Putting welcome into the matchContext for the\n// tool bar is not required, but would all actions\n// to only appear if welcome is a certain value\nthis.matchContext = { client : 'IncredibleScreen', welcome : hello }\n\nreturn ( &lt;Content&gt;\n&lt;Content.Header&gt;\n&lt;TitleBar variant=\"screenTitle\" title=\"Incredible Screen\" icon={Config.get( 'IncredibleScreen', 'screenIcon', 'fa fa-snowflake-o fa-fw' )}&gt;\n&lt;Toolbar\nvariant=\"actionBar\"\nprefer=\"icon\"\nhasContextMenu={false}\nmatchContext={this.matchContext}\ncontext={{}} /&gt;\n&lt;/TitleBar&gt;\n&lt;/Content.Header&gt;\n&lt;Content.Area variant=\"screenContent\"&gt;\n&lt;Text variant=\"caption\" icon=\"fa fa-snowflake fa-fw\"&gt;\nMy incredible Screen!\n&lt;/Text&gt;\n&lt;Text variant=\"smallCaption\" icon=\"fa fa-snowflake fa-fw\"&gt;\nHello {hello}!\n&lt;/Text&gt;\n&lt;/Content.Area&gt;\n&lt;/Content&gt;\n)\n}\n}\n\nexport default connect(\nstate =&gt; ( {\n} )\n)( IncredibleScreen )\n</code></pre></p>"},{"location":"docs/startup/","title":"Startup","text":"<p>There are many phases to startup. Plugins are used to drive as many of these as possible. The startup flow looks like:</p> flowchart TB   subgraph Providers     E[Run Reducer Plugins] --&gt; F[Run Middleware Plugins];   end   subgraph Prerender     direction LR;     PRA[Verify Current User] --&gt; PRB[Load OIDC Clients];   end   subgraph OnLogin [Run On Login Plugins ]     LA[Role Downloading] --&gt; LB[Blueprint Analysis];     LB --&gt; LC[Custom];   end   A[Load Plugins] --&gt; B[Run Initializers Plugins];   B --&gt;C[Run Support Component Plugins];   C --&gt; D[Run Provider Plugins];   D --&gt; Providers;   Providers --&gt; Prerender;   Prerender --&gt; Auth{Valid User?};   Auth -- Yes --&gt; Render[Render Main React App];   Auth -- No --&gt; Login[Render Login Screen];   Login --&gt; Auth;   Render --&gt; OnLogin;   click B href \"./initializers/\" \"Run the Initializer Plugins\" _self   click C href \"./support-components/\" \"Run the Component Support Plugins\" _self  <ul> <li>Init Molten<ul> <li>This loads the default Plugins</li> </ul> </li> <li>Load custom plugins<ul> <li>Implemented by custom application</li> </ul> </li> <li>Run all Initializer Plugins</li> <li>Run all Support Component Plugins</li> <li>Run all Provider Plugins<ul> <li>Reducer Plugins run from ReduxStore plugin</li> <li>Middleware Plugins run from ReduxStore plugin</li> </ul> </li> <li>Run all Prerender Plugins<ul> <li>Auth verify run by Auth plugin</li> <li>Oidc loaded here to be ready for login screen by Auth plugin</li> </ul> </li> <li>Render React application</li> <li>Login/Authentication</li> <li>LoggedIn Plugins run<ul> <li>Role downloading</li> <li>Blueprint Analysis<ul> <li>Auto plugins created</li> </ul> </li> </ul> </li> </ul>"},{"location":"docs/startup/initializers/","title":"Initializer Plugins","text":"<p>The Plugins installed at <code>Constants.INITIALIZER</code> or <code>'Molten.Initializer'</code> are invoked after as the first step in <code>Molten.create()</code>. These plugins should have an <code>id</code>, <code>sort</code>, and <code>init( molten )</code> function as properties. This function can be async and the next initializer in the chain will not be called until the one before it finishes.</p> <p>Initializers can initialize objects from the config options (<code>molten.getConfig()</code>) and make them available to other steps by calling <code>molten.set( key, value )</code> or <code>molten.setThunk( key, )</code>.</p>"},{"location":"docs/startup/initializers/#example","title":"Example","text":"PluginSetup <p>File MyInitializer.js. <pre><code>  export default {\nid : 'my.Initializer',\nsort : -5, // defaults to 0, \ninit : ( molten ) =&gt; {\nconst api = new Api( molten.getConfig( 'api' ) ) molten.set( 'api' )\nmolten.setThunkArg( 'api', api )\n}\n}\n</code></pre></p> <p>Be sure to install your plugin in your PluginSetup.js file. <pre><code>  Plugin.add( 'Molten.Initializer', MyInitialize )\n</code></pre></p>"},{"location":"docs/startup/initializers/#default-initializers","title":"Default Initializers","text":"<p>The inital Molten setup will install the following plugins as Initializer Plugins.</p> Type Sort Description molten.LoadConfig -1000000 This will take values from <code>config.plugins.config</code> and call Config.set( resource, key, value ). The <code>config.plugins.config</code> should be configured with as {  : {  :  } } molten.Splash -100000 This will create a splash screen based on the config's <code>molten.splashClass</code>, if present. molten.ApiInit -100 This will create an Api object to interface to Leverege's platform and advertise it as a the 'api' thunk argument and the value 'api' in Molten's values. molten.RouterInit -30 Creates a history object and sets it as 'history' in molten's values."},{"location":"docs/startup/redux/","title":"Redux","text":"<p>Redux here</p>"},{"location":"docs/startup/support-components/","title":"Support Component Plugins","text":"<p>The Plugins installed at <code>Constants.SUPPORT_COMPONENTS</code> or <code>'Molten.SupportComponent'</code> are invoked just before the Providers. These plugins should have an <code>id</code>, <code>sort</code>, and <code>createSupportComponents( molten )</code> function as properties. This function should an array of components to be placed beside the Application. Support components like Toast and Dialogs can use this.</p> <p>In the React world, these components are used to install components to support the final app. They are siblings of the Main application and exist within the providers: <pre><code>  &lt;X.Provider&gt;\n&lt;AuthCheckScreen/&gt;\n&lt;MySypportComponent/&gt;\n&lt;Toast/&gt;\n&lt;Dialogs/&gt;\n&lt;...other Support Components...&gt;\n&lt;/X.Provider&gt;\n</code></pre></p> <p>The plugin should have a createSupportComponents( molten ) function that returns an array of support components to install.</p>"},{"location":"docs/startup/support-components/#example","title":"Example","text":"PluginSetup <p>File MySupportComponent.js. <pre><code>  export default {\nid : 'molten.Theme',\nsort : 0, createSupportComponents : ( molten ) =&gt; {\nreturn [\nReact.createElement( Toast, { key : 'theme.toast', containerId : 'default' } ),\nReact.createElement( Dialogs, { key : 'theme.dialogs' } )\n]\n}\n}\n</code></pre></p> <p>Be sure to install your plugin in your PluginSetup.js file. <pre><code>  Plugin.add( 'Molten.SupportComponents', MySupportComponent )\n</code></pre></p>"},{"location":"docs/startup/support-components/#default-support-components","title":"Default Support Components","text":"Type Sort Description molten.Theme 0 This will install Toast and Dialogs support"},{"location":"docs/table/","title":"Table","text":""},{"location":"docs/table/#purpose","title":"Purpose","text":"<p>Unsurprisingly, the purpose of the Table module is to render tabular data. To do so, it needs a model, some data and a renderer.</p>"},{"location":"docs/table/#model","title":"Model","text":"<p>The TableModel from the @leverege/ui-attributes library provides all of the configuration options necessary to render a table component. THe only top-level option is whether each table row should be selectable, meaning whether a checkbox should be rendered to the left most side of each row to allow selection. The rest of the table model is dedicated to a list of Columns, each of which has their own options which are documented elsewhere. It is worth noting here however that ColumnCreators (objects that are capable of creating table column models) are automatically generated for each Attribute that is created, making attributes eligible for inclusion in a table by default.</p>"},{"location":"docs/table/#data","title":"Data","text":"<p>The data for a table instance is simply an array of object refs.</p>"},{"location":"docs/table/#renderer","title":"Renderer","text":"<p>The renderer for a Table is the TableView, found in @leverege/molten.</p>"},{"location":"docs/table/#actions-match","title":"Actions Match","text":"<p>There are four toolbars within each table view that you can target to install Actions with the following match contexts:</p> Location Match Context Top Left <code>{ use : 'filterBar', client : 'TableDataViewer | HistoryTableViewer', objectType, path }</code> Top Right <code>{ use : 'actionBar', client : 'TableDataViewer | HistoryTableViewer', objectType, path }</code> Bottom Left <code>{ use : 'footerLeft', client : 'TableDataViewer | HistoryTableViewer', objectType, path }</code> Bottom Right <code>{ use : 'footerRight', client : 'TableDataViewer | HistoryTableViewer', objectType, path }</code>"},{"location":"docs/table/columns/","title":"Columns","text":"<p>Most of the available customization in the Table module is in tweaking and customizing the way that columns are rendered. By default, each attribute you create will automatically have a ColumnCreator generated for it. This column creator is capable of generating an AttributeColumnModel or UnitAttributeColumnModel depending upon whether your attribute represents a unit type or not. AttributeColumnModel and UnitAttributeColumnModel instances each have built in editors and renderers that are capable of allowing a user to customize things like text color, font style, background color, unit and value formatting, unit conversion and more.</p>"},{"location":"docs/table/columns/#customization","title":"Customization","text":"<p>You can also customize the behavior and appearance of table columns using the available table Plugin Points.</p>"},{"location":"docs/table/plugin-points/","title":"Plugin Points","text":"<p>Table plugin points allow you to customize the look and feel of your table in various ways.</p>"},{"location":"docs/table/plugin-points/attribute-cell-renderer/","title":"AttributeCellRenderer","text":"<p>Registering an AttributeCellRenderer plugin give you the chance to replace the default cell renderer for a particular table column. The best way to demonstrate is through a simple example.</p>"},{"location":"docs/table/plugin-points/attribute-cell-renderer/#example","title":"Example","text":"RendererSetup <p>File DoubleNameRenderer.jsx <pre><code>import React from 'react'\n\nfunction DoubleNameRenderer( props ) {\nconst { data : { value } } = props\nreturn `${value} ${value}`\n}\n\nexport default {\nobjectType : 'test',\nattrName : 'name',\nrenderer : ( data, props, context ) =&gt; {\nreturn React.createElement( DoubleNameRenderer, {\n...props,\ndata,\ncontext\n} )\n}\n}\n</code></pre></p> <p>File PluginSetup.js <pre><code>import DoubleNameRenderer from './DoubleNameRenderer'\n\nexport default {\ninstall( molten ) {\nmolten.addPlugin('AttributeCellRenderer', DoubleNameRenderer )\n}\n}\n</code></pre></p> <p>As you can see, the process is simply to register a renderer against a particular object type and attribute name. This will cause any cells rendered for that objectType ane attribute name combination to use our renderer instead of the default.</p> <p>The three arguments passed to the renderer function are as follows:</p> Prop Purpose data This is the data that is passed to each cell by the parent table. It includes almost all of the state of the entire table, including that of the current cell, the current row and all other rows. Notably though, data contains a property called \"value\" which is the actual value for this table cell. context This is the context that the table passes to each cell containing it's props under the <code>clientProps</code> key, the current row object under <code>target</code> and the original column renderer under the key <code>renderer</code>. This last property allows you to use the original renderer conditionally if you'd like to make some cells appear in their default state but for others to have a customized look by calling <code>renderer.renderCell( data, props, context )</code>. props These are additional style props that are passed to the cell component and are generally undefined. The TableView uses react-table internally, and for very custom table implementations, additional cell props can be provided to each cell through the react-table apis."},{"location":"docs/table/plugin-points/column-renderer/","title":"ColumnRenderer","text":"<p>In most cases, when you want to replace the default renderer for a column, an AttributeCellRenderer plugin will suffice. However, perhaps your custom data type has an Attribute with a <code>valueType</code> that the table does not support out of the box. For instance, the table does not have an image column renderer by default. Let's take a look at what you'd need to do to implement such a renderer.</p>"},{"location":"docs/table/plugin-points/column-renderer/#requirements","title":"Requirements","text":"<p>Each column renderer needs its own column model which defines all of the options that can be configured for that column. It can also optionally provide an editor to allow a user to change and tweak model options. And finally, it requires a renderer that knows how to convert a model and object ref data into a visualization of an attribute.</p>"},{"location":"docs/table/plugin-points/column-renderer/#example","title":"Example","text":"ModelRendererSetup <p>File ImageAttributeColumnModel.js. <pre><code>import { ColumnModel, Attributes } from '@leverege/ui-attributes'\n\n/* Initialize Constants */\nconst VALUE_TYPE = 'image'\nconst TYPE = `attr.column.${VALUE_TYPE}`\n\n/**\n* Gets name from data.\n*/\nfunction getName( data ) {\nreturn Attributes.getDisplayName( data.attrName, data.objectType )\n}\n\n/* Initialize Model Base */\nconst base = {\n...ColumnModel,\ngetName,\n}\ndelete base.create\n\n/**\n* Creates an attribute detail model instance.\n*/\nfunction create( attrName, objectType ) {\nreturn ColumnModel.create( TYPE, {\nattrName,\nobjectType,\n} )\n}\n\n/* Export Modules */\nmodule.exports = {\nTYPE,\ncreate,\n...base\n} </code></pre></p> <p>File ImageAttributeColumnRenderer.jsx <pre><code>import React from 'react'\n\nimport {AttributeColumnRenderer} from '@leverege/ui-attributes'\n\nexport default class ImageColumnRenderer extends AttributeColumnRenderer {\nrenderCell = ( data ) =&gt; {\nconst {\nvalue\n} = data\nreturn (\n&lt;img alt={value} src={value} /&gt;\n)\n}\n}\n</code></pre></p> <p>File PluginSetup.js <pre><code>import { Plugins } from '@leverege/plugin'\nimport AttributeColumnEditor from '@leverege/ui-attributes'\n\nimport ImageColumnModel from './ImageColumnModel'\nimport ImageColumnRenderer from './ImageColumnRenderer'\n\nexport default {\ninstall( molten ) {\nmolten.addPlugin( 'Model', { type : ImageColumnModel.TYPE, model : ImageColumnModel } )\nmolten.addPlugin( 'ModelEditor', { type : ImageColumnModel.TYPE, editor : AttributeColumnEditor } )\nmolten.addPlugin( 'ColumnRenderer', { type : ImageColumnModel.TYPE, renderer : ImageColumnRenderer } )\n}\n}\n</code></pre></p> <p>As you can see, this is a very simple example that simply extends the AttributeColumnModel, AttributeColumnEditor and AttributeColumnRenderer from @leverege/ui-attributes. In a real-life situation, you'd likely want to add additional parameters like a width and height for the image to the model and either extend or completely replace the column editor. More details on models and model editors can be found here.</p>"},{"location":"docs/table/plugin-points/model-configurer/","title":"TableModelConfigurer","text":"<p>The TableModelConfigurer Plugin Point allows you to register a function which will generate the default table model for a given matchContext. For instance, if you have an object type of \"vehicle\" in your application, you can register a TableModelConfigurer like this and it will be invoked for generating the default model for all tables whose Match context includes <code>objectType : 'vehicle'</code>:</p> ConfigurerSetup <p>File UnselectableTableModelConfigurer.js <pre><code>import { TableModel } from '@leverege/ui-attributes'\n\nexport default {\nid : 'unselectable.vehicle.TableModelConfigurer'\nsort : 'aaa',\nconfigure : ( tableModel, objectType, addName, cxt ) =&gt; {\nreturn TableModel.setSelectable( tableModel, false )\n}\n}\n</code></pre></p> <p>File PluginSetup.js <pre><code>import UnselectableTableModelConfigurer from './UnselectableTableModelConfigurer'\n\nexport default {\ninstall( molten ) {\nmolten.addPlugin( 'TableModelConfigurer', UnselectableTableModelConfigurer )\n}\n}\n</code></pre></p> <p>Each TableModelConfigurer plugin is passed the model instance from the configurer before it and is expected to return a model instance in turn. The first configurer will recieve a freshly initialized default model (the result of TableModel.create()). The order that each configurer is called in depends on the \"sort\" property of the plugin itself.</p> <p>Tip</p> <p>Molten comes with a default table model configurer for Imagine objects, the BlueprintTableModelConfigurerer.</p>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#overview","title":"Overview","text":"<p>The primary component of Leverege Build is Molten. Molten is a React-based plugin framework for rapid UI development. Simply write and register a plugin and Molten will make it available throughout your application exactly where you need it--without requiring changes to existing code.</p> <p>At its core, Molten is a plugin registry with update and access mechanisms. It also includes an extensive suite of pre-built plugins that solve common data patterns and visualizations. Molten's default plugins are designed to make it easy to build powerful IoT applications using the Leverege Stack, but Molten can be used on its own to make your codebase more modular, dynamic, and flexible.</p> <p>Molten gives you the ability register new plugins--code to be accessed elsewhere in the app--and to add new plugin points that call your custom code. This means you have maximum control over the data and displays driving your app. Add a button that appears on select toolbars. Call a function that conditionally colors icons based on external data. Query an API and render items on a table and a map. You can use Molten to make small changes to an existing app, or as a starting point for a totally custom product.</p> <p>Tip</p> <p>To learn more about Molten's key concepts before jumping in, see the Concepts section for an overview of plugins, models, and attributes.</p>"},{"location":"getting-started/#using-molten-with-levereges-iot-stack","title":"Using Molten with Leverege's IoT Stack","text":"<p>Leverege's IoT Stack provides a powerful, flexible system for working with internet connected devices, and the businesses built around them. Molten's default settings and plugins make working with your Leverege project simple.</p> <p>It handles user authentication and dynamically creates routes and views based on your Imagine project configuration. Molten uses Leverege's Builder tool for advanced themeing allowing you to dial in the look and feel of your app. You can learn more about configuring your Imagine project in the tutorials on the Leverege User Configuration.</p> <p>To get started:</p> <ul> <li>Install Molten: <code>npm i @leverege/molten</code></li> <li>Molten uses Mapbox for geographic utilities (map displays, geocoding). You will need to add a Mapbox API key to your <code>.env</code></li> </ul> <pre><code>  MAPBOX_APIKEY=your-api-key-here\n</code></pre> <ul> <li>Initialize Molten in your startup script</li> </ul> <p>index.js</p> <pre><code>import Molten from '@leverege/molten'\nimport Theme from './Theme' // path to your exported theme\n\nfunction start() {\nconst theme = {\ntheme : Theme,\nappearanceProjectId : '&lt;your-Builder-appearance-id&gt;',\nuseActiveTheme : true // if true, Molten will pull theme data from Builder in real time, immediately reflecting design change. Set to false for production or to improve performance.\n}\n\nconst api = {\nhost : 'https://example-api.leverege.com', // your Leverege API host\nsystemId : '&lt;your-system-id&gt;', // system in your Leverege Project\nprojectId : '&lt;your-project-id&gt;', // your Leverege Project ID\nstoreToken : true\n}\n\nconst config = { theme, api }\n\nMolten.init( config )\n\nMolten.create()\n}\n\nwindow.Application = { start }\n</code></pre> <ul> <li>Configure your html to start the application</li> </ul> <p>index.html</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html&gt;\n&lt;head&gt;\n  &lt;meta charset=\"utf-8\"&gt;\n  &lt;title&gt;My Leverege Project With Molten&lt;/title&gt;\n  &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1, minimum-scale=1\" /&gt;\n  &lt;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\"/&gt;\n&lt;/head&gt;\n\n&lt;body&gt;\n  &lt;div id=\"root\" style=\"z-index:0\"&gt;\n    &lt;script src=\"/index.js\"&gt;&lt;/script&gt;\n    &lt;script&gt; Application.start( ) &lt;/script&gt;\n  &lt;/div&gt;\n&lt;/body&gt;\n&lt;/html&gt;\n</code></pre> <ul> <li>Start your application: <code>npm start</code></li> </ul>"},{"location":"getting-started/#using-molten-without-levereges-iot-stack","title":"Using Molten without Leverege's IoT Stack","text":"<p>You do not need to use Leverege's IoT Stack to benefit from using Molten. Its plugin framework can make any codebase simpler and more extensible.</p> <p>Because the default plugins are designed for working with the Leverege Stack, we just need to take some extra steps to exclude those plugins.</p> <ul> <li>Install Molten: <code>npm i @leverege/molten</code></li> <li>Initialize Molten in your startup script</li> </ul> <pre><code>import Molten from '@leverege/molten'\nimport Theme from './Theme' // path to your exported theme\nimport MyCustomScreen from './MyCustomScreen' // Path to the component you want to display on load\n\nfunction start() {\n// Molten renders the authScreenClass component on startup. By default, it's a login to a Leverege project, but you can replace it with whatever want in your config.\nconst authScreenClass = MyCustomScreen\n\n// The excludes array in your config lists all the plugin IDs of any registered plugins (including default plugins) you want to exclude. Here we are taking out plugins related to authenticating to Leverege's API and theme engine.\nconst excludes = [\n'molten.ApiInit',\n'molten.ThemeInit',\n'molten.ApiLogin',\n'molten.ApiUserSettings',\n'molten.AuthInit',\n]\n\nconst config = {\nmolten : { authScreenClass },\nplugins : { excludes }\n}\n\nMolten.init( config )\n\nMolten.create()\n}\n\nwindow.Application = { start }\n</code></pre> <ul> <li>Start the web server: <code>npm start</code></li> </ul> <p>These steps will get a Molten enabled system running displaying only your custom code. To take advantage of Molten's plugin framework, you will need to add plugin points (and probably some plugins) to your code.</p> <p>See the plugins concepts page for a high level overview of plugins.</p>"},{"location":"getting-started/i18n/","title":"Localization","text":"<p>i18n.md</p>"},{"location":"getting-started/i18n/#installing-bundler","title":"Installing Bundler","text":""},{"location":"getting-started/i18n/#checking-for-translations","title":"Checking for translations","text":""},{"location":"plugins/","title":"Plugins","text":"<p>These plugins are automatically installed with Molten.</p>"}]}