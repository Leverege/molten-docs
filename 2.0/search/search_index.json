{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"api/","text":"API \u00b6 Api Referenece","title":"API"},{"location":"api/#api","text":"Api Referenece","title":"API"},{"location":"concepts/","text":"Concepts \u00b6","title":"Concepts"},{"location":"concepts/#concepts","text":"","title":"Concepts"},{"location":"concepts/actions/","text":"Actions \u00b6","title":"Actions"},{"location":"concepts/actions/#actions","text":"","title":"Actions"},{"location":"concepts/attributes/","text":"Attributes \u00b6 Molten make use of a mechanism call attributes for much of its data access. An Attribute is used to access a named piece of data about an object. This piece of data may represent a unique property on the data being accesssed, or it might represent a shared idea that can be applied to many types of objects, such as a human readable name or geographic position. These Attributes are used in a variety of places in molten to facilitate different needs. For example, when presenting data columns in a table or information to see in a detail card, the user will pick which Attributes to use. When rendering to a geographic map, the geodetic position attribute can be used to place the object. When building a logical condition to do dynamic data styling or alerting, the Attributes can be selected to perform the conditional if/then logic. The Attribute is acting as a delegate between the attribute name and a particular type of object. It provides a common interface to get data and in some cases, set data. Where pieces of information represent a well known and shared concept, a well known attribute name is used. Where the data represents very specific information, a unique attribute name can be used. To demonstrate this concept, here are some example attribute names: Attribute Name What is it name The user displayable name of the object. This is a shared Attribute that can be used in a generic information display or readout that tells the user what it is. Usually, every object type can have one of these, even if it just returns the objects unique id. icon Returns an image url ro font icon class name used to represent the object geoPosition This represents the latitude/longitude of an object. This could be used to map any geo spatial point object on a map, or perform a containment check against it for alert purposes. boat.bilge.status A example of a unique attribute about a boat's bilge status. When an attribute is unique to a type of object, its name should be prefixed with the object type, boat in this case. myType.myAttribute A example of a unique attribute. The Attribute acts as a normalization mechanism between the name of the attribute and the type of an attribute. For example, an object of type car may store its geographic position in a lat and lon field, while an object of type boat may store it in a geoPosition : { latitude, longitude } subfield. The attribute for the car knows to access the lat and lon field and assemble the appropriate geoPosition object. The boat, likewise, would know to use the geoPosition field. The attribute when registered, supplies the attibrute name and type of object it works against, as well as the method to retreive the data. This allows the car and boat attribute to extract the data appropriately based on the objects data type and return the correct format of the data. The fields of an Attribute are: Field Type Description name string Defines the name of the attribute objectType string The string name of the type of object the attribute can get/set data on. valueType string The type of object the returned from get(). The valueType must be the same for all attributes with the same name. displayName string The human display name of the attribute get function A function( object, context ) that returns the value of the attribute for the given object. If Attributes.get() is invoked with the objRef, the data portion of the obejctRef will be given to this function unless the Attribute sets usesObjRef to true . usesObjRef boolean Defaults to false. If this is true, the objRef will be given to the get() method canSet function Optional. A function( objRef, value, context ) the should return true or false, indicating where or not the set function is available set function Optional. A function( object, value, context ) invoked to perform the set Attributes Library The @leverege/ui-attributes library contains all of the base mechanics to make this work. Value Types \u00b6 There are many default valueTypes supplied. You can make your own as well. You will need to add other plugins to support other mechanism such as Details and Tables. Here is a list of the predefined valueTypes: Value Type Return string string number number timestamp Date boolean boolean int number icon string of a url or a font icon class name percent number length UnitType speed UnitType acceleration UnitType surface UnitType volume UnitType mass UnitType time UnitType frequency UnitType angle UnitType current UnitType temperature UnitType substanceAmount UnitType luminousIntensity UnitType force UnitType energy UnitType power UnitType pressure UnitType electricCharge UnitType electricCapacitance UnitType electricPotential UnitType electricResistance UnitType electricInductance UnitType electricConductance UnitType magneticFlux UnitType magneticFluxDensity UnitType bit UnitType flow UnitType geoPoint Object containing { lat, lon } where lat and lon are in degrees geoJson string containing the geoJson data relationship string (Imagine attribute type) parentRelationship string id (Imagine attribute type) enum string (Imagine attribute type) UnitType is an object that contains { type : , value, unit }.","title":"Attributes"},{"location":"concepts/attributes/#attributes","text":"Molten make use of a mechanism call attributes for much of its data access. An Attribute is used to access a named piece of data about an object. This piece of data may represent a unique property on the data being accesssed, or it might represent a shared idea that can be applied to many types of objects, such as a human readable name or geographic position. These Attributes are used in a variety of places in molten to facilitate different needs. For example, when presenting data columns in a table or information to see in a detail card, the user will pick which Attributes to use. When rendering to a geographic map, the geodetic position attribute can be used to place the object. When building a logical condition to do dynamic data styling or alerting, the Attributes can be selected to perform the conditional if/then logic. The Attribute is acting as a delegate between the attribute name and a particular type of object. It provides a common interface to get data and in some cases, set data. Where pieces of information represent a well known and shared concept, a well known attribute name is used. Where the data represents very specific information, a unique attribute name can be used. To demonstrate this concept, here are some example attribute names: Attribute Name What is it name The user displayable name of the object. This is a shared Attribute that can be used in a generic information display or readout that tells the user what it is. Usually, every object type can have one of these, even if it just returns the objects unique id. icon Returns an image url ro font icon class name used to represent the object geoPosition This represents the latitude/longitude of an object. This could be used to map any geo spatial point object on a map, or perform a containment check against it for alert purposes. boat.bilge.status A example of a unique attribute about a boat's bilge status. When an attribute is unique to a type of object, its name should be prefixed with the object type, boat in this case. myType.myAttribute A example of a unique attribute. The Attribute acts as a normalization mechanism between the name of the attribute and the type of an attribute. For example, an object of type car may store its geographic position in a lat and lon field, while an object of type boat may store it in a geoPosition : { latitude, longitude } subfield. The attribute for the car knows to access the lat and lon field and assemble the appropriate geoPosition object. The boat, likewise, would know to use the geoPosition field. The attribute when registered, supplies the attibrute name and type of object it works against, as well as the method to retreive the data. This allows the car and boat attribute to extract the data appropriately based on the objects data type and return the correct format of the data. The fields of an Attribute are: Field Type Description name string Defines the name of the attribute objectType string The string name of the type of object the attribute can get/set data on. valueType string The type of object the returned from get(). The valueType must be the same for all attributes with the same name. displayName string The human display name of the attribute get function A function( object, context ) that returns the value of the attribute for the given object. If Attributes.get() is invoked with the objRef, the data portion of the obejctRef will be given to this function unless the Attribute sets usesObjRef to true . usesObjRef boolean Defaults to false. If this is true, the objRef will be given to the get() method canSet function Optional. A function( objRef, value, context ) the should return true or false, indicating where or not the set function is available set function Optional. A function( object, value, context ) invoked to perform the set Attributes Library The @leverege/ui-attributes library contains all of the base mechanics to make this work.","title":"Attributes"},{"location":"concepts/attributes/#value-types","text":"There are many default valueTypes supplied. You can make your own as well. You will need to add other plugins to support other mechanism such as Details and Tables. Here is a list of the predefined valueTypes: Value Type Return string string number number timestamp Date boolean boolean int number icon string of a url or a font icon class name percent number length UnitType speed UnitType acceleration UnitType surface UnitType volume UnitType mass UnitType time UnitType frequency UnitType angle UnitType current UnitType temperature UnitType substanceAmount UnitType luminousIntensity UnitType force UnitType energy UnitType power UnitType pressure UnitType electricCharge UnitType electricCapacitance UnitType electricPotential UnitType electricResistance UnitType electricInductance UnitType electricConductance UnitType magneticFlux UnitType magneticFluxDensity UnitType bit UnitType flow UnitType geoPoint Object containing { lat, lon } where lat and lon are in degrees geoJson string containing the geoJson data relationship string (Imagine attribute type) parentRelationship string id (Imagine attribute type) enum string (Imagine attribute type) UnitType is an object that contains { type : , value, unit }.","title":"Value Types"},{"location":"concepts/attributes/data-sources/","text":"Data Sources \u00b6 DataSources act as a bridge between the data objects and their source. The data object themselves are represented by an Object Reference, or objRef . The objRef has DataSources are used to acquire data from a given service. This could be a remote server or a local data source as well. It is used in conjunction with the ObjRef , Attributes and Relationships to supply access to the given","title":"Data Sources"},{"location":"concepts/attributes/data-sources/#data-sources","text":"DataSources act as a bridge between the data objects and their source. The data object themselves are represented by an Object Reference, or objRef . The objRef has DataSources are used to acquire data from a given service. This could be a remote server or a local data source as well. It is used in conjunction with the ObjRef , Attributes and Relationships to supply access to the given","title":"Data Sources"},{"location":"concepts/attributes/details/","text":"Data Sources \u00b6","title":"Data Sources"},{"location":"concepts/attributes/details/#data-sources","text":"","title":"Data Sources"},{"location":"concepts/attributes/formatters/","text":"Formatters \u00b6","title":"Formatters"},{"location":"concepts/attributes/formatters/#formatters","text":"","title":"Formatters"},{"location":"concepts/attributes/graph/","text":"Graphing \u00b6","title":"Graphing"},{"location":"concepts/attributes/graph/#graphing","text":"","title":"Graphing"},{"location":"concepts/attributes/relationships/","text":"Relationships \u00b6","title":"Relationships"},{"location":"concepts/attributes/relationships/#relationships","text":"","title":"Relationships"},{"location":"concepts/attributes/table/","text":"Data Sources \u00b6","title":"Data Sources"},{"location":"concepts/attributes/table/#data-sources","text":"","title":"Data Sources"},{"location":"concepts/models/","text":"Models \u00b6 Molten uses the concept of a Model in much of its architecture. It is a way of transfering settings and workflows, and defining behaviors in plain JSON. Characteristics \u00b6 A model has several characteristics that should be enforced while using them. Following these characteristics make it easy to save them, restore them, edit them, and find handlers/executors for them. Plain JSON Object \u00b6 Models should be a simple javascript object. They should not be or contain classes, functions, or Dates anywhere in their structure. This allows them to be easy stored to a network server, or added to a Redux like mechanism. Immutable \u00b6 Models should be considered immutable. Changing a field redirectly in a Model will break caches, Redux and UI's that rely on top level object differences. Typed \u00b6 Models should have a type field that defines its unique identity. Normally this is a namespaced string such as myProject.MyModel Working with Models \u00b6 There tends to be a lot of broilerplate code when it comes to mutating models. To support this, the @leverege/model-util library is available for use. For example, when changing a value and following the immutablitly rule above, it would look like: import MyModel from './MyModel' // If model was defined as model = { type : 'myMode' , value : 5 , subValues : { sv : 1 } } // WRONG - Dont do this model . value = 42 // CORRECT - Do this const nModel = MyModel . setValue ( model , 42 ) model === nModel // => false model . subValues === nModel . subValues // => true The @leverege/model-util will support creating getters and setters for single values in the model, for child arrays of items, and for child maps of other values. By leveraging the ModelUtil class these can be created very easily. Once created, these Model should be registered with Plugins by invoking Plugins.add( 'Model', MyModel ) . Because Models have types, they are easily used with the Plugin's Factory mechanism. Setting up a mechanism that should change behaviors based on the type of model installed is just another plugin point. Mechanisms like if/then/else logic options, color or symbol selectors, filtering or exporting of data become new plugin point Factories with the Plugins bound against the Model type. If you need to allow the user to edit a model, going to the ModelEditorFactory to find a React component works great. Using the immutablily principle, the Model object and UI Element's eventData mechanism, change a model via a UI Element and sending the new model value to a change listener is very easy. At the controller level of the UI, the model could be stored into a Components state, or shoved into Redux, or sent across a network.","title":"Models"},{"location":"concepts/models/#models","text":"Molten uses the concept of a Model in much of its architecture. It is a way of transfering settings and workflows, and defining behaviors in plain JSON.","title":"Models"},{"location":"concepts/models/#characteristics","text":"A model has several characteristics that should be enforced while using them. Following these characteristics make it easy to save them, restore them, edit them, and find handlers/executors for them.","title":"Characteristics"},{"location":"concepts/models/#plain-json-object","text":"Models should be a simple javascript object. They should not be or contain classes, functions, or Dates anywhere in their structure. This allows them to be easy stored to a network server, or added to a Redux like mechanism.","title":"Plain JSON Object"},{"location":"concepts/models/#immutable","text":"Models should be considered immutable. Changing a field redirectly in a Model will break caches, Redux and UI's that rely on top level object differences.","title":"Immutable"},{"location":"concepts/models/#typed","text":"Models should have a type field that defines its unique identity. Normally this is a namespaced string such as myProject.MyModel","title":"Typed"},{"location":"concepts/models/#working-with-models","text":"There tends to be a lot of broilerplate code when it comes to mutating models. To support this, the @leverege/model-util library is available for use. For example, when changing a value and following the immutablitly rule above, it would look like: import MyModel from './MyModel' // If model was defined as model = { type : 'myMode' , value : 5 , subValues : { sv : 1 } } // WRONG - Dont do this model . value = 42 // CORRECT - Do this const nModel = MyModel . setValue ( model , 42 ) model === nModel // => false model . subValues === nModel . subValues // => true The @leverege/model-util will support creating getters and setters for single values in the model, for child arrays of items, and for child maps of other values. By leveraging the ModelUtil class these can be created very easily. Once created, these Model should be registered with Plugins by invoking Plugins.add( 'Model', MyModel ) . Because Models have types, they are easily used with the Plugin's Factory mechanism. Setting up a mechanism that should change behaviors based on the type of model installed is just another plugin point. Mechanisms like if/then/else logic options, color or symbol selectors, filtering or exporting of data become new plugin point Factories with the Plugins bound against the Model type. If you need to allow the user to edit a model, going to the ModelEditorFactory to find a React component works great. Using the immutablily principle, the Model object and UI Element's eventData mechanism, change a model via a UI Element and sending the new model value to a change listener is very easy. At the controller level of the UI, the model could be stored into a Components state, or shoved into Redux, or sent across a network.","title":"Working with Models"},{"location":"concepts/models/editors/","text":"Model Editors \u00b6 ModelEditorFactory \u00b6 import { ModelEditorFactory } from '@leverege/ui-plugin' The ModelEditorFactory is a great way to dynamically edit objects when you don't want to care what they are. Consider the following code: PluginSetup.js MyModel.js MyModelEditor.jsx SettingsEditor.jsx Setting.js import MyModel from './MyModel' import MyModelEditor from './MyModelEditor' export default { install : ( molten ) => { molten . addPlugin ( 'Model' , { type : MyModel . TYPE , model : MyModel } ) } } import { createAllValue } from '@leverege/model-util' const type = 'my.model' function create ( existing ) { return { type , age : existing ? . age , } } export { type , TYPE : type , create , ... createAllValue ( 'age' , 'Age' ) } import React from 'react' import { PropertyGrid , NumericInput } from '@leverege/ui-elements' import MyModel from './MyModel' export default function MyModelEditor ( props ) { const { value } = props const onModelChange = useValueChange ( MyModel , props ) return ( < PropertyGrid > < PropertyGrid . Item label = \"Age\" > < NumericInput value = { MyModel . getAge ( value )} hint = \"Age\" eventData = \"setAge\" onChange = { onModelChange } /> < /PropertyGrid.Item> < /PropertyGrid> ) } import React from 'react' import { ModelEditorFactory } from '@leverege/ui-plugin' export default function SettingsEditor ( props ) { const { settingValue } = props const onChange = () => { // make a network call to change the setting } return ModelEditorFactory . create ( settingValue , { value : settingValue , onChange } ) } const MyModel = './MyModel' export default MyModel . create ( { age : 32 } ) This allows you to create a SettingsEditor that doesn't care what the setting actually looks like. Assuming any possible setting model has a registered editor in the plugins library, that setting will be editable. This powerful paradigm is used throughout molten to edit ui settings, filter objects, re-parent Leverege devices, and so much more! To note some additional best practices in the code above, look specifically at the MyModelEditor file. Note that to render the field editors, we're using a combination of PropertyGrid from the Leverege ui-elements library and the useValueChange hook from the Leverege ui-hooks library. These are considered the general best practices for creating model editors, since they standardize how callbacks occur between compoonents, and the styles used when editing objects. Hook: useInstanceCallback \u00b6 The purpose of this hook is to generate callbacks that do not change when new props are supplied. This can prevent excess renders from occurring on subcomponents. It is useful for proxying changes to parent components The hook can be invoked with either a function, or an array of functions, and the variables that should be available to the currently returned callbacks (normally props). Each function supplied will be given the variables and the arguments that where given to the callback. // Static function that takes ( variables, ...args ) function click ( props , evt ) { // send the click somewhere, with maybe some extra stuff props . sendClick ( props . model , evt ) } // React function. The click method above will be invoked with props and the event function myEditor ( props ) { const [ onClick ] = useInstanceCallback ( [ click ], props ) return < button onClick = { onClick } > Do Something < /button> } Hook: useModelChange \u00b6 This hook is meant to be used with the model-util (or equivalent) library and ui-element events. It makes use of the useInstanceCallback hook to invoke a method on a given mutator function and forward the result to the onChange callback. The method invoked is supplied in the event's data field. For example, if you have a Model Class: const ModelUtil = require ( '@leverege/model-util' ) const { useModelChange } = require ( '@leverege/ui-hooks' ) const TYPE = 'armedModel' module . exports = { TYPE , create : ( ) => { return { type : TYPE , armed : true } }, ... ModelUtil . createAllValue ( 'armed' , 'Armed' ) } In your React function, you can use this hook like this: function myEditor ( props ) { const { model } = props const [ onChange ] = useModelChange ( ArmedModel , props ) return < ToggleButton onChange = { onChange } value = { ArmedModel . getArmed ( model )} eventData = \"setArmed\" > Armed < /ToggleButtton> } When the ui-element ToggelButton is clicked, ArmedModel.setArmed( model, event.value ) will be invoked. The result (newModel) from that call will be sent to props.onChange( { value : newModel, data : props.eventData }) . Hook: useValueChange \u00b6 useValueChange is very similar to the useModelChange hook, with the principal difference being that it expects the model value to be in the value prop rather than the model prop. Function: onModelChange \u00b6 The useModelChange hook uses the onModelChange method to do most of the work. It can be used in a class to avoid some code. The createModelChange method is supplied as a convenient class method to do this. class MyElem extends React . Component { onChange = createModelChange ( ArmedModel ) render ( ) { return < ToggleButton onChange = { onChange } value = { ArmedModel . getArmed ( model )} eventData = \"setArmed\" > Armed < /ToggleButtton> } }","title":"Editors"},{"location":"concepts/models/editors/#model-editors","text":"","title":"Model Editors"},{"location":"concepts/models/editors/#modeleditorfactory","text":"import { ModelEditorFactory } from '@leverege/ui-plugin' The ModelEditorFactory is a great way to dynamically edit objects when you don't want to care what they are. Consider the following code: PluginSetup.js MyModel.js MyModelEditor.jsx SettingsEditor.jsx Setting.js import MyModel from './MyModel' import MyModelEditor from './MyModelEditor' export default { install : ( molten ) => { molten . addPlugin ( 'Model' , { type : MyModel . TYPE , model : MyModel } ) } } import { createAllValue } from '@leverege/model-util' const type = 'my.model' function create ( existing ) { return { type , age : existing ? . age , } } export { type , TYPE : type , create , ... createAllValue ( 'age' , 'Age' ) } import React from 'react' import { PropertyGrid , NumericInput } from '@leverege/ui-elements' import MyModel from './MyModel' export default function MyModelEditor ( props ) { const { value } = props const onModelChange = useValueChange ( MyModel , props ) return ( < PropertyGrid > < PropertyGrid . Item label = \"Age\" > < NumericInput value = { MyModel . getAge ( value )} hint = \"Age\" eventData = \"setAge\" onChange = { onModelChange } /> < /PropertyGrid.Item> < /PropertyGrid> ) } import React from 'react' import { ModelEditorFactory } from '@leverege/ui-plugin' export default function SettingsEditor ( props ) { const { settingValue } = props const onChange = () => { // make a network call to change the setting } return ModelEditorFactory . create ( settingValue , { value : settingValue , onChange } ) } const MyModel = './MyModel' export default MyModel . create ( { age : 32 } ) This allows you to create a SettingsEditor that doesn't care what the setting actually looks like. Assuming any possible setting model has a registered editor in the plugins library, that setting will be editable. This powerful paradigm is used throughout molten to edit ui settings, filter objects, re-parent Leverege devices, and so much more! To note some additional best practices in the code above, look specifically at the MyModelEditor file. Note that to render the field editors, we're using a combination of PropertyGrid from the Leverege ui-elements library and the useValueChange hook from the Leverege ui-hooks library. These are considered the general best practices for creating model editors, since they standardize how callbacks occur between compoonents, and the styles used when editing objects.","title":"ModelEditorFactory"},{"location":"concepts/models/editors/#hook-useinstancecallback","text":"The purpose of this hook is to generate callbacks that do not change when new props are supplied. This can prevent excess renders from occurring on subcomponents. It is useful for proxying changes to parent components The hook can be invoked with either a function, or an array of functions, and the variables that should be available to the currently returned callbacks (normally props). Each function supplied will be given the variables and the arguments that where given to the callback. // Static function that takes ( variables, ...args ) function click ( props , evt ) { // send the click somewhere, with maybe some extra stuff props . sendClick ( props . model , evt ) } // React function. The click method above will be invoked with props and the event function myEditor ( props ) { const [ onClick ] = useInstanceCallback ( [ click ], props ) return < button onClick = { onClick } > Do Something < /button> }","title":"Hook: useInstanceCallback"},{"location":"concepts/models/editors/#hook-usemodelchange","text":"This hook is meant to be used with the model-util (or equivalent) library and ui-element events. It makes use of the useInstanceCallback hook to invoke a method on a given mutator function and forward the result to the onChange callback. The method invoked is supplied in the event's data field. For example, if you have a Model Class: const ModelUtil = require ( '@leverege/model-util' ) const { useModelChange } = require ( '@leverege/ui-hooks' ) const TYPE = 'armedModel' module . exports = { TYPE , create : ( ) => { return { type : TYPE , armed : true } }, ... ModelUtil . createAllValue ( 'armed' , 'Armed' ) } In your React function, you can use this hook like this: function myEditor ( props ) { const { model } = props const [ onChange ] = useModelChange ( ArmedModel , props ) return < ToggleButton onChange = { onChange } value = { ArmedModel . getArmed ( model )} eventData = \"setArmed\" > Armed < /ToggleButtton> } When the ui-element ToggelButton is clicked, ArmedModel.setArmed( model, event.value ) will be invoked. The result (newModel) from that call will be sent to props.onChange( { value : newModel, data : props.eventData }) .","title":"Hook: useModelChange"},{"location":"concepts/models/editors/#hook-usevaluechange","text":"useValueChange is very similar to the useModelChange hook, with the principal difference being that it expects the model value to be in the value prop rather than the model prop.","title":"Hook: useValueChange"},{"location":"concepts/models/editors/#function-onmodelchange","text":"The useModelChange hook uses the onModelChange method to do most of the work. It can be used in a class to avoid some code. The createModelChange method is supplied as a convenient class method to do this. class MyElem extends React . Component { onChange = createModelChange ( ArmedModel ) render ( ) { return < ToggleButton onChange = { onChange } value = { ArmedModel . getArmed ( model )} eventData = \"setArmed\" > Armed < /ToggleButtton> } }","title":"Function: onModelChange"},{"location":"concepts/models/model-util/","text":"Model Util \u00b6 The Leverege model util library @leverege/model-util is a helpful tool for creating and managing immutable models. Example \u00b6 Let's say you have an instance of a pet model that looks like this: let fluffy = { type : 'pet' , name : 'Fluffy' , species : 'cat' , color : 'white' , // fluffy might be immortal birthDate : '1973-01-08T00:00:00.000Z' } And you need to be able to update the species , color , and birthDate of Fluffy because given their apparent immortality you're no longer convinced they're a cat. You have a couple of options do so immutably. The naive (and wrong) way to do it is as follows: fluffy = { ... fluffy , species : 'shapeshifter' , color : 'cream' , birthDate : '0000-01-01T00:00:00.000Z' } Danger Don't modify models like this, its not reproducible across the code base and is prone to errors The better way to modify a model is like so: PetModel.js EditFluffy.js const { createAllValue , createAllArray , createAllMap } = require ( '@leverege/model-util' ) module . exports = { ... createAllValue ( 'name' , 'Name' ), ... createAllValue ( 'species' , 'Species' ), ... createAllValue ( 'color' , 'Color' ), ... createAllValue ( 'birthDate' , 'BirthDate' ), } const PetModel = require ( './PetModel' ) let fluffy = { type : 'pet' , name : 'Fluffy' , species : 'cat' , color : 'white' , // fluffy might be immortal birthDate : '1973-01-08T00:00:00.000Z' } fluffy = PetModel . setSpecies ( fluffy , 'shapeshifter' ) fluffy = PetModel . setColor ( fluffy , 'cream' ) fluffy = PetModel . setBirthDate ( fluffy , '0000-01-01T00:00:00.000Z' ) createAllValue( key, name, setOpts, getOpts ) \u00b6 createAllValue will return an object like the following { `set ${ name } ` ( model , newVal ) { ... }, `get ${ name } ` ( model ) { ... } } This can be used to get and set a value at a known key in a model createAllArray( key, name, namePlural ) \u00b6 discussion about normalization of this into { // adds an item into the array at a given index `add ${ name } ` ( model , item , insertAt ) { ... }, // remove an item (without knowing the index in the array) `remove ${ name } ` ( model , item ) { ... }, // remove an item at a given index `remove ${ name } At` ( model , index ) { ... }, // set a given index to a new value `set ${ name } ` ( model , index , value ) { ... }, // swap two items in the array `swap ${ namePlural } ` ( model , index1 , index2 ) { ... }, // move an item to a new index `move ${ name } ` ( model , from , to ) { ... }, // empty the array `clear ${ namePlural } ` ( model ) { ... }, // set the whole array `set ${ namePlural } ` ( model , value ) { ... }, // get an item at a known index `get ${ name } ` ( model , index ) { ... }, // get the whole array `get ${ namePlural } ` ( model ) { ... }, // get the index of a given item in the array (-1 if its not in the array) `indexOf ${ name } ` ( model , item ) { ... }, } createAllMap( key, name, namePlural) \u00b6 discussion about normalization of this into { // set a known key to a new value `set ${ name } ` ( model , itemKey , item ) { ... }, // get the value at a known key `get ${ name } ` ( model , itemKey ) { ... }, // check if the map has a value at a known key `contains ${ name } ` ( model , itemKey ) { ... }, // remove the value at a known key `remove ${ name } ` ( model , itemKey ) { ... }, // set the whole map to a new object `set ${ namePlural } ` ( model , object ) { ... }, // get the whole map `get ${ namePlural } ` ( model ) { ... }, // get all the entries in the map `get ${ name } Entries` ( model ) {... }, // remove all keys from the map `clear ${ namePlural } ` ( model ) { ... }, }","title":"Model Util"},{"location":"concepts/models/model-util/#model-util","text":"The Leverege model util library @leverege/model-util is a helpful tool for creating and managing immutable models.","title":"Model Util"},{"location":"concepts/models/model-util/#example","text":"Let's say you have an instance of a pet model that looks like this: let fluffy = { type : 'pet' , name : 'Fluffy' , species : 'cat' , color : 'white' , // fluffy might be immortal birthDate : '1973-01-08T00:00:00.000Z' } And you need to be able to update the species , color , and birthDate of Fluffy because given their apparent immortality you're no longer convinced they're a cat. You have a couple of options do so immutably. The naive (and wrong) way to do it is as follows: fluffy = { ... fluffy , species : 'shapeshifter' , color : 'cream' , birthDate : '0000-01-01T00:00:00.000Z' } Danger Don't modify models like this, its not reproducible across the code base and is prone to errors The better way to modify a model is like so: PetModel.js EditFluffy.js const { createAllValue , createAllArray , createAllMap } = require ( '@leverege/model-util' ) module . exports = { ... createAllValue ( 'name' , 'Name' ), ... createAllValue ( 'species' , 'Species' ), ... createAllValue ( 'color' , 'Color' ), ... createAllValue ( 'birthDate' , 'BirthDate' ), } const PetModel = require ( './PetModel' ) let fluffy = { type : 'pet' , name : 'Fluffy' , species : 'cat' , color : 'white' , // fluffy might be immortal birthDate : '1973-01-08T00:00:00.000Z' } fluffy = PetModel . setSpecies ( fluffy , 'shapeshifter' ) fluffy = PetModel . setColor ( fluffy , 'cream' ) fluffy = PetModel . setBirthDate ( fluffy , '0000-01-01T00:00:00.000Z' )","title":"Example"},{"location":"concepts/models/model-util/#createallvalue-key-name-setopts-getopts","text":"createAllValue will return an object like the following { `set ${ name } ` ( model , newVal ) { ... }, `get ${ name } ` ( model ) { ... } } This can be used to get and set a value at a known key in a model","title":"createAllValue( key, name, setOpts, getOpts )"},{"location":"concepts/models/model-util/#createallarray-key-name-nameplural","text":"discussion about normalization of this into { // adds an item into the array at a given index `add ${ name } ` ( model , item , insertAt ) { ... }, // remove an item (without knowing the index in the array) `remove ${ name } ` ( model , item ) { ... }, // remove an item at a given index `remove ${ name } At` ( model , index ) { ... }, // set a given index to a new value `set ${ name } ` ( model , index , value ) { ... }, // swap two items in the array `swap ${ namePlural } ` ( model , index1 , index2 ) { ... }, // move an item to a new index `move ${ name } ` ( model , from , to ) { ... }, // empty the array `clear ${ namePlural } ` ( model ) { ... }, // set the whole array `set ${ namePlural } ` ( model , value ) { ... }, // get an item at a known index `get ${ name } ` ( model , index ) { ... }, // get the whole array `get ${ namePlural } ` ( model ) { ... }, // get the index of a given item in the array (-1 if its not in the array) `indexOf ${ name } ` ( model , item ) { ... }, }","title":"createAllArray( key, name, namePlural )"},{"location":"concepts/models/model-util/#createallmap-key-name-nameplural","text":"discussion about normalization of this into { // set a known key to a new value `set ${ name } ` ( model , itemKey , item ) { ... }, // get the value at a known key `get ${ name } ` ( model , itemKey ) { ... }, // check if the map has a value at a known key `contains ${ name } ` ( model , itemKey ) { ... }, // remove the value at a known key `remove ${ name } ` ( model , itemKey ) { ... }, // set the whole map to a new object `set ${ namePlural } ` ( model , object ) { ... }, // get the whole map `get ${ namePlural } ` ( model ) { ... }, // get all the entries in the map `get ${ name } Entries` ( model ) {... }, // remove all keys from the map `clear ${ namePlural } ` ( model ) { ... }, }","title":"createAllMap( key, name, namePlural)"},{"location":"concepts/plugins/","text":"Plugins \u00b6 Molten makes heavy use of the @leverege/plugins library. This library supplies a central registration mechanism in which various classes, functions, and objects can be declared to participate in other framework's interfaces. Often this binding can occur without the need for a direct dependency on target framework. The uses for this 'repository of things' can very greatly: from dynamic url routing, to custom contextual actions, to attribute definition, to logic intercept mechanisms, to initializers, to UI editor lookups, to colorizers, to name just a few. Use \u00b6 The use of this library can be very simple and the requirements are very few: Including the library in your own code Defining an interface for your custom plugin mechanism (sometimes called Plugin Points) Picking a unique plugin name for your mechanism (usually namespaced, like . ) import { Plugins } from '@leverege/plugin' // 1 const plgs = Plugins . get ( 'myProject.Initializer' ) // 2 plgs . forEach ( ( initializer ) => { initializer . init () // 3 } ) In this example, we have defined our own custom plugin point that will invoke an init method at the appropriate time. It has imported the library (1), asked for all plugins registered as a myProject.Initializer plugin (2), and used the custom plugin point's interface to invoke init() on each plugin (3). It can be that simple to define your own custom Plugins point. To participate in that example plugin point, simply add a plugin to the Plugin mechanism: import { Plugins } from '@leverege/plugin' // 1 MyInitializer = { init : () => { /* do something */ } } // Alternately: molten.addPlugin( 'myProject.Initializer', MyInitializer ) Plugins . add ( 'myProject.Initializer' , MyInitializer ) This Plugins.add() or molten.addPlugin() registers the plugin for use at the specified plugins point. Adding a plugin can be as simple as this. Some plugin points are a little more complicated. These plugin points will often use match objects , type values, and methods to help determine whether or not a particular plugin should be used in a particular instance. Some will define sort values to help aid in ordered invokation. Some are meant to be used in Factory lookup mechanism or participate in active Views . These extra mechanisms need to be defined by the plugin points interface documentation so developers can understand how to leverage the particular plugin point. Observable \u00b6 The Plugins mechanism is also observable, meaning that listeners can be registered to detect when plugins are added or removed. This can help plugin endpoints respond to new plugins or avoid ordering issues cause by importation/registration order. It can also help to support dynamic loading of code. // Add a listener to all types const unsubscribeGlobal = Plugins . on ( listener ) // Add a listener to a specific type const unsubscribeType = Plugins . on ( 'myProject.Initializer' , listener ) // To remove a listener from all types Plugins . off ( listener ) // or use the returned function unsubscribeGlobal () // To remove a listener from a specific type Plugins . off ( 'myProject.Initializer' , listener ) // or use the returned function unsubscribeType () The listener method will be invoked with an object when an add or remove occurs: { type , // either 'pluginAdded' or 'pluginRemoved', pluginType , // The plugin type that changed plugin , // The plugin that was added or removed plugins // The Plugins object } An alternative why of determining if Plugins were added or removed without listening to Plugins is to look at the version number for a type. const version = Plugins . getVersion ( 'myProject.Initializer' ) Anytime a plugin is added or removed, the version number will be updated. This change detection is useful when caches are being used to record previous work using the plugins. A change to the version can be used to bust the cache and cause the work to be recalculated with the current plugin set. const version = Plugins . getVersion ( 'myProject.PluginPoint' ) // React Example const result = useMemo ( ( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, [ version ] ) // @leverege/value-cache example const result = valueCache . calc (( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, version )","title":"Plugins"},{"location":"concepts/plugins/#plugins","text":"Molten makes heavy use of the @leverege/plugins library. This library supplies a central registration mechanism in which various classes, functions, and objects can be declared to participate in other framework's interfaces. Often this binding can occur without the need for a direct dependency on target framework. The uses for this 'repository of things' can very greatly: from dynamic url routing, to custom contextual actions, to attribute definition, to logic intercept mechanisms, to initializers, to UI editor lookups, to colorizers, to name just a few.","title":"Plugins"},{"location":"concepts/plugins/#use","text":"The use of this library can be very simple and the requirements are very few: Including the library in your own code Defining an interface for your custom plugin mechanism (sometimes called Plugin Points) Picking a unique plugin name for your mechanism (usually namespaced, like . ) import { Plugins } from '@leverege/plugin' // 1 const plgs = Plugins . get ( 'myProject.Initializer' ) // 2 plgs . forEach ( ( initializer ) => { initializer . init () // 3 } ) In this example, we have defined our own custom plugin point that will invoke an init method at the appropriate time. It has imported the library (1), asked for all plugins registered as a myProject.Initializer plugin (2), and used the custom plugin point's interface to invoke init() on each plugin (3). It can be that simple to define your own custom Plugins point. To participate in that example plugin point, simply add a plugin to the Plugin mechanism: import { Plugins } from '@leverege/plugin' // 1 MyInitializer = { init : () => { /* do something */ } } // Alternately: molten.addPlugin( 'myProject.Initializer', MyInitializer ) Plugins . add ( 'myProject.Initializer' , MyInitializer ) This Plugins.add() or molten.addPlugin() registers the plugin for use at the specified plugins point. Adding a plugin can be as simple as this. Some plugin points are a little more complicated. These plugin points will often use match objects , type values, and methods to help determine whether or not a particular plugin should be used in a particular instance. Some will define sort values to help aid in ordered invokation. Some are meant to be used in Factory lookup mechanism or participate in active Views . These extra mechanisms need to be defined by the plugin points interface documentation so developers can understand how to leverage the particular plugin point.","title":"Use"},{"location":"concepts/plugins/#observable","text":"The Plugins mechanism is also observable, meaning that listeners can be registered to detect when plugins are added or removed. This can help plugin endpoints respond to new plugins or avoid ordering issues cause by importation/registration order. It can also help to support dynamic loading of code. // Add a listener to all types const unsubscribeGlobal = Plugins . on ( listener ) // Add a listener to a specific type const unsubscribeType = Plugins . on ( 'myProject.Initializer' , listener ) // To remove a listener from all types Plugins . off ( listener ) // or use the returned function unsubscribeGlobal () // To remove a listener from a specific type Plugins . off ( 'myProject.Initializer' , listener ) // or use the returned function unsubscribeType () The listener method will be invoked with an object when an add or remove occurs: { type , // either 'pluginAdded' or 'pluginRemoved', pluginType , // The plugin type that changed plugin , // The plugin that was added or removed plugins // The Plugins object } An alternative why of determining if Plugins were added or removed without listening to Plugins is to look at the version number for a type. const version = Plugins . getVersion ( 'myProject.Initializer' ) Anytime a plugin is added or removed, the version number will be updated. This change detection is useful when caches are being used to record previous work using the plugins. A change to the version can be used to bust the cache and cause the work to be recalculated with the current plugin set. const version = Plugins . getVersion ( 'myProject.PluginPoint' ) // React Example const result = useMemo ( ( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, [ version ] ) // @leverege/value-cache example const result = valueCache . calc (( ) => { const p = Plugins . get ( 'myProject.PluginPoint' ) // do some work return result }, version )","title":"Observable"},{"location":"concepts/plugins/config/","text":"Configuration \u00b6 The Plugins mechanism supplies a way registering objects for use in different mechanisms. The Config mechanism supplies a single location where these plugins can supply configurable options without each interface having to make its own options mechanism. Getting Config Values \u00b6 To use the Config option in your plugin, invoke the get( rsource, key, defaultValue ) method: import { Config } from `@leverege/plugins` const opt1 = Config . get ( 'myProject.MyPlugin' , 'option1' , 12 ) In general, you should avoid get Config options at the time you javascript is loaded, but instead delay until when the option is needed. This will avoid any ordering issues between intialization and usage of the Config options. Setting Config Values \u00b6 To set the Config option, use set( rsource, key, value ) method: import { Config } from `@leverege/plugins` Config . set ( 'myProject.MyPlugin' , 'option1' , 42 ) On Molten startup, the LoadConfig plugin will take all options stored in Molten's config object at the path 'plugins/config' and set them on the Plugin's Config object.","title":"Config"},{"location":"concepts/plugins/config/#configuration","text":"The Plugins mechanism supplies a way registering objects for use in different mechanisms. The Config mechanism supplies a single location where these plugins can supply configurable options without each interface having to make its own options mechanism.","title":"Configuration"},{"location":"concepts/plugins/config/#getting-config-values","text":"To use the Config option in your plugin, invoke the get( rsource, key, defaultValue ) method: import { Config } from `@leverege/plugins` const opt1 = Config . get ( 'myProject.MyPlugin' , 'option1' , 12 ) In general, you should avoid get Config options at the time you javascript is loaded, but instead delay until when the option is needed. This will avoid any ordering issues between intialization and usage of the Config options.","title":"Getting Config Values"},{"location":"concepts/plugins/config/#setting-config-values","text":"To set the Config option, use set( rsource, key, value ) method: import { Config } from `@leverege/plugins` Config . set ( 'myProject.MyPlugin' , 'option1' , 42 ) On Molten startup, the LoadConfig plugin will take all options stored in Molten's config object at the path 'plugins/config' and set them on the Plugin's Config object.","title":"Setting Config Values"},{"location":"concepts/plugins/factories/","text":"Factories \u00b6 The Factory concept encapsulates the \"I have a object, give me a way to do X with it\". This 'way' can be represented by a Class, a function or object, and is defined by the plugin point making use of the factory. What the intent of this mechanism is ( the X ), is left up to the plugin point. Examples include but are in no way limited to: Finding a processor for an incoming message object Presenting a React editor or view for an object Exporting an XML node that represents the object Finding a formatting object to convert the object to a string Configuring a cache mechanism to use a different backend Finding and configuring a color calculator for objects In order to find or lookup the appropriate handling mechanism from the Factory, the object must have a type associated with it. By default, the factories look for the 'type' field on the object and use it to look up the mechanism registered in the factory. Tip If you are unhappy with a registered factory object (like an Editor for a Model), you can replace the install one with you own. It will be use in place of the original. Make sure your object implements all the requirements defined by the plugin point. Creation and Registration \u00b6 For a plugin point to use a Factory, it should use the createFactory( type, options, throwError = false ) method to obtain and/or create it. const factory = Plugins . createFactory ( 'myProject.MyLookupType' , { name : 'default' , pluginKey : 'processor' , strategy : Plugins . ALL } ) The first argument identifies the plugin point type that the Factory is using in its lookups, the second object is the options used to configure the factory: Option Field Default Description name default The name of the Factory. This is used to cache the factory so it can be returned from a repeated createFactory() or getFactory() call. pluginKey plugin The key in the registered plugin that defines the item the Factory will use. pluginKeyType type The type key name used by Factory.create() and Factory.get() when finding a factory item. strategy Plugins.ALL This determines how to treat the item found in create() before it is returned. See below for strategy descriptions. defaultObject null If no look up is found for a type, this object will be used registry null The default objects in the lookup To register a Plugins for use in the factory describe above: const myFactoryPlugin = { type : 'myObjectType' , processor : ( obj ) => { /* do something */ } } Plugins . add ( `myProject.MyLookupType` , myFactoryPlugin ) In this case, the type defines what kind of object this processor will be used for. Because the Factory options specified processor as the pluginKey , the actual object is registered using that key. If the factory is invoked like this const msg = { type : 'myObjectType' , /* more values */ } const result = factory . create ( msg ) the myFactoryPlugin.processor( msg ) will be invoked and its result returned. Because the stategy is ALL and the processor is a function, the function will be invoked will all parameters given to the create() . Different Strategy objects can be set on a Factory to allow different behaviors to occur. When create( obj, ...rest ) is invoked, the strategies will behave in the following ways: Strategy Result Plugins.ALL This is the default strategy. If the registered item is a function, it will be invoked with f( obj, ...rest ) and the result returned. If the registered item is a Class, new Clzz( obj, ...args ) will be returned. Plugins.NONE If the registered item is a function, it will be invoked with no options. If the registered item is a Class, new Clzz( ) will be returned. Plugins.ARGS If the registered item is a function, it will be invoked with f( ...rest ) and the result returned. If the registered item is a Class, new Clzz( ...args ) will be returned. Plugins.MERGE If the registered item is a function, it will be invoked with f( { model : msg, ...rest } ) and the result returned. If the registered item is a Class, new Clzz( { model : msg, ...args } ) will be returned. The Plugins.mergeStrategy() call can be used to create a merge strategy that will use a different key. Plugins.LOOKUP In this case, the registered object is simply returned Plugins.reactStrategy( React, propKey = 'model' ) This strategy will call React.createElement() with the registered item as the component function or class. The ...rest object will be supplied as props to the component. If propKey is a string, the obj object will be given as a prop as well, using the propKey as the prop name. function A custom function( factory, registeredItem, typeOrObject, props ) can be set as the strategy object as well. Dynamic Factories \u00b6 The Factory mechanism used in the plugin library is backed by @leverege/factory and augmented to include automatic registration and deregistration of plugins as they are added and removed. The factory mechanism can be used independently of Plugins as well - See @leverege/factory .","title":"Factories"},{"location":"concepts/plugins/factories/#factories","text":"The Factory concept encapsulates the \"I have a object, give me a way to do X with it\". This 'way' can be represented by a Class, a function or object, and is defined by the plugin point making use of the factory. What the intent of this mechanism is ( the X ), is left up to the plugin point. Examples include but are in no way limited to: Finding a processor for an incoming message object Presenting a React editor or view for an object Exporting an XML node that represents the object Finding a formatting object to convert the object to a string Configuring a cache mechanism to use a different backend Finding and configuring a color calculator for objects In order to find or lookup the appropriate handling mechanism from the Factory, the object must have a type associated with it. By default, the factories look for the 'type' field on the object and use it to look up the mechanism registered in the factory. Tip If you are unhappy with a registered factory object (like an Editor for a Model), you can replace the install one with you own. It will be use in place of the original. Make sure your object implements all the requirements defined by the plugin point.","title":"Factories"},{"location":"concepts/plugins/factories/#creation-and-registration","text":"For a plugin point to use a Factory, it should use the createFactory( type, options, throwError = false ) method to obtain and/or create it. const factory = Plugins . createFactory ( 'myProject.MyLookupType' , { name : 'default' , pluginKey : 'processor' , strategy : Plugins . ALL } ) The first argument identifies the plugin point type that the Factory is using in its lookups, the second object is the options used to configure the factory: Option Field Default Description name default The name of the Factory. This is used to cache the factory so it can be returned from a repeated createFactory() or getFactory() call. pluginKey plugin The key in the registered plugin that defines the item the Factory will use. pluginKeyType type The type key name used by Factory.create() and Factory.get() when finding a factory item. strategy Plugins.ALL This determines how to treat the item found in create() before it is returned. See below for strategy descriptions. defaultObject null If no look up is found for a type, this object will be used registry null The default objects in the lookup To register a Plugins for use in the factory describe above: const myFactoryPlugin = { type : 'myObjectType' , processor : ( obj ) => { /* do something */ } } Plugins . add ( `myProject.MyLookupType` , myFactoryPlugin ) In this case, the type defines what kind of object this processor will be used for. Because the Factory options specified processor as the pluginKey , the actual object is registered using that key. If the factory is invoked like this const msg = { type : 'myObjectType' , /* more values */ } const result = factory . create ( msg ) the myFactoryPlugin.processor( msg ) will be invoked and its result returned. Because the stategy is ALL and the processor is a function, the function will be invoked will all parameters given to the create() . Different Strategy objects can be set on a Factory to allow different behaviors to occur. When create( obj, ...rest ) is invoked, the strategies will behave in the following ways: Strategy Result Plugins.ALL This is the default strategy. If the registered item is a function, it will be invoked with f( obj, ...rest ) and the result returned. If the registered item is a Class, new Clzz( obj, ...args ) will be returned. Plugins.NONE If the registered item is a function, it will be invoked with no options. If the registered item is a Class, new Clzz( ) will be returned. Plugins.ARGS If the registered item is a function, it will be invoked with f( ...rest ) and the result returned. If the registered item is a Class, new Clzz( ...args ) will be returned. Plugins.MERGE If the registered item is a function, it will be invoked with f( { model : msg, ...rest } ) and the result returned. If the registered item is a Class, new Clzz( { model : msg, ...args } ) will be returned. The Plugins.mergeStrategy() call can be used to create a merge strategy that will use a different key. Plugins.LOOKUP In this case, the registered object is simply returned Plugins.reactStrategy( React, propKey = 'model' ) This strategy will call React.createElement() with the registered item as the component function or class. The ...rest object will be supplied as props to the component. If propKey is a string, the obj object will be given as a prop as well, using the propKey as the prop name. function A custom function( factory, registeredItem, typeOrObject, props ) can be set as the strategy object as well.","title":"Creation and Registration"},{"location":"concepts/plugins/factories/#dynamic-factories","text":"The Factory mechanism used in the plugin library is backed by @leverege/factory and augmented to include automatic registration and deregistration of plugins as they are added and removed. The factory mechanism can be used independently of Plugins as well - See @leverege/factory .","title":"Dynamic Factories"},{"location":"concepts/plugins/layout/","text":"Layout \u00b6 Sometimes, especially for UI Plugins, the Plugins need to be ordered and arranged into a tree like structure. This can be true of actions in a menu, creators in a selector, and other such mechanisms. The Layout is supplied as a common way to do this ordering. To use it: import { Layout } from '@leverege/plugins' const tree = Layout . create ( arrayOfItems /*, { buildTree : true } */ ) This create call will look at every item in the array for a layout object. This object can have the following options: Field Default Description sort item.name or item.type or '_z' This string is used to organize the objects into priorities. Items sorted with small sort values are higher in the list, so an 'a' will occur before a 'z' in sort order. group [] An array of strings representing groups. In a tree, items that share the group path will end up in the same node in hierarchy. groupNames [] The name of the group elements, used for human consumption. Only one item will contribute this value (the first one defining it) groupIcons [] The icon (either url or font icon) of the groups, used for human consumption. Only one item will contribute this value (the first one defining it) If create() is called with the buildTree option set to false, and array of objects containing { sort, group, groupKey, groupNames, groupIcons, item } will be returned. If buildTree is not set or is true, the array will be turned into a tree, where the root and groups in the tree look like: { type : 'layoutNode' , name , icon , items : [ ] } The items array will contain items from the original array and other layout nodes, created in order to support the hierarchy.","title":"Layout"},{"location":"concepts/plugins/layout/#layout","text":"Sometimes, especially for UI Plugins, the Plugins need to be ordered and arranged into a tree like structure. This can be true of actions in a menu, creators in a selector, and other such mechanisms. The Layout is supplied as a common way to do this ordering. To use it: import { Layout } from '@leverege/plugins' const tree = Layout . create ( arrayOfItems /*, { buildTree : true } */ ) This create call will look at every item in the array for a layout object. This object can have the following options: Field Default Description sort item.name or item.type or '_z' This string is used to organize the objects into priorities. Items sorted with small sort values are higher in the list, so an 'a' will occur before a 'z' in sort order. group [] An array of strings representing groups. In a tree, items that share the group path will end up in the same node in hierarchy. groupNames [] The name of the group elements, used for human consumption. Only one item will contribute this value (the first one defining it) groupIcons [] The icon (either url or font icon) of the groups, used for human consumption. Only one item will contribute this value (the first one defining it) If create() is called with the buildTree option set to false, and array of objects containing { sort, group, groupKey, groupNames, groupIcons, item } will be returned. If buildTree is not set or is true, the array will be turned into a tree, where the root and groups in the tree look like: { type : 'layoutNode' , name , icon , items : [ ] } The items array will contain items from the original array and other layout nodes, created in order to support the hierarchy.","title":"Layout"},{"location":"concepts/plugins/refinement/","text":"Plugin Refinement \u00b6 There are many situations where the Plugins registered at a given plugin point are further analyzed before being used. An example of this are Actions that are presented in a toolbar or context menu. In this situation, there are many Action plugins registered, but we only want to use the Actions that desired to be seen on a particular screen or when the target object is of a particular type. This refinement can occur in different ways depending on the plugin point, but two common paradigms often occur: matches objects and handles() functions. Match vs Handles Ultimately, how plugins are selected for use depends on the plugin point. There are situations when both matches and handles() are used. When this occurs, it is usually an indication of broad stroke filter(the matches) and then a finer grain mechanism to really decide whether or not the plugin should used. An example of this is Actions in a toolbar, where the matches is used to identify the client and particular toolbar, and the handles() is use to indicate that it can be used if a particular object is selected in the context given to handles(). The client will feed different contexts to the toolbars based on which objects are selected in table, map, list or other UI mechanism. Matches Paradigm \u00b6 Sometimes a plugin point will use the Matches paradigme to filter Plugins. This is often used as static, cacheable filter for all possible things that might show up in a plugin point. This paradigm has two sides: one advertised by the plugin point indicating what and/or where it is, and one on the Plugin that indicates its specific requirements. In order for a Plugin to be used, all the required fields in the Plugin's matches object must be met by the plugin point's matchContext . For example: export default MyAction { matches : { use : 'actionBar' , client : 'MyScreen' } // ... } This plugin is specifying that it should be used only when the plugin point specifies that the plugins are being used for an actionBar and the plugin point is in client called MyScreen . How plugin point specifies this filtered set of plugins can vary, but a simple example is to use the filter parameter on Plugins.get() import { Plugins , Context } from '@leverege/plugin' const matchContext = { use : 'actionBar' , client : 'MyScreen' , mobile : false , otherParam : 'yes' } const actions = Plugins . get ( 'Actions' , Context . createMatch ( matchContext ) ) In this particualr case, MyAction's matches.use would be compared against matchContext.use , and matches.client would be compared to matchContext.client . Since both fields match, the Action would pass the filter an be used. The other fields in the matchContext are unused in the case of MyAction, but other plugins might use them. It is important for the plugin point creator to document the contents of the matchContext. Some common matchContext parameters are represent here, but any keys can be supplied by the plugin point. Field Example client The overal type of screen or client. clientType A refinement of the client. Is sometimes the same as client mobile Is this client being used for a mobile presentation objectType The type of object being represented path The relationship path relationship A Relationship object Example Note In the above case, the Plugins.get() is not caching its results so the filter will occur every time. This is for example purposes only, and a Plugin View should really be used instead. The Context.createMatch() is a convenience function that calls plg => Match.isMatch( clientMatch, plg.matches ) Match Syntax \u00b6 The Match.isMatch( context, matches ) function has several rules it follows. If matches is Result null return true. All requirements are met. Array isMatch() is called for each element in the array. If any ony return true, the outer isMatch() will return true as well. function The result of calling matches( context ) will be returned. (it should return true or false) Object Each key in matches is evaluated against the context . If any one returns false, false is returned. Otherwise return true. See below for Field rules. else return false. Tip In general, it is best to use the Array or the Object when ever possible and avoid the complicated function at the field level. However, setting matches to a function and console logging the context is a quick way to see debug the matchesContext being used to evaluate your Plugin. When isMatch compares the fields in the matches object to the context object, it will use the following rules to evaluate each field key. The matches[field] and context[field] maybe both be arrays, in which cases each item in the matches is compared to each value in the context , and if any result in a true evaluation, the field will be considered matching. (For this description, V is the field value supplied in the matches object from the Plugin, and CV is the value of the field in the matchContext. R is used to indicate a recursive invokation of this rule.) If the field value V Result is an Array Return true if R( V[n], CV) is true equals CV return true * return true if CV is non-null Starts with '!' return true if V.substring(1) is not equal to CV Starts with '>', '>=', '<', '<=' returns true if mathematically CV is greater than, greater than or equal to, less then, less than or equal to the V minues the comparator null return true if CV is null or undefined Object if V.not exists, return false if R( V.not, CV) returns true. If V.and exists, return R( V.and, CV) . Otherwise return true function return result of V( context, CV ) return false Handles Paradigm \u00b6 In this paradigm, the Plugin will have a handle( cxt ) method that can return either true or false. If true, the Plugin should be used. This is very similar to Matches paradigm, though the intent is different, and these two paradigms are often used together on the same plugin point. Where the Matches paradigm may statically filter the set of Plugins down to all possible ones that might be used in this particular plugin point, the handles( cxt ) is meant to look deeper at what is happening in that particular case to determine if the plugin can or wants participate. The context object cxt supplied to this method contains entries that represent the current state of the plugin point: are certain objects checked, is the user right clicking on a particular item, is an item in a list selected, etc. As an example, a Contextual Action Menu plugin might want to work in a table of objects of type \"vehicle\", but only want that vehicle is in an alert state and the user has permissions to send an sms message to its owner. The Matches might match against client equaling 'TableView' and its path equaling 'dealer.vehicles', while the handles( cxt ) would check that the target object is a vehicle and the user is permissioned to send an sms. Context \u00b6 The plugins library includes a Context class meant to aid in the evaluation of the handles() context object. On primary support supplied is in regards to the target of the given context. It can be one object or many. There could also be a secondary target, or many secondary targets. It is up to your Plugin to decide when it should participate using the given context. In the case of a Action, some can support many targets, like perhaps a bulk remove. Some may require a single primary and a single secondary target, like a pair A to B. Some may allow many targets and many secondary targets. And some may not require targets at all, but some other field in the context. The following methods in Context can help your Plugin evaluate this context object. The following target methods below will look at the 'target' key in the Context object. Normally, objects are expected to have a { type : <objectType> } field. When this is not possible, the context can be constructed with a targetType field that indicates the type of targets in the target list. Method Description getTarget( cxt ) Returns the first object in the target field getTargets( cxt ) Returns an Array of objects in the target field getTargetTypes( cxt ) Returns an Array of objectTypes in the target field isTargetOfType( cxt, type, only = true ) Returns true if the target is of the given type. When isOnly is true, this will also return false when there are more than one target. getTargetOfType( cxt, type, only = true ) Returns the object or null in the target if it is of the given type. When isOnly is true, this will also return null when there are more than one target. hasTargetsOfType( cxt, type, arrayCondition = 'any ) This will return true if there are any targets in the list of the specified type. Possible options for arrayCondition inclue 'any', 'onlyOne', 'one', and 'all'. Using 'onlyOne' means there is only one target in the list and it is of the given type. Using 'one' means there is only one target in the list of the type. Using 'all' means all trargets must be of the specified type. getTargetsOfType( cxt, type, arrayCondition = 'any ) This is like hasTargetsOfType() but an array of the targets are actually returned. For secondary target evaluation, the same methods above exist but with the addition of 'Secondary' in the method name: getSecondaryTargetTypes , isSecondaryTargetOfType , getSecondaryTargetOfType , hasSecondaryTargetsOfType , getSecondaryTargetsOfType . These methods will use the fields called secondaryTarget and `secondaryTargetType . These methods are also available in a generic form where you can supply the keys to evaluate: getObject , getObjects , getOfType , getObjectTypes , isObjectOfType , getObjectOfType , hasObjectsOfType .","title":"Refinement"},{"location":"concepts/plugins/refinement/#plugin-refinement","text":"There are many situations where the Plugins registered at a given plugin point are further analyzed before being used. An example of this are Actions that are presented in a toolbar or context menu. In this situation, there are many Action plugins registered, but we only want to use the Actions that desired to be seen on a particular screen or when the target object is of a particular type. This refinement can occur in different ways depending on the plugin point, but two common paradigms often occur: matches objects and handles() functions. Match vs Handles Ultimately, how plugins are selected for use depends on the plugin point. There are situations when both matches and handles() are used. When this occurs, it is usually an indication of broad stroke filter(the matches) and then a finer grain mechanism to really decide whether or not the plugin should used. An example of this is Actions in a toolbar, where the matches is used to identify the client and particular toolbar, and the handles() is use to indicate that it can be used if a particular object is selected in the context given to handles(). The client will feed different contexts to the toolbars based on which objects are selected in table, map, list or other UI mechanism.","title":"Plugin Refinement"},{"location":"concepts/plugins/refinement/#matches-paradigm","text":"Sometimes a plugin point will use the Matches paradigme to filter Plugins. This is often used as static, cacheable filter for all possible things that might show up in a plugin point. This paradigm has two sides: one advertised by the plugin point indicating what and/or where it is, and one on the Plugin that indicates its specific requirements. In order for a Plugin to be used, all the required fields in the Plugin's matches object must be met by the plugin point's matchContext . For example: export default MyAction { matches : { use : 'actionBar' , client : 'MyScreen' } // ... } This plugin is specifying that it should be used only when the plugin point specifies that the plugins are being used for an actionBar and the plugin point is in client called MyScreen . How plugin point specifies this filtered set of plugins can vary, but a simple example is to use the filter parameter on Plugins.get() import { Plugins , Context } from '@leverege/plugin' const matchContext = { use : 'actionBar' , client : 'MyScreen' , mobile : false , otherParam : 'yes' } const actions = Plugins . get ( 'Actions' , Context . createMatch ( matchContext ) ) In this particualr case, MyAction's matches.use would be compared against matchContext.use , and matches.client would be compared to matchContext.client . Since both fields match, the Action would pass the filter an be used. The other fields in the matchContext are unused in the case of MyAction, but other plugins might use them. It is important for the plugin point creator to document the contents of the matchContext. Some common matchContext parameters are represent here, but any keys can be supplied by the plugin point. Field Example client The overal type of screen or client. clientType A refinement of the client. Is sometimes the same as client mobile Is this client being used for a mobile presentation objectType The type of object being represented path The relationship path relationship A Relationship object Example Note In the above case, the Plugins.get() is not caching its results so the filter will occur every time. This is for example purposes only, and a Plugin View should really be used instead. The Context.createMatch() is a convenience function that calls plg => Match.isMatch( clientMatch, plg.matches )","title":"Matches Paradigm"},{"location":"concepts/plugins/refinement/#match-syntax","text":"The Match.isMatch( context, matches ) function has several rules it follows. If matches is Result null return true. All requirements are met. Array isMatch() is called for each element in the array. If any ony return true, the outer isMatch() will return true as well. function The result of calling matches( context ) will be returned. (it should return true or false) Object Each key in matches is evaluated against the context . If any one returns false, false is returned. Otherwise return true. See below for Field rules. else return false. Tip In general, it is best to use the Array or the Object when ever possible and avoid the complicated function at the field level. However, setting matches to a function and console logging the context is a quick way to see debug the matchesContext being used to evaluate your Plugin. When isMatch compares the fields in the matches object to the context object, it will use the following rules to evaluate each field key. The matches[field] and context[field] maybe both be arrays, in which cases each item in the matches is compared to each value in the context , and if any result in a true evaluation, the field will be considered matching. (For this description, V is the field value supplied in the matches object from the Plugin, and CV is the value of the field in the matchContext. R is used to indicate a recursive invokation of this rule.) If the field value V Result is an Array Return true if R( V[n], CV) is true equals CV return true * return true if CV is non-null Starts with '!' return true if V.substring(1) is not equal to CV Starts with '>', '>=', '<', '<=' returns true if mathematically CV is greater than, greater than or equal to, less then, less than or equal to the V minues the comparator null return true if CV is null or undefined Object if V.not exists, return false if R( V.not, CV) returns true. If V.and exists, return R( V.and, CV) . Otherwise return true function return result of V( context, CV ) return false","title":"Match Syntax"},{"location":"concepts/plugins/refinement/#handles-paradigm","text":"In this paradigm, the Plugin will have a handle( cxt ) method that can return either true or false. If true, the Plugin should be used. This is very similar to Matches paradigm, though the intent is different, and these two paradigms are often used together on the same plugin point. Where the Matches paradigm may statically filter the set of Plugins down to all possible ones that might be used in this particular plugin point, the handles( cxt ) is meant to look deeper at what is happening in that particular case to determine if the plugin can or wants participate. The context object cxt supplied to this method contains entries that represent the current state of the plugin point: are certain objects checked, is the user right clicking on a particular item, is an item in a list selected, etc. As an example, a Contextual Action Menu plugin might want to work in a table of objects of type \"vehicle\", but only want that vehicle is in an alert state and the user has permissions to send an sms message to its owner. The Matches might match against client equaling 'TableView' and its path equaling 'dealer.vehicles', while the handles( cxt ) would check that the target object is a vehicle and the user is permissioned to send an sms.","title":"Handles Paradigm"},{"location":"concepts/plugins/refinement/#context","text":"The plugins library includes a Context class meant to aid in the evaluation of the handles() context object. On primary support supplied is in regards to the target of the given context. It can be one object or many. There could also be a secondary target, or many secondary targets. It is up to your Plugin to decide when it should participate using the given context. In the case of a Action, some can support many targets, like perhaps a bulk remove. Some may require a single primary and a single secondary target, like a pair A to B. Some may allow many targets and many secondary targets. And some may not require targets at all, but some other field in the context. The following methods in Context can help your Plugin evaluate this context object. The following target methods below will look at the 'target' key in the Context object. Normally, objects are expected to have a { type : <objectType> } field. When this is not possible, the context can be constructed with a targetType field that indicates the type of targets in the target list. Method Description getTarget( cxt ) Returns the first object in the target field getTargets( cxt ) Returns an Array of objects in the target field getTargetTypes( cxt ) Returns an Array of objectTypes in the target field isTargetOfType( cxt, type, only = true ) Returns true if the target is of the given type. When isOnly is true, this will also return false when there are more than one target. getTargetOfType( cxt, type, only = true ) Returns the object or null in the target if it is of the given type. When isOnly is true, this will also return null when there are more than one target. hasTargetsOfType( cxt, type, arrayCondition = 'any ) This will return true if there are any targets in the list of the specified type. Possible options for arrayCondition inclue 'any', 'onlyOne', 'one', and 'all'. Using 'onlyOne' means there is only one target in the list and it is of the given type. Using 'one' means there is only one target in the list of the type. Using 'all' means all trargets must be of the specified type. getTargetsOfType( cxt, type, arrayCondition = 'any ) This is like hasTargetsOfType() but an array of the targets are actually returned. For secondary target evaluation, the same methods above exist but with the addition of 'Secondary' in the method name: getSecondaryTargetTypes , isSecondaryTargetOfType , getSecondaryTargetOfType , hasSecondaryTargetsOfType , getSecondaryTargetsOfType . These methods will use the fields called secondaryTarget and `secondaryTargetType . These methods are also available in a generic form where you can supply the keys to evaluate: getObject , getObjects , getOfType , getObjectTypes , isObjectOfType , getObjectOfType , hasObjectsOfType .","title":"Context"},{"location":"concepts/plugins/views/","text":"Views \u00b6 As mentioned earlier, the Plugins.get( type, filter ) call can return a filtered set of plugins of a given type. Sometimes, however, these plugins are evaluated and organized into a more complicated structure that allows for easier and quicker access. This is where the View comes into play. The View will watch the Plugin mechanisms for Plugins that are added and removed, and mark its view as dirty when appropriate. When the View is nexted ask for its value, it can either recalculate the value or return a cached one. For a plugin point to use a Factory, it should use the createView( type, options, throwError = false ) method to obtain and/or create it. const view = Plugins . createView ( 'myProject.MyLookupType' , options ) The first argument identifies the plugin point type that the View is using , the second object is the options used to configure the factory: Option Field Default Description name default The name of the View. This is used to cache the View so it can be returned from a repeated createFactory() or getFactory() call. sort defaultSort This defines the sort function used to sort the plugins. By default, the sort function uses a string sorting mechanism on the 'sort' key, but alternates functions can be used. If this is 'byNumber', a sort using a number will be installed. filter null The filter used to prune plugins from the View. If processor is supplied, this is not used. processor null A function that, if supplied, this is invoked with an Array of sorted plugins. The result of this function is returned from View.get() . If this is not supplied, the filter options will be used. If a processor is not supplied, view.get() will return an array of plugins, sorted and filtered according to those options. If the processor is given, the result from the processor defines the shape of the return value of view.get() . When a Plugin of the View's type is added or removed, the view is marked as dirty and is recalculated vi processor or filter on the next invokation of view.get() .","title":"Views"},{"location":"concepts/plugins/views/#views","text":"As mentioned earlier, the Plugins.get( type, filter ) call can return a filtered set of plugins of a given type. Sometimes, however, these plugins are evaluated and organized into a more complicated structure that allows for easier and quicker access. This is where the View comes into play. The View will watch the Plugin mechanisms for Plugins that are added and removed, and mark its view as dirty when appropriate. When the View is nexted ask for its value, it can either recalculate the value or return a cached one. For a plugin point to use a Factory, it should use the createView( type, options, throwError = false ) method to obtain and/or create it. const view = Plugins . createView ( 'myProject.MyLookupType' , options ) The first argument identifies the plugin point type that the View is using , the second object is the options used to configure the factory: Option Field Default Description name default The name of the View. This is used to cache the View so it can be returned from a repeated createFactory() or getFactory() call. sort defaultSort This defines the sort function used to sort the plugins. By default, the sort function uses a string sorting mechanism on the 'sort' key, but alternates functions can be used. If this is 'byNumber', a sort using a number will be installed. filter null The filter used to prune plugins from the View. If processor is supplied, this is not used. processor null A function that, if supplied, this is invoked with an Array of sorted plugins. The result of this function is returned from View.get() . If this is not supplied, the filter options will be used. If a processor is not supplied, view.get() will return an array of plugins, sorted and filtered according to those options. If the processor is given, the result from the processor defines the shape of the return value of view.get() . When a Plugin of the View's type is added or removed, the view is marked as dirty and is recalculated vi processor or filter on the next invokation of view.get() .","title":"Views"},{"location":"config/","text":"Configuration \u00b6 This describes the values in the Molten Confg.js file. Show/Hide the Layout Controller \u00b6 Path Description plugins/config/LayoutViewerSelector Allows visibility control of the layout button in GroupScreen and ItemInfoScreen. { allowEditing : <boolean>;|<string>|<function> } for example: { allowEditing : \"Installer, Admin\" } Would allow user in the persona of Installer or Admin to see the buttons plugins/config/mapBoxPosition Sets default position and zoom. selectedRezoomThreshold: Indicates at what range (or less ) the view should recenter/zoom in on the selected object. selectedZoom: target zoom when selection occurs and rezoom threshold is exceeded. ( Negative one means dont zoom ) pathOptions: an object where the keys are the blueprint paths to allow customization of selectedRezoom options. { center : [ -77.1902656, 39.1081595 ], zoom : 18, selectedRezoomThreshold : 12, // if we re beyond this range, selection will cause rezoom/center selectedZoom : 18, // this is the target range to go to on selection. pathOptions : { building : { selectedRezoomThreshold : 10, selectedZoom : 18 } } } UserManagement / ResourceUser Screen \u00b6 Under plugins/config/ResourceUsers, the following keys can be set to change properties: Key Default activateAccountFieldValidators null activateAccountPreSubmitComponents null activateAccountValidator () => true activateAccountCustomOnSubmit () => activateAccountSupportsLogin true userSelectorUsernameLabel Email or Username* userSelectorUsernameHint Enter Email or Username userSelectorUsernameInstructions Enter user's email or username and hit enter or next to continue. addUserTitle Add User editUserTitle Edit User addUserOkay Next editUserUpdate Update allowCreateUser true allowInviteUser true inviteEmailLabel Email* inviteEmailHint Enter Email createEmailLabel Account Email* createEmailHint ex. johnsmith@example.com createUsernameLabel Username createUsernameHint Enter Username activateEmailLabel Account Email* createNameLabel Name* createNameHint ex. John Smith createPhoneLabel Phone Number createPhoneHint ex. (555) 555-5555 createPasswordLabel Password createPasswordHint Enter password createConfirmPasswordLabel Confirm Password createConfirmPasswordHint Re-enter password screenIcon null addDialogIcon null editDialogIcon null removeUserDialogIcon null 404 / LostScreen \u00b6 Under plugins/config/LostScreen, the following keys can be set to change properties: Key Default Description title Oops! The title to put on the page message We couldn't find this page - our apologies! The sub text to display to the user button Let's find our way The label of the button on the \u2018home\u2019 link link '/' The location to take the user when the button is pressed image fa fa-meh-o The font icon or image url to display. This can also be an array of font icons and image urls. If it is an Array, one will randomly be selected and used. These images are supplied as good initial resources: LostScreen : { image : [ 'https://molten-ui-assets.storage.googleapis.com/404-UFO.png', 'https://molten-ui-assets.storage.googleapis.com/404-Earth.png', 'https://molten-ui-assets.storage.googleapis.com/404-Page.png', 'https://molten-ui-assets.storage.googleapis.com/404-Ghost.png' ] } NetworkOffline \u00b6 Under plugins/config/NetworkOffline, the following keys can be set to change properties: Key Default Description message Your Network connection has been lost. The message to display when network connection is lost. icon fa fa-exclamation-triangle The font icon class or image url to display with the text, when the connection is lost. BlueprintActions \u00b6 Under plugins/config/BlueprintActions, the following keys can be set to change properties: Key Default Description updateIcon fa fa-pencil fa-fw The font icon class or image url to display for a blueprint update action. createIcon fa fa-plus fa-fw The font icon class or image url to display for a blueprint create action. bulkCreateIcon fa fa-plus fa-fw The font icon class or image url to display for a blueprint bulk create action. removeIcon fa fa-trash fa-fw The font icon class or image url to display for a blueprint remove action. No Data/No Search Results Views \u00b6 Under plugins/config/ where is one of ListDataViewer or TableDataViewer the following keys can be set to change the no data/no search results views: | Key | Default | Description | | noDataMessage | The class found in molten at: src/screens/shared/group/noData/NoDataView.jsx | The string or React Component/Function to render when there is no data in the table/list | Under plugins/config/NoDataView the following keys can be set to configure the NoDataView that is used by default Key Default Description noDataTitle the name of the blueprint Can be overridden by a string in the blueprint or attribute noDataBody Looks like there's nothing here, try creating something! Can be overridden by a string in the blueprint or attribute noDataIcon https://molten-ui-assets.storage.googleapis.com/no-data.svg Can be overridden by a string in the blueprint or attribute noDataIconDimensions { height : 224, width : 224 } Can be overridden by a string in the blueprint or attribute noDataDocLink null Can be overridden by a string in the blueprint or attribute noSearchResultsTitle We couldn't find any matches for that Can be overridden by a string in the blueprint or attribute noSearchResultsBody Please try searching for another item Can be overridden by a string in the blueprint or attribute noSearchResultsIcon https://molten-ui-assets.storage.googleapis.com/no-search-results.svg Can be overridden by a string in the blueprint or attribute noSearchResultsIconDimensions { height : 224, width : 224 } Can be overridden by a string in the blueprint or attribute Group Screen \u00b6 Key Default Description refreshTime 30000 Number of milliseconds between data refreshes on all group screens /defaultPerPage 200 Default per page for a given relationship path defaultPerPage 200 Default per page for all GroupScreens (used as a fallback if no value specified for a specific path)","title":"Configuration"},{"location":"config/#configuration","text":"This describes the values in the Molten Confg.js file.","title":"Configuration"},{"location":"config/#showhide-the-layout-controller","text":"Path Description plugins/config/LayoutViewerSelector Allows visibility control of the layout button in GroupScreen and ItemInfoScreen. { allowEditing : <boolean>;|<string>|<function> } for example: { allowEditing : \"Installer, Admin\" } Would allow user in the persona of Installer or Admin to see the buttons plugins/config/mapBoxPosition Sets default position and zoom. selectedRezoomThreshold: Indicates at what range (or less ) the view should recenter/zoom in on the selected object. selectedZoom: target zoom when selection occurs and rezoom threshold is exceeded. ( Negative one means dont zoom ) pathOptions: an object where the keys are the blueprint paths to allow customization of selectedRezoom options. { center : [ -77.1902656, 39.1081595 ], zoom : 18, selectedRezoomThreshold : 12, // if we re beyond this range, selection will cause rezoom/center selectedZoom : 18, // this is the target range to go to on selection. pathOptions : { building : { selectedRezoomThreshold : 10, selectedZoom : 18 } } }","title":"Show/Hide the Layout Controller"},{"location":"config/#usermanagement-resourceuser-screen","text":"Under plugins/config/ResourceUsers, the following keys can be set to change properties: Key Default activateAccountFieldValidators null activateAccountPreSubmitComponents null activateAccountValidator () => true activateAccountCustomOnSubmit () => activateAccountSupportsLogin true userSelectorUsernameLabel Email or Username* userSelectorUsernameHint Enter Email or Username userSelectorUsernameInstructions Enter user's email or username and hit enter or next to continue. addUserTitle Add User editUserTitle Edit User addUserOkay Next editUserUpdate Update allowCreateUser true allowInviteUser true inviteEmailLabel Email* inviteEmailHint Enter Email createEmailLabel Account Email* createEmailHint ex. johnsmith@example.com createUsernameLabel Username createUsernameHint Enter Username activateEmailLabel Account Email* createNameLabel Name* createNameHint ex. John Smith createPhoneLabel Phone Number createPhoneHint ex. (555) 555-5555 createPasswordLabel Password createPasswordHint Enter password createConfirmPasswordLabel Confirm Password createConfirmPasswordHint Re-enter password screenIcon null addDialogIcon null editDialogIcon null removeUserDialogIcon null","title":"UserManagement / ResourceUser Screen"},{"location":"config/#404-lostscreen","text":"Under plugins/config/LostScreen, the following keys can be set to change properties: Key Default Description title Oops! The title to put on the page message We couldn't find this page - our apologies! The sub text to display to the user button Let's find our way The label of the button on the \u2018home\u2019 link link '/' The location to take the user when the button is pressed image fa fa-meh-o The font icon or image url to display. This can also be an array of font icons and image urls. If it is an Array, one will randomly be selected and used. These images are supplied as good initial resources: LostScreen : { image : [ 'https://molten-ui-assets.storage.googleapis.com/404-UFO.png', 'https://molten-ui-assets.storage.googleapis.com/404-Earth.png', 'https://molten-ui-assets.storage.googleapis.com/404-Page.png', 'https://molten-ui-assets.storage.googleapis.com/404-Ghost.png' ] }","title":"404 / LostScreen"},{"location":"config/#networkoffline","text":"Under plugins/config/NetworkOffline, the following keys can be set to change properties: Key Default Description message Your Network connection has been lost. The message to display when network connection is lost. icon fa fa-exclamation-triangle The font icon class or image url to display with the text, when the connection is lost.","title":"NetworkOffline"},{"location":"config/#blueprintactions","text":"Under plugins/config/BlueprintActions, the following keys can be set to change properties: Key Default Description updateIcon fa fa-pencil fa-fw The font icon class or image url to display for a blueprint update action. createIcon fa fa-plus fa-fw The font icon class or image url to display for a blueprint create action. bulkCreateIcon fa fa-plus fa-fw The font icon class or image url to display for a blueprint bulk create action. removeIcon fa fa-trash fa-fw The font icon class or image url to display for a blueprint remove action.","title":"BlueprintActions"},{"location":"config/#no-datano-search-results-views","text":"Under plugins/config/ where is one of ListDataViewer or TableDataViewer the following keys can be set to change the no data/no search results views: | Key | Default | Description | | noDataMessage | The class found in molten at: src/screens/shared/group/noData/NoDataView.jsx | The string or React Component/Function to render when there is no data in the table/list | Under plugins/config/NoDataView the following keys can be set to configure the NoDataView that is used by default Key Default Description noDataTitle the name of the blueprint Can be overridden by a string in the blueprint or attribute noDataBody Looks like there's nothing here, try creating something! Can be overridden by a string in the blueprint or attribute noDataIcon https://molten-ui-assets.storage.googleapis.com/no-data.svg Can be overridden by a string in the blueprint or attribute noDataIconDimensions { height : 224, width : 224 } Can be overridden by a string in the blueprint or attribute noDataDocLink null Can be overridden by a string in the blueprint or attribute noSearchResultsTitle We couldn't find any matches for that Can be overridden by a string in the blueprint or attribute noSearchResultsBody Please try searching for another item Can be overridden by a string in the blueprint or attribute noSearchResultsIcon https://molten-ui-assets.storage.googleapis.com/no-search-results.svg Can be overridden by a string in the blueprint or attribute noSearchResultsIconDimensions { height : 224, width : 224 } Can be overridden by a string in the blueprint or attribute","title":"No Data/No Search Results Views"},{"location":"config/#group-screen","text":"Key Default Description refreshTime 30000 Number of milliseconds between data refreshes on all group screens /defaultPerPage 200 Default per page for a given relationship path defaultPerPage 200 Default per page for all GroupScreens (used as a fallback if no value specified for a specific path)","title":"Group Screen"},{"location":"docs/","text":"","title":"Index"},{"location":"docs/custom-data/","text":"Adding Custom Data \u00b6 A common need in molten is the consumption of data that is external to the leverege platform. That data might be stored locally in files, accessible through a 3 rd party API, or elsewhere. Assuming the data is roughly structured as a group of items with individual items within it, the process for consuming and displaying this data on custom pages within a molten application are as follows: Create actions classes that mirror the Group and Item Actions Create a DataSource object to make those actions available Add custom Atrribute plugins to let the ui configure viewing the data Make a custom route that uses GroupScreen to view the data Add custom actions to CRUD the data (optional) Customize the search features (optional) This section of the documentation will serve as a tutorial for how to perform these actions and, in particular, how to set up a pet shop demo in molten that manages a list of pets","title":"Adding Custom Data"},{"location":"docs/custom-data/#adding-custom-data","text":"A common need in molten is the consumption of data that is external to the leverege platform. That data might be stored locally in files, accessible through a 3 rd party API, or elsewhere. Assuming the data is roughly structured as a group of items with individual items within it, the process for consuming and displaying this data on custom pages within a molten application are as follows: Create actions classes that mirror the Group and Item Actions Create a DataSource object to make those actions available Add custom Atrribute plugins to let the ui configure viewing the data Make a custom route that uses GroupScreen to view the data Add custom actions to CRUD the data (optional) Customize the search features (optional) This section of the documentation will serve as a tutorial for how to perform these actions and, in particular, how to set up a pet shop demo in molten that manages a list of pets","title":"Adding Custom Data"},{"location":"docs/custom-data/actions/","text":"The first step in implementing our pet list demo is to create \"action\" classes. Action classes in molten allow for a code interface to common actions that would be performed against individuals or groups of items in an API. Some examples of these actions include requesting a list from the data's source (like a REST API) as bounded by a set of filters, creating an item in a list, updating an item in a list, deleting an item from a list, etc. Additional actions may revolve around retrieving previously requested data in a synchronous manner (like from redux or another local state mechanism) An example of what custom actions look like is located below These two files demonstrate the proper way to extend ItemActions and GroupActions respectively. The base classes for ItemActions and GroupActions can be found in the src/dataSource folder. They contain documentation around which functions are required to be implemented to successfully extend them, and which are optional. For the purpose of this tutorial, the most relevant functions are: PetsActions: item - gets a PetActions instance relevant to a single Pet create - creates a pet in the pets list list/search - goes and gets a list of pets that match a filter object update - updates a specified pet in the list delete - deletes a specified pet from the list getList - gets the list that was requested by list/search from local state PetActions: - parent - gets a PetsActions instance get - goes and gets the state of a given pet update - updates the pet specified by this actions class delete - deletes the pet specified by this actions class getItem - gets the item specified by this actions class from local state Action Files \u00b6 PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } } Mock Pet API \u00b6 The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Creating Custom Actions"},{"location":"docs/custom-data/actions/#action-files","text":"PetActions PetsActions.js import { GlobalState } from '@leverege/ui-redux' import { DataSources } from '@leverege/ui-attributes/lib/dataSource' import ItemActions from '../../../src/dataSource/ItemActions' // eslint-disable-next-line import/no-cycle import PetsActions from './PetsActions' import PetApi from './PetApi' export default class PetActions extends ItemActions { static getItem ( state = GlobalState . get () ) { return PetApi . get ( this . id ) } constructor ( { match , relationship , id } ) { super () this . match = match this . relationship = relationship this . systemId = relationship ? . systemId this . id = id } getGroup () { return this . parent () } /** * Returns the parent's action object. */ parent ( ) { return new PetsActions ( {} ) } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return `pets/ ${ this . id } ` } /** * Returns a redux action that will call api to read a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ get ( ) { // looks like an action but doesn't touch redux return async () => { return PetApi . get ( this . id ) } } /** * Returns a redux action that will call the api to create an item at the current path * @param {object} data the data of the item to create * @param {object} options a set of options */ create ( data ) { return async () => { return PetApi . create ( data ) } } /** * Returns a redux action that will call api to update a child of the current path * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( data ) { return async () => { const pds = DataSources . DataSourceFactory . get ( 'petApi.pet' ) const entry = pds . getData ( { id : this . id } ) return PetApi . set ( this . id , { ... entry , ... data } ) } } /** * Returns a redux action that will call api to delete a child of the current path * @param {object} options api options * @returns {function} redux thunk function */ delete () { return () => { return PetApi . delete ( this . id ) } } // local access getItem () { return PetApi . get ( this . id ) } isLoading () { return false } isDone () { return true } } import { GlobalState } from '@leverege/ui-redux' import PetActions from './PetActions' import GroupActions from '../../../src/dataSource/GroupActions' import PetApi from './PetApi' export default class PetsAction extends GroupActions { constructor ( opts ) { super () this . opts = opts this . searches = {} this . queryName = 'default' } getGroup () { return this } getInterfaceUrl () { return this . getUrl () } /** * Returns the url for this group action object */ getUrl () { return 'pets' } /** * Creates a item action for the id in the group. */ item ( id ) { return new PetActions ( { id } ) } itemRef ( id ) { return { type : this . relationship . blueprint . type , ref : this . getUrl (), id } } /** * Returns a redux action that will call api to create an item as a child of the current path * @param {object} obj item to be created * @param {object} options api options * @returns {function} redux thunk function */ create ( obj , options ) { return async () => { return PetApi . create ( obj ) } } /** * Create a dispatch action for a request of a list of objects */ list ( options ) { return this . search ( options ) } search ( obj , options ) { return async ( dispatch , getState , { api } ) => { const search = obj ? . filter ? . value const queryName = options ? . queryName || this . queryName const perPage = obj ? . perPage || obj ? . limit || 200 this . searches [ queryName ] = { perPage , search } const res = await PetApi . search ( this . searches [ queryName ] ) return res } } /** * Returns a redux action that will call api to update a child of the current path * @param {string} id id of the item to be updated * @param {object} data values of the item to be changed * @param {object} options api options * @returns {function} redux thunk function */ update ( id , data , options ) { return this . item ( id ). update ( data , options ) } /** * Returns a redux action that will call api to delete a child of the current path * @param {string} id id of the item to be deleted * @param {object} options api options * @returns {function} redux thunk function */ delete ( id , body , options , reducerOptions ) { return this . item ( id ). delete ( body , options , reducerOptions ) } getList ( state = GlobalState . get (), options ) { const queryName = options ? . queryName || this . queryName const res = PetApi . search ( this . searches [ queryName ] ) return res } isLoading ( state = GlobalState . get () ) { return false } isDone ( state = GlobalState . get () ) { return true } }","title":"Action Files"},{"location":"docs/custom-data/actions/#mock-pet-api","text":"The mock api below simulates normal functions of an API without requiring an externally running api. import B62 from '@leverege/base62-util' import Gen from 'project-name-generator' import { UI , GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' function createPet ( data ) { return { id : B62 . v4 (), type : 'petApi.pet' , name : data ? . name == null ? Gen (). spaced : data ? . name , age : data ? . age == null ? Math . ceil ( Math . random () * 20 ) : data ? . age , position : data ? . position == null ? { lat : 38 + ( Math . random () - 0.5 ), lon : - 76 + ( Math . random () - 0.5 ) } : data ? . position } } /** * This is a mock of an api and thus makes no requests, in a real * situation this would reach out to external data. */ class PetApi { generateData = ( count = 200 ) => { const data = {} const list = [] for ( let n = 0 ; n < count ; n ++ ) { const p = createPet () data [ p . id ] = p list . push ( p ) } GlobalState . dispatch ( UI . multiSet ( { petList : list , petData : data } ) ) } get ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ id ] } set ( id , newValue ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList if ( ! data [ id ] ) { return null } const index = list . findIndex ( item => item . id === id ) const nList = [ ... list . slice ( 0 , index ), newValue , ... list . slice ( index + 1 ) ] const nData = { ... data , [ id ] : newValue } GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) return nList } delete ( id ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const nData = { ... data } delete nData [ id ] const nList = list . filter ( entry => entry . id !== id ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } create ( newData ) { const state = GlobalState . get () const data = state ? . ui ? . petData const list = state ? . ui ? . petList const newPet = createPet ( newData ) const nData = { ... data } const nList = [ ... list ] nData [ newPet . id ] = newPet nList . unshift ( newPet ) GlobalState . dispatch ( UI . multiSet ( { petList : nList , petData : nData } ) ) } search ( { perPage , search } = { perPage : 200 , search : null } ) { const state = GlobalState . get () let list = state ? . ui ? . petList if ( ! list && ! this . loaded ) { this . loaded = true process . nextTick ( () => this . generateData () ) return null } if ( ! list ) { return null } const res = list const items = {} const toCheck = search ? . replace ( /[*]/g , '' ) if ( toCheck ) { const attrs = Attributes . getAttributesFor ( 'petApi.pet' ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck . toLowerCase () ) ) { items [ i . id ] = i } } ) } ) list = Object . values ( items ) } return { total : list . length , start : 0 , perPage , count : list . length , items : list } } } export default new PetApi ()","title":"Mock Pet API"},{"location":"docs/custom-data/attributes/","text":"Pets have 3 attributes (besides their id): Name, Age, and Position. To be able to view these attributes in a table, update form, or creation form, Attribute plugins must be created for them. Attributes plugins have a few required fields, namely: name - The name of the Attribute, which is used to look it up along with objectType to perform common operations objectType - The type of object this Attribute is relevant to, which is used along with name to look it up to perform common operations valueType - The type of the attribute, which can be anything, but common types include strings , numbers , integers , geoPoints , geoJson , and Timestamp . get - This function is used by display and update mechanisms to get the current value of this attribute given an instance of the objectType it pertains to and some context displayName - A field of the Attribute used to display the attribute in lists for configuration or default titles Name Attribute Age Attribute Position Attribute Setup { name : 'name' , objectType : 'petApi.pet' , valueType : 'string' , get : ( data , cxt ) => { return data ? . name }, displayName : 'Name' } { name : 'age' , objectType : 'petApi.pet' , valueType : 'number' , get : ( data , cxt ) => { return data ? . age }, displayName : 'Age' } { name : 'geoPosition' , objectType : 'petApi.pet' , valueType : 'geoPoint' , get : ( data , cxt ) => { return data ? . position }, displayName : 'Position' } molten . addPlugin ( 'Attribute' , NameAttribute ) molten . addPlugin ( 'Attribute' , AgeAttribute ) molten . addPlugin ( 'Attribute' , PositionAttribute )","title":"Making Custom Attributes"},{"location":"docs/custom-data/data-source/","text":"The second step of consuming custom data in your molten application is creating a DataSource. More general DataSource documentation can be found here For our use case, of creating a list of pets, the DataSource might look like this: import { GlobalState } from '@leverege/ui-redux' import PetsActions from './PetsActions' import PetActions from './PetActions' export default class PetDataSource { dataSource () { return 'petApi.pets' } getData ( objRef ) { const state = GlobalState . get () const data = state ? . ui ? . petData return data ? .[ objRef . id ] } getActions ( objRef ) { if ( objRef ? . id ) { return new PetActions ( { item : objRef , id : objRef ? . id } ) } return new PetsActions () } } Notice that in the getActions function we are returning instances of our PetActions and PetsActions classes as implemented in the previous step.","title":"Creating a DataSource"},{"location":"docs/custom-data/molten-actions/","text":"Beyond basic list functionality, it's easy in molten to add actions to Create, Update, and Delete items in your list if those are things your API supports. Below is the code for basic actions to perform these operations continuing the pet shop example. Create Action \u00b6 Plugin Create Pet Component Shared Create/Edit Form File CreateAction.js import { Dialogs } from '@leverege/ui-elements' import { Config } from '@leverege/plugin' import CreatePet from '../views/CreatePet' // given a Relationship instance, make a create action that can be installed into molten export default relationship => ( { id : 'action.pet.CreateItem' , name : 'Create Pet Item' , layout : { sort : 'item.add' }, handles : cxt => true , appearance : ( ) => { return { name : 'Create Pet' , icon : Config . get ( 'BlueprintActions' , 'createIcon' , 'https://storage.googleapis.com/molten-ui-assets/create-action.png' ) } }, perform : ( { context } ) => { const { clientProps : { actions }, reloadData } = context Dialogs . show ( { component : CreatePet , props : { reloadData , actions , relationship } } ) } } ) File CreatePet.jsx import React from 'react' import { Dialog , Toast } from '@leverege/ui-elements' import { GlobalState } from '@leverege/ui-redux' import CreateEditForm from './CreateEditForm' export default function CreatePet ( props ) { const { show , onClose , actions , value , reloadData } = props const onSubmit = async ( { value } ) => { try { await GlobalState . dispatch ( actions . create ( value ) ) Toast . success ( 'Successfully Created Pet' ) } catch ( err ) { console . error ( err ) Toast . error ( 'Failed to Create Pet' ) } await reloadData ? .() onClose () } return ( < Dialog show = { show } onClose = { onClose } > < CreateEditForm {... props } value = { value } title = \"Create Pet\" submitText = \"Submit\" onSubmit = { onSubmit } onCancel = { onClose } /> < /Dialog> ) } File CreateEditForm.jsx import React from 'react' import { Pane , Button , TextInput , NumericInput , PropertyGrid , Content } from '@leverege/ui-elements' import { TitleBar } from '@leverege/ui-plugin' import { GeoPointEditor } from '@leverege/ui-geo-elements' export default class CreateEditForm extends React . Component { constructor ( props ) { super ( props ) const { value } = props this . state = { newValue : value } } onCancel = ( evt ) => { const { onCancel , eventData } = this . props return onCancel ? .( { data : eventData , value : null , originalEvent : evt } ) } onSubmit = ( evt ) => { const { onSubmit , eventData } = this . props const { newValue } = this . state return onSubmit ? .( { data : eventData , value : newValue , originalEvent : evt } ) } onAgeChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , age : evt ? . value } } ) } onNameChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , name : evt ? . value } } ) } onPositionChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , position : evt ? . value } } ) } render () { const { value , submitText , title , titleIcon } = this . props const { newValue } = this . state return ( < Content relative > < Content . Header variant = \"formHeader\" > < TitleBar variant = \"dialogTitle\" title = { title } icon = { titleIcon } /> < /Content.Header> < Content . Area variant = \"formBody\" > < Pane > < PropertyGrid > < PropertyGrid . Item label = \"Name\" > < TextInput value = { newValue ? . name } onChange = { this . onNameChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Age\" > < NumericInput value = { newValue ? . age } onChange = { this . onAgeChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Position\" > < GeoPointEditor value = { newValue ? . position } onChange = { this . onPositionChange } /> < /PropertyGrid.Item> < /PropertyGrid> < /Pane> < /Content.Area> < Content . Footer variant = \"formButtons\" layout = \"flex:rowMEnd\" > < Pane layout = \"flex:rowM\" > < Button variant = \"secondary\" onClick = { this . onCancel } > Cancel < /Button> < Button disabled = { newValue === value } variant = \"primary\" onClick = { this . onSubmit } > { submitText } < /Button> < /Pane> < /Content.Footer> < /Content> ) } } Update Action \u00b6 Plugin Update Pet Component Shared Create/Edit Form File UpdateAction.js import { Dialogs } from '@leverege/ui-elements' import { Config , Context } from '@leverege/plugin' import { DataSources } from '@leverege/ui-attributes' import UpdatePet from '../views/UpdatePet' // given a Relationship instance, make an update action that can be installed into molten export default relationship => ( { id : 'blueprint.action.pet.UpdateItem' , name : 'Update Pet Item' , layout : { sort : 'item.update' }, handles : ( cxt ) => { const targets = Context . getTargetsOfType ( cxt , 'petApi.pet' ) return ! ( targets == null || targets . length === 0 || targets . length > 1 ) }, appearance : ( ) => { return { name : 'Update Pet' , icon : Config . get ( 'BlueprintActions' , 'updateIcon' , 'https://storage.googleapis.com/molten-ui-assets/update-action.png' ) } }, perform : ( { context } ) => { const { reloadData } = context const target = Context . getTargetOfType ( context , 'petApi.pet' ) const actions = DataSources . getActions ( target ) Dialogs . show ( { component : UpdatePet , props : { reloadData , actions , relationship , value : target ? . data } } ) } } ) File UpdatePet.jsx import React from 'react' import { GlobalState } from '@leverege/ui-redux' import { Dialog , Toast } from '@leverege/ui-elements' import CreateEditForm from './CreateEditForm' export default function UpdatePet ( props ) { const { show , onClose , actions , value , reloadData } = props const onSubmit = async ( { value } ) => { try { await GlobalState . dispatch ( actions . update ( value ) ) Toast . success ( 'Successfully Updated Pet' ) } catch ( err ) { console . error ( err ) Toast . error ( 'Failed to Update Pet' ) } await reloadData ? .() onClose () } return ( < Dialog show = { show } onClose = { onClose } > < CreateEditForm {... props } value = { value } title = \"Update Pet\" submitText = \"Update\" onSubmit = { onSubmit } onCancel = { onClose } /> < /Dialog> ) } File CreateEditForm.jsx import React from 'react' import { Pane , Button , TextInput , NumericInput , PropertyGrid , Content } from '@leverege/ui-elements' import { TitleBar } from '@leverege/ui-plugin' import { GeoPointEditor } from '@leverege/ui-geo-elements' export default class CreateEditForm extends React . Component { constructor ( props ) { super ( props ) const { value } = props this . state = { newValue : value } } onCancel = ( evt ) => { const { onCancel , eventData } = this . props return onCancel ? .( { data : eventData , value : null , originalEvent : evt } ) } onSubmit = ( evt ) => { const { onSubmit , eventData } = this . props const { newValue } = this . state return onSubmit ? .( { data : eventData , value : newValue , originalEvent : evt } ) } onAgeChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , age : evt ? . value } } ) } onNameChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , name : evt ? . value } } ) } onPositionChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , position : evt ? . value } } ) } render () { const { value , submitText , title , titleIcon } = this . props const { newValue } = this . state return ( < Content relative > < Content . Header variant = \"formHeader\" > < TitleBar variant = \"dialogTitle\" title = { title } icon = { titleIcon } /> < /Content.Header> < Content . Area variant = \"formBody\" > < Pane > < PropertyGrid > < PropertyGrid . Item label = \"Name\" > < TextInput value = { newValue ? . name } onChange = { this . onNameChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Age\" > < NumericInput value = { newValue ? . age } onChange = { this . onAgeChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Position\" > < GeoPointEditor value = { newValue ? . position } onChange = { this . onPositionChange } /> < /PropertyGrid.Item> < /PropertyGrid> < /Pane> < /Content.Area> < Content . Footer variant = \"formButtons\" layout = \"flex:rowMEnd\" > < Pane layout = \"flex:rowM\" > < Button variant = \"secondary\" onClick = { this . onCancel } > Cancel < /Button> < Button disabled = { newValue === value } variant = \"primary\" onClick = { this . onSubmit } > { submitText } < /Button> < /Pane> < /Content.Footer> < /Content> ) } } Delete Action \u00b6 Plugin Delete Pet Component File DeleteAction.js import { Context , Config } from '@leverege/plugin' import { Dialogs } from '@leverege/ui-elements' import DeletePet from '../views/DeletePet' export default ( relationship , { objectType , name , namePlural } ) => { const { path , attribute } = relationship const sectionName = ` ${ name } Actions` return { id : `action. ${ path } .DeleteItem` , name : `Delete ${ namePlural } Items` , layout : { sort : 'item.zzz' , sectionName }, handles : ( cxt ) => { const targets = Context . getTargetsOfType ( cxt , objectType ) return ! ( targets == null || targets . length === 0 ) }, appearance : ( { context , action } ) => { const targets = Context . getTargetsOfType ( context , objectType ) const num = targets . length return { name : num < 2 ? `Delete ${ name } ` : `Delete ${ num } ${ namePlural } ` , icon : Config . get ( 'PetActions' , 'deleteIcon' , 'https://storage.googleapis.com/molten-ui-assets/delete-action.png' ), disabled : num === 0 } }, perform : ( { context } ) => { const { clientProps : { actions , targetKey } } = context const targets = Context . getTargetsOfType ( context , objectType ) if ( targets . length === 0 ) { return } Dialogs . show ( { component : DeletePet , props : { targets , actions , attribute , isItem : false , selectionKey : targetKey , } } ) } } } File DeletePet.jsx /* eslint-disable no-await-in-loop */ import React from 'react' import { DataSources } from '@leverege/ui-attributes' import { GlobalState , Selection } from '@leverege/ui-redux' import { Dialog , Toast } from '@leverege/ui-elements' /** * Removes the userIds from the given action. */ async function onRemove ( { data } ) { // Get parameters const { targets , selectionKey , onClose } = data const num = targets . length if ( num === 0 ) { onClose () return } // Try to remove users let success = 0 let failure = 0 let err = null for ( let n = 0 ; n < num ; n ++ ) { try { const tgt = targets [ n ] const actions = DataSources . getActions ( tgt ) await GlobalState . dispatch ( actions . delete () ) success ++ if ( selectionKey ) { GlobalState . dispatch ( Selection . remove ( selectionKey , tgt . id ) ) } } catch ( error ) { failure ++ if ( err == null ) { err = error } // eslint-disable-next-line no-console console . error ( error ) } } // Successfully removed if ( failure === 0 ) { Toast . success ( ` ${ success === 1 ? '' : num } Pet ${ num === 1 ? '' : 's' } Deleted` ) } else if ( success === 0 ) { Toast . error ( [ `Failed to Delete ${ failure === 1 ? '' : num } Pet` , err . message ] ) } else { Toast . warn ( [ `Deleted ${ success } / ${ num } Pet. Failed to delete ${ failure } .` , err . message ] ) } onClose () } /** * Remove users dialog. */ export default function DeletePet ( props ) { // Get parameters const { onClose , show , targets } = props const num = targets ? . length || 0 const title = num < 2 ? 'Pet' : ` ${ num } Pets` const button = 'Delete' const titleType = 'Delete' const extra = `This will permanently delete the ${ title } and cannot be undone.` // Render component return ( < Dialog . Question show = { show } eventData = { props } title = { ` ${ titleType } ${ title } ?` } message = { `Are you sure you want to DELETE ${ num } Pet ${ num === 1 ? '' : 's' } ? ${ extra } ` } okay = { button } okayVariant = \"primaryDestructive\" onCancel = { onClose } onOkay = { onRemove } /> ) } Setup \u00b6 File PluginSetup.js import DeleteAction from './DeleteAction' import CreateAction from './CreateAction' import UpdateAction from './UpdateAction' import Relationship from '../../../src/dataSource/Relationship' const objectType = 'petApi.pet' const name = 'Pet' const namePlural = 'Pets' exports . install = ( molten ) => { const relationship = new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' , } ) molten . addPlugin ( 'Action' , DeleteAction ( relationship , { objectType , name , namePlural } ) ) molten . addPlugin ( 'Action' , CreateAction ( relationship , { objectType , name , namePlural } ) ) molten . addPlugin ( 'Action' , UpdateAction ( relationship , { objectType , name , namePlural } ) ) }","title":"Adding CRUD Actions"},{"location":"docs/custom-data/molten-actions/#create-action","text":"Plugin Create Pet Component Shared Create/Edit Form File CreateAction.js import { Dialogs } from '@leverege/ui-elements' import { Config } from '@leverege/plugin' import CreatePet from '../views/CreatePet' // given a Relationship instance, make a create action that can be installed into molten export default relationship => ( { id : 'action.pet.CreateItem' , name : 'Create Pet Item' , layout : { sort : 'item.add' }, handles : cxt => true , appearance : ( ) => { return { name : 'Create Pet' , icon : Config . get ( 'BlueprintActions' , 'createIcon' , 'https://storage.googleapis.com/molten-ui-assets/create-action.png' ) } }, perform : ( { context } ) => { const { clientProps : { actions }, reloadData } = context Dialogs . show ( { component : CreatePet , props : { reloadData , actions , relationship } } ) } } ) File CreatePet.jsx import React from 'react' import { Dialog , Toast } from '@leverege/ui-elements' import { GlobalState } from '@leverege/ui-redux' import CreateEditForm from './CreateEditForm' export default function CreatePet ( props ) { const { show , onClose , actions , value , reloadData } = props const onSubmit = async ( { value } ) => { try { await GlobalState . dispatch ( actions . create ( value ) ) Toast . success ( 'Successfully Created Pet' ) } catch ( err ) { console . error ( err ) Toast . error ( 'Failed to Create Pet' ) } await reloadData ? .() onClose () } return ( < Dialog show = { show } onClose = { onClose } > < CreateEditForm {... props } value = { value } title = \"Create Pet\" submitText = \"Submit\" onSubmit = { onSubmit } onCancel = { onClose } /> < /Dialog> ) } File CreateEditForm.jsx import React from 'react' import { Pane , Button , TextInput , NumericInput , PropertyGrid , Content } from '@leverege/ui-elements' import { TitleBar } from '@leverege/ui-plugin' import { GeoPointEditor } from '@leverege/ui-geo-elements' export default class CreateEditForm extends React . Component { constructor ( props ) { super ( props ) const { value } = props this . state = { newValue : value } } onCancel = ( evt ) => { const { onCancel , eventData } = this . props return onCancel ? .( { data : eventData , value : null , originalEvent : evt } ) } onSubmit = ( evt ) => { const { onSubmit , eventData } = this . props const { newValue } = this . state return onSubmit ? .( { data : eventData , value : newValue , originalEvent : evt } ) } onAgeChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , age : evt ? . value } } ) } onNameChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , name : evt ? . value } } ) } onPositionChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , position : evt ? . value } } ) } render () { const { value , submitText , title , titleIcon } = this . props const { newValue } = this . state return ( < Content relative > < Content . Header variant = \"formHeader\" > < TitleBar variant = \"dialogTitle\" title = { title } icon = { titleIcon } /> < /Content.Header> < Content . Area variant = \"formBody\" > < Pane > < PropertyGrid > < PropertyGrid . Item label = \"Name\" > < TextInput value = { newValue ? . name } onChange = { this . onNameChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Age\" > < NumericInput value = { newValue ? . age } onChange = { this . onAgeChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Position\" > < GeoPointEditor value = { newValue ? . position } onChange = { this . onPositionChange } /> < /PropertyGrid.Item> < /PropertyGrid> < /Pane> < /Content.Area> < Content . Footer variant = \"formButtons\" layout = \"flex:rowMEnd\" > < Pane layout = \"flex:rowM\" > < Button variant = \"secondary\" onClick = { this . onCancel } > Cancel < /Button> < Button disabled = { newValue === value } variant = \"primary\" onClick = { this . onSubmit } > { submitText } < /Button> < /Pane> < /Content.Footer> < /Content> ) } }","title":"Create Action"},{"location":"docs/custom-data/molten-actions/#update-action","text":"Plugin Update Pet Component Shared Create/Edit Form File UpdateAction.js import { Dialogs } from '@leverege/ui-elements' import { Config , Context } from '@leverege/plugin' import { DataSources } from '@leverege/ui-attributes' import UpdatePet from '../views/UpdatePet' // given a Relationship instance, make an update action that can be installed into molten export default relationship => ( { id : 'blueprint.action.pet.UpdateItem' , name : 'Update Pet Item' , layout : { sort : 'item.update' }, handles : ( cxt ) => { const targets = Context . getTargetsOfType ( cxt , 'petApi.pet' ) return ! ( targets == null || targets . length === 0 || targets . length > 1 ) }, appearance : ( ) => { return { name : 'Update Pet' , icon : Config . get ( 'BlueprintActions' , 'updateIcon' , 'https://storage.googleapis.com/molten-ui-assets/update-action.png' ) } }, perform : ( { context } ) => { const { reloadData } = context const target = Context . getTargetOfType ( context , 'petApi.pet' ) const actions = DataSources . getActions ( target ) Dialogs . show ( { component : UpdatePet , props : { reloadData , actions , relationship , value : target ? . data } } ) } } ) File UpdatePet.jsx import React from 'react' import { GlobalState } from '@leverege/ui-redux' import { Dialog , Toast } from '@leverege/ui-elements' import CreateEditForm from './CreateEditForm' export default function UpdatePet ( props ) { const { show , onClose , actions , value , reloadData } = props const onSubmit = async ( { value } ) => { try { await GlobalState . dispatch ( actions . update ( value ) ) Toast . success ( 'Successfully Updated Pet' ) } catch ( err ) { console . error ( err ) Toast . error ( 'Failed to Update Pet' ) } await reloadData ? .() onClose () } return ( < Dialog show = { show } onClose = { onClose } > < CreateEditForm {... props } value = { value } title = \"Update Pet\" submitText = \"Update\" onSubmit = { onSubmit } onCancel = { onClose } /> < /Dialog> ) } File CreateEditForm.jsx import React from 'react' import { Pane , Button , TextInput , NumericInput , PropertyGrid , Content } from '@leverege/ui-elements' import { TitleBar } from '@leverege/ui-plugin' import { GeoPointEditor } from '@leverege/ui-geo-elements' export default class CreateEditForm extends React . Component { constructor ( props ) { super ( props ) const { value } = props this . state = { newValue : value } } onCancel = ( evt ) => { const { onCancel , eventData } = this . props return onCancel ? .( { data : eventData , value : null , originalEvent : evt } ) } onSubmit = ( evt ) => { const { onSubmit , eventData } = this . props const { newValue } = this . state return onSubmit ? .( { data : eventData , value : newValue , originalEvent : evt } ) } onAgeChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , age : evt ? . value } } ) } onNameChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , name : evt ? . value } } ) } onPositionChange = ( evt ) => { const { newValue } = this . state this . setState ( { newValue : { ... newValue , position : evt ? . value } } ) } render () { const { value , submitText , title , titleIcon } = this . props const { newValue } = this . state return ( < Content relative > < Content . Header variant = \"formHeader\" > < TitleBar variant = \"dialogTitle\" title = { title } icon = { titleIcon } /> < /Content.Header> < Content . Area variant = \"formBody\" > < Pane > < PropertyGrid > < PropertyGrid . Item label = \"Name\" > < TextInput value = { newValue ? . name } onChange = { this . onNameChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Age\" > < NumericInput value = { newValue ? . age } onChange = { this . onAgeChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Position\" > < GeoPointEditor value = { newValue ? . position } onChange = { this . onPositionChange } /> < /PropertyGrid.Item> < /PropertyGrid> < /Pane> < /Content.Area> < Content . Footer variant = \"formButtons\" layout = \"flex:rowMEnd\" > < Pane layout = \"flex:rowM\" > < Button variant = \"secondary\" onClick = { this . onCancel } > Cancel < /Button> < Button disabled = { newValue === value } variant = \"primary\" onClick = { this . onSubmit } > { submitText } < /Button> < /Pane> < /Content.Footer> < /Content> ) } }","title":"Update Action"},{"location":"docs/custom-data/molten-actions/#delete-action","text":"Plugin Delete Pet Component File DeleteAction.js import { Context , Config } from '@leverege/plugin' import { Dialogs } from '@leverege/ui-elements' import DeletePet from '../views/DeletePet' export default ( relationship , { objectType , name , namePlural } ) => { const { path , attribute } = relationship const sectionName = ` ${ name } Actions` return { id : `action. ${ path } .DeleteItem` , name : `Delete ${ namePlural } Items` , layout : { sort : 'item.zzz' , sectionName }, handles : ( cxt ) => { const targets = Context . getTargetsOfType ( cxt , objectType ) return ! ( targets == null || targets . length === 0 ) }, appearance : ( { context , action } ) => { const targets = Context . getTargetsOfType ( context , objectType ) const num = targets . length return { name : num < 2 ? `Delete ${ name } ` : `Delete ${ num } ${ namePlural } ` , icon : Config . get ( 'PetActions' , 'deleteIcon' , 'https://storage.googleapis.com/molten-ui-assets/delete-action.png' ), disabled : num === 0 } }, perform : ( { context } ) => { const { clientProps : { actions , targetKey } } = context const targets = Context . getTargetsOfType ( context , objectType ) if ( targets . length === 0 ) { return } Dialogs . show ( { component : DeletePet , props : { targets , actions , attribute , isItem : false , selectionKey : targetKey , } } ) } } } File DeletePet.jsx /* eslint-disable no-await-in-loop */ import React from 'react' import { DataSources } from '@leverege/ui-attributes' import { GlobalState , Selection } from '@leverege/ui-redux' import { Dialog , Toast } from '@leverege/ui-elements' /** * Removes the userIds from the given action. */ async function onRemove ( { data } ) { // Get parameters const { targets , selectionKey , onClose } = data const num = targets . length if ( num === 0 ) { onClose () return } // Try to remove users let success = 0 let failure = 0 let err = null for ( let n = 0 ; n < num ; n ++ ) { try { const tgt = targets [ n ] const actions = DataSources . getActions ( tgt ) await GlobalState . dispatch ( actions . delete () ) success ++ if ( selectionKey ) { GlobalState . dispatch ( Selection . remove ( selectionKey , tgt . id ) ) } } catch ( error ) { failure ++ if ( err == null ) { err = error } // eslint-disable-next-line no-console console . error ( error ) } } // Successfully removed if ( failure === 0 ) { Toast . success ( ` ${ success === 1 ? '' : num } Pet ${ num === 1 ? '' : 's' } Deleted` ) } else if ( success === 0 ) { Toast . error ( [ `Failed to Delete ${ failure === 1 ? '' : num } Pet` , err . message ] ) } else { Toast . warn ( [ `Deleted ${ success } / ${ num } Pet. Failed to delete ${ failure } .` , err . message ] ) } onClose () } /** * Remove users dialog. */ export default function DeletePet ( props ) { // Get parameters const { onClose , show , targets } = props const num = targets ? . length || 0 const title = num < 2 ? 'Pet' : ` ${ num } Pets` const button = 'Delete' const titleType = 'Delete' const extra = `This will permanently delete the ${ title } and cannot be undone.` // Render component return ( < Dialog . Question show = { show } eventData = { props } title = { ` ${ titleType } ${ title } ?` } message = { `Are you sure you want to DELETE ${ num } Pet ${ num === 1 ? '' : 's' } ? ${ extra } ` } okay = { button } okayVariant = \"primaryDestructive\" onCancel = { onClose } onOkay = { onRemove } /> ) }","title":"Delete Action"},{"location":"docs/custom-data/molten-actions/#setup","text":"File PluginSetup.js import DeleteAction from './DeleteAction' import CreateAction from './CreateAction' import UpdateAction from './UpdateAction' import Relationship from '../../../src/dataSource/Relationship' const objectType = 'petApi.pet' const name = 'Pet' const namePlural = 'Pets' exports . install = ( molten ) => { const relationship = new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' , } ) molten . addPlugin ( 'Action' , DeleteAction ( relationship , { objectType , name , namePlural } ) ) molten . addPlugin ( 'Action' , CreateAction ( relationship , { objectType , name , namePlural } ) ) molten . addPlugin ( 'Action' , UpdateAction ( relationship , { objectType , name , namePlural } ) ) }","title":"Setup"},{"location":"docs/custom-data/routes/","text":"Once you have actions, a dataSource, and ui-attributes, the next step is to create a screen. For this example we intend to re-use the GroupScreen. Using GroupScreen \u00b6 If you've been following along so far, using the GroupScreen is easy! All of the hard work came from the implementation of your DataSource and Action classes earlier. Assuming you stuck to the interface as specified previously, all you have to do to use the GroupScreen is include it as the component in your route (seen in the next step), and pass it the right props, namely: objectType - in this case petApi.pet, but just the type you picked for you items relationship - an instance of the Relationship class from molten actions - an instance of your PetsActions class from before This will look like this: const props = { objectType : 'petApi.pet' , relationship : new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType : 'petApi.pet' , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' } ), actions : new PetsActions () } Installing the Route \u00b6 Route s are another type of plugin, and have several required keys. The Pets Screen Route plugin looks like this: { // all plugins need a unique id id : 'pets.route.PetScreen' , // what is the url of the route? This will be prefixed in the final ui // by the molten baseRoute, which may include additional information like // systemId and person path : '/pets/' , // whether or not the path has to be an exact match to render exact : true , // where in the ui the route will go. This means it // will be rendered at the route inside the Main Screen. // This is common for root level ui screens. matches : { client : 'Main' }, // what React component is rendered by the route (this is the molten GroupScreen) component : GroupScreen , // what props should be passed to the GroupScreen props : { objectType : 'petApi.pet' , relationship : new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType : 'petApi.pet' , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' } ), actions : new PetsActions () } } and is installed like so: molten . addPlugin ( 'Route' , PetRoute ) Of course without a way to get to that route in the ui, its not particularly useful! The best way to install a link to your new pet shop route is with a LinkAction, which can be created and installed like so: // this import is different when working from the molten demo folder import { LinkAction } from '@leverege/molten/lib/routes' const PetLink = LinkAction . create ( { id : 'pet.PetsLink' , matches : { use : 'navBar' , client : 'Main' }, name : 'Pets' , icon : 'fa fa-bug fa-fw' , path : '/pets' } ) molten . addPlugin ( 'Action' , PetLink )","title":"Creating a Route"},{"location":"docs/custom-data/routes/#using-groupscreen","text":"If you've been following along so far, using the GroupScreen is easy! All of the hard work came from the implementation of your DataSource and Action classes earlier. Assuming you stuck to the interface as specified previously, all you have to do to use the GroupScreen is include it as the component in your route (seen in the next step), and pass it the right props, namely: objectType - in this case petApi.pet, but just the type you picked for you items relationship - an instance of the Relationship class from molten actions - an instance of your PetsActions class from before This will look like this: const props = { objectType : 'petApi.pet' , relationship : new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType : 'petApi.pet' , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' } ), actions : new PetsActions () }","title":"Using GroupScreen"},{"location":"docs/custom-data/routes/#installing-the-route","text":"Route s are another type of plugin, and have several required keys. The Pets Screen Route plugin looks like this: { // all plugins need a unique id id : 'pets.route.PetScreen' , // what is the url of the route? This will be prefixed in the final ui // by the molten baseRoute, which may include additional information like // systemId and person path : '/pets/' , // whether or not the path has to be an exact match to render exact : true , // where in the ui the route will go. This means it // will be rendered at the route inside the Main Screen. // This is common for root level ui screens. matches : { client : 'Main' }, // what React component is rendered by the route (this is the molten GroupScreen) component : GroupScreen , // what props should be passed to the GroupScreen props : { objectType : 'petApi.pet' , relationship : new Relationship ( { apiName : 'petApi' , name : 'pets' , objectType : 'petApi.pet' , path : 'petApi.pets' , refPath : '/pets' , urlPath : '/pets' } ), actions : new PetsActions () } } and is installed like so: molten . addPlugin ( 'Route' , PetRoute ) Of course without a way to get to that route in the ui, its not particularly useful! The best way to install a link to your new pet shop route is with a LinkAction, which can be created and installed like so: // this import is different when working from the molten demo folder import { LinkAction } from '@leverege/molten/lib/routes' const PetLink = LinkAction . create ( { id : 'pet.PetsLink' , matches : { use : 'navBar' , client : 'Main' }, name : 'Pets' , icon : 'fa fa-bug fa-fw' , path : '/pets' } ) molten . addPlugin ( 'Action' , PetLink )","title":"Installing the Route"},{"location":"docs/custom-data/search/","text":"If optionally you wish to add the ability for users to free text search your list of items (and your API supports such functionality), you can add just a couple of plugins to do so. The first thing you need to add is a SearchBar plugin, which will look something like this: SearchBar Plugin installation \u00b6 A SearchBar at its core is a DataViewer, so it's installed using that plugin type, but specifically tuned to be used as a search plugin on GroupScreen's molten . addPlugin ( 'DataViewer' , { id : 'molten.dataViewer.search.PetSearchBar' , type : 'molten.Search' , name : 'Search Bar' , icon : 'fa fa-search fa-fw' , // this is what tells the GroupScreen where to put this plugin location : [ 'search' ], // this search bar can only be used against group screens of petApi.pet's matches : { type : 'GroupDataViewer' , objectType : 'petApi.pet' }, component : SearchBar , } ) SearchBar Component \u00b6 For the ease of the pet shop demo, we opted to use the SearchBar from molten, and simply wrap it to adjust some of its props import React from 'react' import ResponsiveSearchBar from '../../../src/screens/group/search/SearchBar' export default function SearchBar ( props ) { const { objectType , path } = props const client = 'molten.group.SearchBar' // changing the use prevents Imagine API suggestions from being rendered, which would break const suggestionsMatchContext = { use : 'petApi.suggestions' , client , objectType , path } return < ResponsiveSearchBar {... props } suggestionsMatchContext = { suggestionsMatchContext } /> } Suggestions Plugin Installation \u00b6 SearchSuggesters are a specialized plugin that allows you to tack additional suggestions onto any search bar (not just the pet shop one!) molten . addPlugin ( 'SearchSuggester' , { id : 'petApi.Suggestions' , name : 'API Suggestions' , // NOTE: this use matches the use from the SearchBar component suggestionsMatchContext matches : { use : 'petApi.suggestions' , client : 'molten.group.SearchBar' }, handles : () => true , // could be useful for storing recent searches onSearchChange : ( { search } ) => {}, suggestions : Suggestions } ) Suggestions Component \u00b6 This component as a note is very similar to the ApiSuggestions in the molten library, but with some changes to make it work with the pet shop example. Get Suggestions Function \u00b6 import { GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' import Path from '@leverege/path' import { Config } from '@leverege/plugin' import Model from '../../../src/screens/group/search/filter/GroupedTextFilterModel' const getSuggestions = async ( actions , filter , search , objectType , api ) => { const f = filter const res = await GlobalState . dispatch ( actions . search ( { filter : f ? { ... f , value : Model . toImagineValue ( search , filter , objectType ) } : null , limit : 100 }, { queryName : 'searchSuggestions' } ) ) const items = {} const toCheck = Model . getLastToken ( search ). toLowerCase () if ( f ? . fields && f . fields . length > 0 ) { f . fields . forEach ( ( field ) => { let accessor = () => null if ( typeof field === 'string' ) { accessor = Path ( field ) } else if ( typeof field === 'object' && field ? . field ) { accessor = Path ( field . field ) } res ? . items . forEach ( ( i ) => { const val = accessor . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck ) ) { items [ val ] = true } } ) } ) } else { const attrs = Attributes . getAttributesFor ( objectType ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . items . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck ) ) { items [ val ] = true } } ) } ) } return Object . keys ( items ) } const updateSuggestions = ( opts ) => { const { actions , filterModel , search , objectType } = opts const filter = Model . toImagineFilter ( filterModel , objectType ) if ( ! search || Model . getLastToken ( search ). length < Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 ) ) { opts . setItems ( [] ) return Promise . resolve ( [] ) } // do this so we can get at the raw api object and not touch api-redux return new Promise ( ( resolve ) => { process . nextTick ( GlobalState . dispatch , async ( dispatch , getState , { api } ) => { const items = await getSuggestions ( actions , filter , search , objectType , api ) opts . setItems ( items ) resolve ( items ) } ) } ) } export { updateSuggestions , getSuggestions } Suggestion Component \u00b6 import React from 'react' import Suggestion from '../../../src/screens/group/search/suggestions/Suggestion' // an individual suggestion export default function PetSuggestion ( props ) { const { item , search } = props const match = item ? . toLowerCase (). lastIndexOf ( search ? . toLowerCase () ) if ( ! item || match < 0 || item ? . toLowerCase () === search ? . toLowerCase () || search ? . toLowerCase (). endsWith ( item ? . toLowerCase () ) ) { return null } const contents = ( <> { item . slice ( 0 , match )} < b > { item . slice ( match , match + search . length )} < /b> { item . slice ( match + search . length )} < /> ) return ( < Suggestion {... props } newSearch = { item } contents = { contents } /> ) } Suggestions Component \u00b6 import React from 'react' import { Config } from '@leverege/plugin' import Suggestion from './Suggestion' import Suggestions from '../../../src/screens/group/search/suggestions/Suggestions' import { updateSuggestions } from './Util' const searchLongEnough = ( search ) => { return search ? . length >= Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 ) } // a list of suggestions export default function PetSuggestions ( props ) { return ( < Suggestions {... props } updateSuggestions = { updateSuggestions } searchLongEnough = { searchLongEnough } suggestionClass = { Suggestion } minSuggestionLength = { Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 )} searchDebounceMs = { Config . get ( 'ApiSuggestions' , 'searchDebounceMs' , 100 )} /> ) }","title":"Customizing Search"},{"location":"docs/custom-data/search/#searchbar-plugin-installation","text":"A SearchBar at its core is a DataViewer, so it's installed using that plugin type, but specifically tuned to be used as a search plugin on GroupScreen's molten . addPlugin ( 'DataViewer' , { id : 'molten.dataViewer.search.PetSearchBar' , type : 'molten.Search' , name : 'Search Bar' , icon : 'fa fa-search fa-fw' , // this is what tells the GroupScreen where to put this plugin location : [ 'search' ], // this search bar can only be used against group screens of petApi.pet's matches : { type : 'GroupDataViewer' , objectType : 'petApi.pet' }, component : SearchBar , } )","title":"SearchBar Plugin installation"},{"location":"docs/custom-data/search/#searchbar-component","text":"For the ease of the pet shop demo, we opted to use the SearchBar from molten, and simply wrap it to adjust some of its props import React from 'react' import ResponsiveSearchBar from '../../../src/screens/group/search/SearchBar' export default function SearchBar ( props ) { const { objectType , path } = props const client = 'molten.group.SearchBar' // changing the use prevents Imagine API suggestions from being rendered, which would break const suggestionsMatchContext = { use : 'petApi.suggestions' , client , objectType , path } return < ResponsiveSearchBar {... props } suggestionsMatchContext = { suggestionsMatchContext } /> }","title":"SearchBar Component"},{"location":"docs/custom-data/search/#suggestions-plugin-installation","text":"SearchSuggesters are a specialized plugin that allows you to tack additional suggestions onto any search bar (not just the pet shop one!) molten . addPlugin ( 'SearchSuggester' , { id : 'petApi.Suggestions' , name : 'API Suggestions' , // NOTE: this use matches the use from the SearchBar component suggestionsMatchContext matches : { use : 'petApi.suggestions' , client : 'molten.group.SearchBar' }, handles : () => true , // could be useful for storing recent searches onSearchChange : ( { search } ) => {}, suggestions : Suggestions } )","title":"Suggestions Plugin Installation"},{"location":"docs/custom-data/search/#suggestions-component","text":"This component as a note is very similar to the ApiSuggestions in the molten library, but with some changes to make it work with the pet shop example.","title":"Suggestions Component"},{"location":"docs/custom-data/search/#get-suggestions-function","text":"import { GlobalState } from '@leverege/ui-redux' import { Attributes } from '@leverege/ui-attributes' import Path from '@leverege/path' import { Config } from '@leverege/plugin' import Model from '../../../src/screens/group/search/filter/GroupedTextFilterModel' const getSuggestions = async ( actions , filter , search , objectType , api ) => { const f = filter const res = await GlobalState . dispatch ( actions . search ( { filter : f ? { ... f , value : Model . toImagineValue ( search , filter , objectType ) } : null , limit : 100 }, { queryName : 'searchSuggestions' } ) ) const items = {} const toCheck = Model . getLastToken ( search ). toLowerCase () if ( f ? . fields && f . fields . length > 0 ) { f . fields . forEach ( ( field ) => { let accessor = () => null if ( typeof field === 'string' ) { accessor = Path ( field ) } else if ( typeof field === 'object' && field ? . field ) { accessor = Path ( field . field ) } res ? . items . forEach ( ( i ) => { const val = accessor . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck ) ) { items [ val ] = true } } ) } ) } else { const attrs = Attributes . getAttributesFor ( objectType ) attrs . forEach ( ( attr ) => { if ( attr . valueType !== 'string' ) { return } res ? . items . forEach ( ( i ) => { const val = attr . get ( i ) if ( typeof val === 'string' && val . toLowerCase (). includes ( toCheck ) ) { items [ val ] = true } } ) } ) } return Object . keys ( items ) } const updateSuggestions = ( opts ) => { const { actions , filterModel , search , objectType } = opts const filter = Model . toImagineFilter ( filterModel , objectType ) if ( ! search || Model . getLastToken ( search ). length < Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 ) ) { opts . setItems ( [] ) return Promise . resolve ( [] ) } // do this so we can get at the raw api object and not touch api-redux return new Promise ( ( resolve ) => { process . nextTick ( GlobalState . dispatch , async ( dispatch , getState , { api } ) => { const items = await getSuggestions ( actions , filter , search , objectType , api ) opts . setItems ( items ) resolve ( items ) } ) } ) } export { updateSuggestions , getSuggestions }","title":"Get Suggestions Function"},{"location":"docs/custom-data/search/#suggestion-component","text":"import React from 'react' import Suggestion from '../../../src/screens/group/search/suggestions/Suggestion' // an individual suggestion export default function PetSuggestion ( props ) { const { item , search } = props const match = item ? . toLowerCase (). lastIndexOf ( search ? . toLowerCase () ) if ( ! item || match < 0 || item ? . toLowerCase () === search ? . toLowerCase () || search ? . toLowerCase (). endsWith ( item ? . toLowerCase () ) ) { return null } const contents = ( <> { item . slice ( 0 , match )} < b > { item . slice ( match , match + search . length )} < /b> { item . slice ( match + search . length )} < /> ) return ( < Suggestion {... props } newSearch = { item } contents = { contents } /> ) }","title":"Suggestion Component"},{"location":"docs/custom-data/search/#suggestions-component_1","text":"import React from 'react' import { Config } from '@leverege/plugin' import Suggestion from './Suggestion' import Suggestions from '../../../src/screens/group/search/suggestions/Suggestions' import { updateSuggestions } from './Util' const searchLongEnough = ( search ) => { return search ? . length >= Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 ) } // a list of suggestions export default function PetSuggestions ( props ) { return ( < Suggestions {... props } updateSuggestions = { updateSuggestions } searchLongEnough = { searchLongEnough } suggestionClass = { Suggestion } minSuggestionLength = { Config . get ( 'ApiSuggestions' , 'minSuggestionLength' , 3 )} searchDebounceMs = { Config . get ( 'ApiSuggestions' , 'searchDebounceMs' , 100 )} /> ) }","title":"Suggestions Component"},{"location":"docs/data-sources/","text":"Data Sources \u00b6 The purpose of a DataSource plugin is to provide a mechanism by which molten can access data about and acquire \"actions\" against a particular type of object. Data Sources themselves are a @leverege/ui-attributes concept, and more information can be found about them here An example of a fleshed out DataSource class can be found at src/blueprints/dataSource/BlueprintDataSource.js or demo/pets/dataSource/PetDataSource.js","title":"Data Sources"},{"location":"docs/data-sources/#data-sources","text":"The purpose of a DataSource plugin is to provide a mechanism by which molten can access data about and acquire \"actions\" against a particular type of object. Data Sources themselves are a @leverege/ui-attributes concept, and more information can be found about them here An example of a fleshed out DataSource class can be found at src/blueprints/dataSource/BlueprintDataSource.js or demo/pets/dataSource/PetDataSource.js","title":"Data Sources"},{"location":"docs/data-viewers/","text":"Data Viewers \u00b6 Danger This is outdated Data Viewers are widgets that are mean to display pieces of information about a common set of data. Usually, this common data is either a list of items (via GroupScreen ) or a single item (via ItemInfoScreen ). The top level controller that manages dataViewers will load the data as needed, but the DataViewers can have some control to effect which data is loaded. In the GroupScreen usage, data viewers are given a filters object by which they can contribute filters. Location \u00b6 DataViewers are presented in a Layout. The root Layout consists of two main sections and four surrounding auxilary sections ( top, bottom, left, right ). These sections are fixed to the screen current screen size, meaning that they do now scroll off the screen: the top is fixed to the top of the area, the bottom to the bottom, left and right to the sides, and the remaining section is divided amoungst the two main sections. Any one of these sections can be null, in which case their space is given to the appropriate section. Within these sections, a Dashboard layout can be created to construct a screen where there are a lot of DataViewers. The dashboard will scroll within its area. A DataViewer can indicate which of this locations they are usable in by specifying an array containing main , aux , or card in their location field. There are also Hidden DataViewers, whose purpose is to load or prepare other data. It should be a viewless component, meaning its render function returns null. Support DataViewers also exist, and implement the same interface. They are meant to be used by other DataViewers and not directly selected for use. To specify a hidden or support DataViewer, set location to be hidden or support . Group Screen \u00b6 Group Data Viewers \u00b6 GroupDataViewers are controlled and organized by the GroupScreen. They will receive the current data, pagination information, filtering information and various keys to help them organize themselves. They can also contribute filters and sort values back to the overall group. Installing \u00b6 To install a plugin, use the following: // Plugins.add( 'GroupDataViewer', ... ) can also be used molten . addPlugin ( 'GroupDataViewer' , { id , type : 'table' , icon : 'fa fa-list fa-fw' , name : 'Table View' , location : 'aux|main|any' , // null => main. Array is also allowed handles : ( relationship ) => { return true } component , createSettings , updateSettings , props : { mode : 1 } } ) Prop Type Description id string The unique plugin id type string The unique type of the DataViewer. icon string The url or font icon class name of the image used to represent the icon. name string The human readable name of the plugin location string Where the DataViewer is usable. primary means only the main sections, where they components must fill 100% of width and height. aux means only the header sections, where based on the vertical prop, the component should take up 100% of width or height, but not both. The other axis should be limited (and relatively small). This is meant for aggregations, rollups, extra command bars, etc. If left null, this will mean primary . If a component can be both, any can be specified. The value of the vertical prop will be undefined when it is used in a primary capacity. handles function A function that takes a relationship object and returns true if the DataViewer can function with the data. component React A react component props object An options object that will be given to the component Props \u00b6 The GroupScreen will supply the following as props to each DataViewers Prop Type Description dispatch object The redux dispatch match object The connected react router match object location object The connected react router location object history object The connected react router history object profile object The current users profile objectType string The object type, which is the blueprint's alias or id data object The current data. The data.items maybe sparce if multiple non-sequential pages have been loaded. Use the pagination to access a single page. The values in data are relationship object The relationship object for current viewed group of data actons object An object used to request creations, delections, etc from the server. The actions should be dispatched. filter object The FilterSourceModel contributed by this data screen filterName string The name of the FilterSourceModel in the FilterSourcesModel. This should be supplied as the 'data' filed in the onFilterChange() event. onFilterChange function Invoke this when the data screen wishes to change its contribution to the filter and sort. The argument should be an event contining filters object The FilterSourcesModel selectionKey string The key used with Selections to manage objects that are selected rolloverKey string The key used with Selections to manage objects that are rolled over targetKey string The key used with Selections to manage objects that are targeted settingsPath string The path used with UserSettings to save data. paginator object The object used to manage pagination. vertical boolean If the DataViewer is used in a header/footer capacity, this will indicate the direction the component will be layed out. This is undefined for primary DataViewers. Hidden Group Screen Viewers \u00b6 Occasionally it is useful to have a group screen viewer installed at a path which does not render any visible UI but which still has the ability to contribute things like filters to the group screen. This can be accomplished by registering a GroupDataViewer with the location of 'hidden'. You can also add a 'matches' property to this plugin which will allow you to only render your hidden viewer for certain paths,object types, etc. The name and icon properties of the GroupDataViewer become unnecessary in this context. NOTE: As a matter of convention, your hidden component should return null from its function body or render method. However, your component will also be wrapped in a display: none; div and will not be visible For example: molten.addPlugin( 'GroupDataViewer', { type : 'ghost', location : 'hidden', matches : { objectType : 'cow' }, handles : () => true, component : HiddenTest, props : { dude : 'Sweet!' } } ) This plugin will render for all pages with objectType === 'cow' and will be passed its own set of filters, etc which it can use to contribute to the group screen. see demo/dataViewer/PluginSetup.js for a working example","title":"Data Viewers"},{"location":"docs/data-viewers/#data-viewers","text":"Danger This is outdated Data Viewers are widgets that are mean to display pieces of information about a common set of data. Usually, this common data is either a list of items (via GroupScreen ) or a single item (via ItemInfoScreen ). The top level controller that manages dataViewers will load the data as needed, but the DataViewers can have some control to effect which data is loaded. In the GroupScreen usage, data viewers are given a filters object by which they can contribute filters.","title":"Data Viewers"},{"location":"docs/data-viewers/#location","text":"DataViewers are presented in a Layout. The root Layout consists of two main sections and four surrounding auxilary sections ( top, bottom, left, right ). These sections are fixed to the screen current screen size, meaning that they do now scroll off the screen: the top is fixed to the top of the area, the bottom to the bottom, left and right to the sides, and the remaining section is divided amoungst the two main sections. Any one of these sections can be null, in which case their space is given to the appropriate section. Within these sections, a Dashboard layout can be created to construct a screen where there are a lot of DataViewers. The dashboard will scroll within its area. A DataViewer can indicate which of this locations they are usable in by specifying an array containing main , aux , or card in their location field. There are also Hidden DataViewers, whose purpose is to load or prepare other data. It should be a viewless component, meaning its render function returns null. Support DataViewers also exist, and implement the same interface. They are meant to be used by other DataViewers and not directly selected for use. To specify a hidden or support DataViewer, set location to be hidden or support .","title":"Location"},{"location":"docs/data-viewers/#group-screen","text":"","title":"Group Screen"},{"location":"docs/data-viewers/#group-data-viewers","text":"GroupDataViewers are controlled and organized by the GroupScreen. They will receive the current data, pagination information, filtering information and various keys to help them organize themselves. They can also contribute filters and sort values back to the overall group.","title":"Group Data Viewers"},{"location":"docs/data-viewers/#installing","text":"To install a plugin, use the following: // Plugins.add( 'GroupDataViewer', ... ) can also be used molten . addPlugin ( 'GroupDataViewer' , { id , type : 'table' , icon : 'fa fa-list fa-fw' , name : 'Table View' , location : 'aux|main|any' , // null => main. Array is also allowed handles : ( relationship ) => { return true } component , createSettings , updateSettings , props : { mode : 1 } } ) Prop Type Description id string The unique plugin id type string The unique type of the DataViewer. icon string The url or font icon class name of the image used to represent the icon. name string The human readable name of the plugin location string Where the DataViewer is usable. primary means only the main sections, where they components must fill 100% of width and height. aux means only the header sections, where based on the vertical prop, the component should take up 100% of width or height, but not both. The other axis should be limited (and relatively small). This is meant for aggregations, rollups, extra command bars, etc. If left null, this will mean primary . If a component can be both, any can be specified. The value of the vertical prop will be undefined when it is used in a primary capacity. handles function A function that takes a relationship object and returns true if the DataViewer can function with the data. component React A react component props object An options object that will be given to the component","title":"Installing"},{"location":"docs/data-viewers/#props","text":"The GroupScreen will supply the following as props to each DataViewers Prop Type Description dispatch object The redux dispatch match object The connected react router match object location object The connected react router location object history object The connected react router history object profile object The current users profile objectType string The object type, which is the blueprint's alias or id data object The current data. The data.items maybe sparce if multiple non-sequential pages have been loaded. Use the pagination to access a single page. The values in data are relationship object The relationship object for current viewed group of data actons object An object used to request creations, delections, etc from the server. The actions should be dispatched. filter object The FilterSourceModel contributed by this data screen filterName string The name of the FilterSourceModel in the FilterSourcesModel. This should be supplied as the 'data' filed in the onFilterChange() event. onFilterChange function Invoke this when the data screen wishes to change its contribution to the filter and sort. The argument should be an event contining filters object The FilterSourcesModel selectionKey string The key used with Selections to manage objects that are selected rolloverKey string The key used with Selections to manage objects that are rolled over targetKey string The key used with Selections to manage objects that are targeted settingsPath string The path used with UserSettings to save data. paginator object The object used to manage pagination. vertical boolean If the DataViewer is used in a header/footer capacity, this will indicate the direction the component will be layed out. This is undefined for primary DataViewers.","title":"Props"},{"location":"docs/data-viewers/#hidden-group-screen-viewers","text":"Occasionally it is useful to have a group screen viewer installed at a path which does not render any visible UI but which still has the ability to contribute things like filters to the group screen. This can be accomplished by registering a GroupDataViewer with the location of 'hidden'. You can also add a 'matches' property to this plugin which will allow you to only render your hidden viewer for certain paths,object types, etc. The name and icon properties of the GroupDataViewer become unnecessary in this context. NOTE: As a matter of convention, your hidden component should return null from its function body or render method. However, your component will also be wrapped in a display: none; div and will not be visible For example: molten.addPlugin( 'GroupDataViewer', { type : 'ghost', location : 'hidden', matches : { objectType : 'cow' }, handles : () => true, component : HiddenTest, props : { dude : 'Sweet!' } } ) This plugin will render for all pages with objectType === 'cow' and will be passed its own set of filters, etc which it can use to contribute to the group screen. see demo/dataViewer/PluginSetup.js for a working example","title":"Hidden Group Screen Viewers"},{"location":"docs/graphs/","text":"Graphs and Charts \u00b6 Graphs are a type of plugin that allow a user to visualize various attributes (both attributes of devices and attributes derived from devices, like aggregations). Graphs are broken into types (the first and presently the only of which is XYChart ) and within each type, there are various plugin points that a allow a developer to customize the look and feel of their graph or chart.","title":"Graphs and Charts"},{"location":"docs/graphs/#graphs-and-charts","text":"Graphs are a type of plugin that allow a user to visualize various attributes (both attributes of devices and attributes derived from devices, like aggregations). Graphs are broken into types (the first and presently the only of which is XYChart ) and within each type, there are various plugin points that a allow a developer to customize the look and feel of their graph or chart.","title":"Graphs and Charts"},{"location":"docs/graphs/getting-started/","text":"Getting Started \u00b6 First, install the ui-attributes-graphs library: npm i @leverege/ui-attributes-graphs Next, define UI Attributes for the data that you are hoping to graph. For instance, the below example defines three attributes for a fictious 'test.history' data type. If you are using Molten, you may already have a number of UI Attributes defined for you based on your Imagine project's blueprints: Plugins . add ( 'Attribute' , { name : 'name' , displayName : 'Name' , valueType : 'string' , objectType : 'test.history' , placement : { group : [ ] }, get : ( obj ) => { return obj ? . name } } ) Plugins . add ( 'Attribute' , { name : 'test.history.time' , displayName : 'Time' , valueType : 'timestamp' , objectType : 'test.history' , placement : { group : [ ] }, get : ( obj ) => { const time = obj && obj . time return time == null ? null : new Date ( time ) } } ) Plugins . add ( 'Attribute' , { name : 'test.history.temperature' , displayName : 'Temperature' , valueType : 'temperature' , objectType : 'test.history' , baseUnit : 'degC' , placement : { group : [ ] }, get : ( obj ) => { const temp = obj ? . data ? . temperature return temp == null ? null : { type : 'temperature' , value : temp , unit : 'degC' } } } ) In this case, time and temperature will be the two data points that we will be graphing against one another. Name is (in this case) a unique identifier for the objects that these data represent and will be used to key the data into series to facilitate graphing. Using the useSeriesData hook or the withSeriesData HOC exported by this library, prepare your data for graphing. The hook/HOC expect to be passed an array of data that you want to be graphed, an attribute name that will be used to chunk that data, and an options object with possible properties of obejctType and sortAttribute. The hook/HOC will tarnsform and memoize this data into an object keyed on the values of the chunk attribute that you have passed. If you pass an objectType in the options, it will be used to help disambiguate the chunk and sort attributes rather than using the first attribute registered with that particular name. If you pass a sortAttribute in the options, it will be used to sort the data in your series. Example \u00b6 const dataArray = [ { \"type\": \"test.history\", \"id\": \"1\", \"data\": { \"time\": 1642444110759, \"name\": \"Device 1\", \"data\": { \"temperature\": 45.7891 } } }, { \"type\": \"test.history\", \"id\": \"2\", \"data\": { \"time\": 1642461033498, \"name\": \"Device 1\", \"data\": { \"temperature\": 40.7705 } } }, { \"type\": \"test.history\", \"id\": \"3\", \"data\": { \"time\": 1642411955689, \"name\": \"Device 1\", \"data\": { \"temperature\": 48.7092 } } }, { \"type\": \"test.history\", \"id\": \"7\", \"data\": { \"time\": 1642474048199, \"name\": \"Device 2\", \"data\": { \"temperature\": 12.299 } } }, { \"type\": \"test.history\", \"id\": \"8\", \"data\": { \"time\": 1642407220379, \"name\": \"Device 2\", \"data\": { \"temperature\": 5.4862 } } }, { \"type\": \"test.history\", \"id\": \"9\", \"data\": { \"time\": 1642478679300, \"name\": \"Device 2\", \"data\": { \"temperature\": 4.5652 } } } ] const seriesData = useSeriesData( dataArray, 'name', { sortAttribute : 'test.time' } ) /* seriesData => { \"Device 2\": [ { \"type\": \"test.history\", \"id\": \"8\", \"data\": { \"time\": 1642407220379, \"name\": \"Device 2\", \"data\": { \"temperature\": 5.4862 } } }, { \"type\": \"test.history\", \"id\": \"7\", \"data\": { \"time\": 1642474048199, \"name\": \"Device 2\", \"data\": { \"temperature\": 12.299 } } }, { \"type\": \"test.history\", \"id\": \"9\", \"data\": { \"time\": 1642478679300, \"name\": \"Device 2\", \"data\": { \"temperature\": 4.5652 } } } ], \"Device 1\": [ { \"type\": \"test.history\", \"id\": \"3\", \"data\": { \"time\": 1642411955689, \"name\": \"Device 1\", \"data\": { \"temperature\": 48.7092 } } }, { \"type\": \"test.history\", \"id\": \"1\", \"data\": { \"time\": 1642444110759, \"name\": \"Device 1\", \"data\": { \"temperature\": 45.7891 } } }, { \"type\": \"test.history\", \"id\": \"2\", \"data\": { \"time\": 1642461033498, \"name\": \"Device 1\", \"data\": { \"temperature\": 40.7705 } } } ] } */ This hook/HOC will format your data into series in a manner that can be used by the ui-attributes-graphs library and will memoize the data to prevent unnecessary re-renders. If you can't use the hook/HOC because of the complexity of your data or formatting needs, a normal object keyed on some unique property will work fine, just remember to memoize the data yourself. Now simply pass this data, a Model for your chart and the objectType for your data (in the above example, this would be 'test.history') to a chart renderer and watch as your data is graphed in stunning color. import { XYChartModel , XYChartRenderer , useSeriesData } from '@leverege/ui-attributes-graphs' const [ model , setModel ] = useState ( XYChartModel . create () ) const seriesData = useSeriesData ( myUnformattedData , 'name' , { sortAttribute : 'test.time' } ) return ( < XYChartRenderer data = { seriesData } objectType = \"test.history\" model = { model } /> )","title":"Getting Started"},{"location":"docs/graphs/getting-started/#getting-started","text":"First, install the ui-attributes-graphs library: npm i @leverege/ui-attributes-graphs Next, define UI Attributes for the data that you are hoping to graph. For instance, the below example defines three attributes for a fictious 'test.history' data type. If you are using Molten, you may already have a number of UI Attributes defined for you based on your Imagine project's blueprints: Plugins . add ( 'Attribute' , { name : 'name' , displayName : 'Name' , valueType : 'string' , objectType : 'test.history' , placement : { group : [ ] }, get : ( obj ) => { return obj ? . name } } ) Plugins . add ( 'Attribute' , { name : 'test.history.time' , displayName : 'Time' , valueType : 'timestamp' , objectType : 'test.history' , placement : { group : [ ] }, get : ( obj ) => { const time = obj && obj . time return time == null ? null : new Date ( time ) } } ) Plugins . add ( 'Attribute' , { name : 'test.history.temperature' , displayName : 'Temperature' , valueType : 'temperature' , objectType : 'test.history' , baseUnit : 'degC' , placement : { group : [ ] }, get : ( obj ) => { const temp = obj ? . data ? . temperature return temp == null ? null : { type : 'temperature' , value : temp , unit : 'degC' } } } ) In this case, time and temperature will be the two data points that we will be graphing against one another. Name is (in this case) a unique identifier for the objects that these data represent and will be used to key the data into series to facilitate graphing. Using the useSeriesData hook or the withSeriesData HOC exported by this library, prepare your data for graphing. The hook/HOC expect to be passed an array of data that you want to be graphed, an attribute name that will be used to chunk that data, and an options object with possible properties of obejctType and sortAttribute. The hook/HOC will tarnsform and memoize this data into an object keyed on the values of the chunk attribute that you have passed. If you pass an objectType in the options, it will be used to help disambiguate the chunk and sort attributes rather than using the first attribute registered with that particular name. If you pass a sortAttribute in the options, it will be used to sort the data in your series.","title":"Getting Started"},{"location":"docs/graphs/getting-started/#example","text":"const dataArray = [ { \"type\": \"test.history\", \"id\": \"1\", \"data\": { \"time\": 1642444110759, \"name\": \"Device 1\", \"data\": { \"temperature\": 45.7891 } } }, { \"type\": \"test.history\", \"id\": \"2\", \"data\": { \"time\": 1642461033498, \"name\": \"Device 1\", \"data\": { \"temperature\": 40.7705 } } }, { \"type\": \"test.history\", \"id\": \"3\", \"data\": { \"time\": 1642411955689, \"name\": \"Device 1\", \"data\": { \"temperature\": 48.7092 } } }, { \"type\": \"test.history\", \"id\": \"7\", \"data\": { \"time\": 1642474048199, \"name\": \"Device 2\", \"data\": { \"temperature\": 12.299 } } }, { \"type\": \"test.history\", \"id\": \"8\", \"data\": { \"time\": 1642407220379, \"name\": \"Device 2\", \"data\": { \"temperature\": 5.4862 } } }, { \"type\": \"test.history\", \"id\": \"9\", \"data\": { \"time\": 1642478679300, \"name\": \"Device 2\", \"data\": { \"temperature\": 4.5652 } } } ] const seriesData = useSeriesData( dataArray, 'name', { sortAttribute : 'test.time' } ) /* seriesData => { \"Device 2\": [ { \"type\": \"test.history\", \"id\": \"8\", \"data\": { \"time\": 1642407220379, \"name\": \"Device 2\", \"data\": { \"temperature\": 5.4862 } } }, { \"type\": \"test.history\", \"id\": \"7\", \"data\": { \"time\": 1642474048199, \"name\": \"Device 2\", \"data\": { \"temperature\": 12.299 } } }, { \"type\": \"test.history\", \"id\": \"9\", \"data\": { \"time\": 1642478679300, \"name\": \"Device 2\", \"data\": { \"temperature\": 4.5652 } } } ], \"Device 1\": [ { \"type\": \"test.history\", \"id\": \"3\", \"data\": { \"time\": 1642411955689, \"name\": \"Device 1\", \"data\": { \"temperature\": 48.7092 } } }, { \"type\": \"test.history\", \"id\": \"1\", \"data\": { \"time\": 1642444110759, \"name\": \"Device 1\", \"data\": { \"temperature\": 45.7891 } } }, { \"type\": \"test.history\", \"id\": \"2\", \"data\": { \"time\": 1642461033498, \"name\": \"Device 1\", \"data\": { \"temperature\": 40.7705 } } } ] } */ This hook/HOC will format your data into series in a manner that can be used by the ui-attributes-graphs library and will memoize the data to prevent unnecessary re-renders. If you can't use the hook/HOC because of the complexity of your data or formatting needs, a normal object keyed on some unique property will work fine, just remember to memoize the data yourself. Now simply pass this data, a Model for your chart and the objectType for your data (in the above example, this would be 'test.history') to a chart renderer and watch as your data is graphed in stunning color. import { XYChartModel , XYChartRenderer , useSeriesData } from '@leverege/ui-attributes-graphs' const [ model , setModel ] = useState ( XYChartModel . create () ) const seriesData = useSeriesData ( myUnformattedData , 'name' , { sortAttribute : 'test.time' } ) return ( < XYChartRenderer data = { seriesData } objectType = \"test.history\" model = { model } /> )","title":"Example"},{"location":"docs/graphs/themeing/","text":"Themeing \u00b6 Themeing for UI Attributes Graphs XYChart is done through UI Builder . Here is a list of customizable values and their corresponding color variables in UI Builder: To Customize... Set this color variable in UI Builder... Series Line/Bar Color graphSeries1 - graphSeries7 Background graphBackground X-Axis Label graphXAxisLabel Y-Axis Label graphYAxisLabel X-Tick Label graphXTickLabel Y-Tick Label graphYTickLabel Threshold Line graphThreshold These values can also be overridden using custom renderer plugins, such as a Custom Graph Background Renderer or Custom Series Renderer","title":"Themeing"},{"location":"docs/graphs/themeing/#themeing","text":"Themeing for UI Attributes Graphs XYChart is done through UI Builder . Here is a list of customizable values and their corresponding color variables in UI Builder: To Customize... Set this color variable in UI Builder... Series Line/Bar Color graphSeries1 - graphSeries7 Background graphBackground X-Axis Label graphXAxisLabel Y-Axis Label graphYAxisLabel X-Tick Label graphXTickLabel Y-Tick Label graphYTickLabel Threshold Line graphThreshold These values can also be overridden using custom renderer plugins, such as a Custom Graph Background Renderer or Custom Series Renderer","title":"Themeing"},{"location":"docs/graphs/plugin-points/colorizers/","text":"Colorizers \u00b6 While Colorizers are not unique to the UI Attributes Graphs library, they can be used to control the color of both series point glpyhs in the Glyph Line series type and the glyph used by the rollover tooltip. Installing a Colorizer for a particular object type will cause a function that you define to be called when a color needs to be determined for a particular data point. This allows for conditional coloring based on object values. Take a look at this simple example for an Alert Colorizer, which changes the color of a line or rollover glpyh when a particular temperature value is surpassed: Example \u00b6 Colorizer Editor Setup File TemperatureAlertColorizer.js . import ModelUtil from '@leverege/model-util' import { Attributes } from '@leverege/ui-attributes' const TYPE = 'colorizer.test.history.Alert' export default { create () { return { type : TYPE , value : 30 , color : '#ff0000' } }, colorFor ( model , obj , context ) { const temp = Attributes . get ( 'test.history.temperature' , obj . type , obj . data ) if ( temp . value > model . value ) { return model . color } return context . seriesColor }, ... ModelUtil . createAllValue ( 'value' ), ... ModelUtil . createAllValue ( 'color' ), TYPE } File TemperatureAlertColorizerEditor.jsx . import { NumericInput , TextInput PropertyGrid } from '@leverege/ui-elements' import { useValueChange } from '@leverege/ui-hooks' import TemperatureAlertColorizer from './TemperatureAlertColorizer' export default function TemperatureAlertColorizerEditor ( props ) { const { value } = props const onModelChange = useValueChange ( TemperatureAlertColorizer , props ) return ( < PropertyGrid > < PropertyGrid . Item label = \"Alert Value\" > < NumericInput value = { TemperatureAlertColorizer . getValue ( value )} hint = \"Alert value\" float eventData = \"setValue\" onChange = { onModelChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Color\" > < TextInput value = { TemperatureAlertColorizer . getColor ( value )} hint = \"Color\" eventData = \"setColor\" onChange = { onModelChange } /> < /PropertyGrid.Item> < /PropertyGrid> ) } File PluginSetup.js . import TemperatureAlertColorizer from './TemperatureAlertColorizer' import TemperatureAlertColorizerEditor from './TemperatureAlertColorizerEditor' export default { install ( molten ) { molten . addPlugin ( 'Model' , { type : TemperatureAlertColorizer . TYPE , model : TemperatureAlertColorizer } ) molten . addPlugin ( 'ModelEditor' , { type : TemperatureAlertColorizer . TYPE , editor : TemperatureAlertColorizerEditor } ) molten . addPlugin ( 'Colorizer' , { type : TemperatureAlertColorizer . TYPE , name : 'Alert Colorizer' , colorizer : TemperatureAlertColorizer } ) } } You are encouraged to use Colorizers in your own plugins when applicable to increase potential customization by users. Tip The wonderful thing about this Colorizer is that it can be resued anywhere that a color is needed to determine an appropriate color for the object type 'test.history'. In other words, it has no special attachment to the concept of a graph and could just as easily be used to color a table cell or a dot on a map representing the same type of object. With a bit of refactoring, this Colorizer could even be made to allow the Attribute that it is checking to be set dynamically as well.","title":"Colorizers"},{"location":"docs/graphs/plugin-points/colorizers/#colorizers","text":"While Colorizers are not unique to the UI Attributes Graphs library, they can be used to control the color of both series point glpyhs in the Glyph Line series type and the glyph used by the rollover tooltip. Installing a Colorizer for a particular object type will cause a function that you define to be called when a color needs to be determined for a particular data point. This allows for conditional coloring based on object values. Take a look at this simple example for an Alert Colorizer, which changes the color of a line or rollover glpyh when a particular temperature value is surpassed:","title":"Colorizers"},{"location":"docs/graphs/plugin-points/colorizers/#example","text":"Colorizer Editor Setup File TemperatureAlertColorizer.js . import ModelUtil from '@leverege/model-util' import { Attributes } from '@leverege/ui-attributes' const TYPE = 'colorizer.test.history.Alert' export default { create () { return { type : TYPE , value : 30 , color : '#ff0000' } }, colorFor ( model , obj , context ) { const temp = Attributes . get ( 'test.history.temperature' , obj . type , obj . data ) if ( temp . value > model . value ) { return model . color } return context . seriesColor }, ... ModelUtil . createAllValue ( 'value' ), ... ModelUtil . createAllValue ( 'color' ), TYPE } File TemperatureAlertColorizerEditor.jsx . import { NumericInput , TextInput PropertyGrid } from '@leverege/ui-elements' import { useValueChange } from '@leverege/ui-hooks' import TemperatureAlertColorizer from './TemperatureAlertColorizer' export default function TemperatureAlertColorizerEditor ( props ) { const { value } = props const onModelChange = useValueChange ( TemperatureAlertColorizer , props ) return ( < PropertyGrid > < PropertyGrid . Item label = \"Alert Value\" > < NumericInput value = { TemperatureAlertColorizer . getValue ( value )} hint = \"Alert value\" float eventData = \"setValue\" onChange = { onModelChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Color\" > < TextInput value = { TemperatureAlertColorizer . getColor ( value )} hint = \"Color\" eventData = \"setColor\" onChange = { onModelChange } /> < /PropertyGrid.Item> < /PropertyGrid> ) } File PluginSetup.js . import TemperatureAlertColorizer from './TemperatureAlertColorizer' import TemperatureAlertColorizerEditor from './TemperatureAlertColorizerEditor' export default { install ( molten ) { molten . addPlugin ( 'Model' , { type : TemperatureAlertColorizer . TYPE , model : TemperatureAlertColorizer } ) molten . addPlugin ( 'ModelEditor' , { type : TemperatureAlertColorizer . TYPE , editor : TemperatureAlertColorizerEditor } ) molten . addPlugin ( 'Colorizer' , { type : TemperatureAlertColorizer . TYPE , name : 'Alert Colorizer' , colorizer : TemperatureAlertColorizer } ) } } You are encouraged to use Colorizers in your own plugins when applicable to increase potential customization by users. Tip The wonderful thing about this Colorizer is that it can be resued anywhere that a color is needed to determine an appropriate color for the object type 'test.history'. In other words, it has no special attachment to the concept of a graph and could just as easily be used to color a table cell or a dot on a map representing the same type of object. With a bit of refactoring, this Colorizer could even be made to allow the Attribute that it is checking to be set dynamically as well.","title":"Example"},{"location":"docs/graphs/plugin-points/graph-background/","text":"Graph Background \u00b6 The UI Attributes Graphs Library comes with several customizable background types that may suit your needs. Solid \u00b6 The default background for new graphs, the solid background is simply a single color covering the entire background of the graph which can be customized by the user. Striped \u00b6 A striped background gives the user options to set the background color of the graph, in addition to selecting from several defined patterns of stripes to display in the inner area of the graph (inside its margin). Options include Diagonal, Diagonal (Reverse), Diagonal (Both), Horizontal, Vertical as well as Horizontal and Vertical. The color of the stripe can also be chosen. Image \u00b6 An image background allows the user to supply an image url and various options such as size and position to place an image in the background of a graph. This is handy to add something like a company watermark to all graphs in a particular UI. Custom Backgrounds \u00b6 In order to add a custom graph background, you will need to register a Model , a Renderer and optionally (if your background is user customizable) a Model Editor . Example \u00b6 To create a Graph Background that displays one color on even days of the week and another on odd days, you would do the following: Model Editor Renderer Setup File SillyGraphBackgroundModel.js . const TYPE = 'myCustomNamespace.graph.SillyGraphBackground' function create () { return { type : TYPE , evenDayColor : 'purple' , oddDayColor : 'black' } } export default { TYPE , create , ... ModelUtil . createAllValue ( 'evenDayColor' ), ... ModelUtil . createAllValue ( 'oddDayColor' ) } File SillyGraphBackgroundEditor.jsx . ... import SillyGraphBackgroundModel from './SillyGraphBackgroundModel' export default function SillyGraphBackgroundEditor ( props ) { const { value } = props const onModelChange = useValueChange ( SillyGraphBackgroundModel , props ) return ( < Pane style = {{ '--propertyGrid-numColumns' : 1 }} > < PropertyGrid variant = \"backgroundEditor|editor\" > < PropertyGrid . Item label = \"Even Day Color\" > < TextInput value = { SillyGraphBackgroundModel . getEvenDayColor ( value )} eventData = \"setEvenDayColor\" onChange = { onModelChange } hint = \"Even Day Color\" /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Odd Day Color\" > < TextInput value = { SillyGraphBackgroundModel . getOddDayColor ( value )} eventData = \"setOddDayColor\" onChange = { onModelChange } hint = \"Odd Day Color\" /> < /PropertyGrid.Item> < /PropertyGrid> < /Pane> ) } File SillyGraphBackgroundRenderer.jsx . import { DataContext } from '@visx/xychart' import SillyGraphBackgroundModel from './SillyGraphBackgroundModel' export default function SillyGraphBackgroundRenderer ( props ) { const { model } = props const { theme , margin , width , height } = useContext ( DataContext ) const { backgroundColor } = useMemo ( () => { const day = new Date (). getDay () const isEven = day % 2 === 0 const backgroundColor = isEven ? SillyGraphBackgroundModel . getEvenColor ( model ) : SillyGraphBackgroundModel . getOddColor ( model ) return { backgroundColor : backgroundColor || theme ? . backgroundColor || '#fff' } }, [ theme ? . backgroundColor , model ] ) if ( width == null || height == null || margin == null || theme == null ) { return null } return ( < rect x = { 0 } y = { 0 } width = { width } height = { height } fill = { backgroundColor } /> ) } File PluginSetup.js . export default { install ( molten ) { molten . addPlugin ( 'GraphBackgroundModel' , { type : SillyGraphBackgroundModel . TYPE , name : 'Silly Graph Background' , model : SillyGraphBackgroundModel } ) molten . addPlugin ( 'GraphBackgroundModelEditor' , { type : SillyGraphBackgroundModel . TYPE , editor : SillyGraphBackgroundEditor } ) molten . addPlugin ( 'GraphBackgroundRenderer' , { type : SillyGraphBackgroundModel . TYPE , renderer : SillyGraphBackgroundRenderer } ) } } As you may have noticed, graph background are renderer as children of a visx XYChart component, and as such, they have access to the chart's context. This context contains helpful data, such as chart dimensions and all of the chart's data. See the documentation for @visx/xychart for more information. Tip Registering your model and editor using the 'GraphBackgroundModel' and 'GraphBackgroundModelEditor' will automatically register those plugins with the 'Model' and 'ModelEditor' plugin points, which is an important step that allows various generic model selectors and factories to know about your model and editor.","title":"Graph Background"},{"location":"docs/graphs/plugin-points/graph-background/#graph-background","text":"The UI Attributes Graphs Library comes with several customizable background types that may suit your needs.","title":"Graph Background"},{"location":"docs/graphs/plugin-points/graph-background/#solid","text":"The default background for new graphs, the solid background is simply a single color covering the entire background of the graph which can be customized by the user.","title":"Solid"},{"location":"docs/graphs/plugin-points/graph-background/#striped","text":"A striped background gives the user options to set the background color of the graph, in addition to selecting from several defined patterns of stripes to display in the inner area of the graph (inside its margin). Options include Diagonal, Diagonal (Reverse), Diagonal (Both), Horizontal, Vertical as well as Horizontal and Vertical. The color of the stripe can also be chosen.","title":"Striped"},{"location":"docs/graphs/plugin-points/graph-background/#image","text":"An image background allows the user to supply an image url and various options such as size and position to place an image in the background of a graph. This is handy to add something like a company watermark to all graphs in a particular UI.","title":"Image"},{"location":"docs/graphs/plugin-points/graph-background/#custom-backgrounds","text":"In order to add a custom graph background, you will need to register a Model , a Renderer and optionally (if your background is user customizable) a Model Editor .","title":"Custom Backgrounds"},{"location":"docs/graphs/plugin-points/graph-background/#example","text":"To create a Graph Background that displays one color on even days of the week and another on odd days, you would do the following: Model Editor Renderer Setup File SillyGraphBackgroundModel.js . const TYPE = 'myCustomNamespace.graph.SillyGraphBackground' function create () { return { type : TYPE , evenDayColor : 'purple' , oddDayColor : 'black' } } export default { TYPE , create , ... ModelUtil . createAllValue ( 'evenDayColor' ), ... ModelUtil . createAllValue ( 'oddDayColor' ) } File SillyGraphBackgroundEditor.jsx . ... import SillyGraphBackgroundModel from './SillyGraphBackgroundModel' export default function SillyGraphBackgroundEditor ( props ) { const { value } = props const onModelChange = useValueChange ( SillyGraphBackgroundModel , props ) return ( < Pane style = {{ '--propertyGrid-numColumns' : 1 }} > < PropertyGrid variant = \"backgroundEditor|editor\" > < PropertyGrid . Item label = \"Even Day Color\" > < TextInput value = { SillyGraphBackgroundModel . getEvenDayColor ( value )} eventData = \"setEvenDayColor\" onChange = { onModelChange } hint = \"Even Day Color\" /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Odd Day Color\" > < TextInput value = { SillyGraphBackgroundModel . getOddDayColor ( value )} eventData = \"setOddDayColor\" onChange = { onModelChange } hint = \"Odd Day Color\" /> < /PropertyGrid.Item> < /PropertyGrid> < /Pane> ) } File SillyGraphBackgroundRenderer.jsx . import { DataContext } from '@visx/xychart' import SillyGraphBackgroundModel from './SillyGraphBackgroundModel' export default function SillyGraphBackgroundRenderer ( props ) { const { model } = props const { theme , margin , width , height } = useContext ( DataContext ) const { backgroundColor } = useMemo ( () => { const day = new Date (). getDay () const isEven = day % 2 === 0 const backgroundColor = isEven ? SillyGraphBackgroundModel . getEvenColor ( model ) : SillyGraphBackgroundModel . getOddColor ( model ) return { backgroundColor : backgroundColor || theme ? . backgroundColor || '#fff' } }, [ theme ? . backgroundColor , model ] ) if ( width == null || height == null || margin == null || theme == null ) { return null } return ( < rect x = { 0 } y = { 0 } width = { width } height = { height } fill = { backgroundColor } /> ) } File PluginSetup.js . export default { install ( molten ) { molten . addPlugin ( 'GraphBackgroundModel' , { type : SillyGraphBackgroundModel . TYPE , name : 'Silly Graph Background' , model : SillyGraphBackgroundModel } ) molten . addPlugin ( 'GraphBackgroundModelEditor' , { type : SillyGraphBackgroundModel . TYPE , editor : SillyGraphBackgroundEditor } ) molten . addPlugin ( 'GraphBackgroundRenderer' , { type : SillyGraphBackgroundModel . TYPE , renderer : SillyGraphBackgroundRenderer } ) } } As you may have noticed, graph background are renderer as children of a visx XYChart component, and as such, they have access to the chart's context. This context contains helpful data, such as chart dimensions and all of the chart's data. See the documentation for @visx/xychart for more information. Tip Registering your model and editor using the 'GraphBackgroundModel' and 'GraphBackgroundModelEditor' will automatically register those plugins with the 'Model' and 'ModelEditor' plugin points, which is an important step that allows various generic model selectors and factories to know about your model and editor.","title":"Example"},{"location":"docs/graphs/plugin-points/model-configurer/","text":"XYChartModelConfigurer \u00b6 The XYChartModelConfigurer Plugin Point allows you to register a function which will generate the default XYChart model for a given matchContext. For instance, if you have an object type of \"vehicle\" in your application, you can register an XYChartModelConfigurer like this and it will be invoked for generating the default model for all XYCharts whose Match context includes objectType : 'vehicle' : Configurer Setup File FixedWidthXYChartModelConfigurer.js import { XYChartModel } from '@leverege/ui-attributes-graphs' export default { id : 'fixedWidth.vehicle.XYChartModelConfigurer' sort : 'aaa' , configure : ( xyChartModel , objectType , cxt ) => { let model = XYChartModel . setWidth ( xyChartModel , 500 ) model = XYChartModel . setHeight ( model , 500 ) return model } } File PluginSetup.js import FixedWidthXYChartModelConfigurer from './FixedWidthXYChartModelConfigurer' export default { install ( molten ) { molten . addPlugin ( 'XYChartModelConfigurer' , FixedWidthXYChartModelConfigurer ) } } Each XYChartModelConfigurer plugin is passed the model instance from the configurer before it and is expected to return a model instance in turn. The first configurer will recieve a freshly initialized default model (the result of XYChartModel.create() ). The order that each configurer is called in depends on the \"sort\" property of the plugin itself. Tip Molten comes with default XYChart model configurers for Imagine objects and aggregations .","title":"XYChartModelConfigurer"},{"location":"docs/graphs/plugin-points/model-configurer/#xychartmodelconfigurer","text":"The XYChartModelConfigurer Plugin Point allows you to register a function which will generate the default XYChart model for a given matchContext. For instance, if you have an object type of \"vehicle\" in your application, you can register an XYChartModelConfigurer like this and it will be invoked for generating the default model for all XYCharts whose Match context includes objectType : 'vehicle' : Configurer Setup File FixedWidthXYChartModelConfigurer.js import { XYChartModel } from '@leverege/ui-attributes-graphs' export default { id : 'fixedWidth.vehicle.XYChartModelConfigurer' sort : 'aaa' , configure : ( xyChartModel , objectType , cxt ) => { let model = XYChartModel . setWidth ( xyChartModel , 500 ) model = XYChartModel . setHeight ( model , 500 ) return model } } File PluginSetup.js import FixedWidthXYChartModelConfigurer from './FixedWidthXYChartModelConfigurer' export default { install ( molten ) { molten . addPlugin ( 'XYChartModelConfigurer' , FixedWidthXYChartModelConfigurer ) } } Each XYChartModelConfigurer plugin is passed the model instance from the configurer before it and is expected to return a model instance in turn. The first configurer will recieve a freshly initialized default model (the result of XYChartModel.create() ). The order that each configurer is called in depends on the \"sort\" property of the plugin itself. Tip Molten comes with default XYChart model configurers for Imagine objects and aggregations .","title":"XYChartModelConfigurer"},{"location":"docs/graphs/plugin-points/scale/","text":"Scale \u00b6 Graphs can be drawn using various scales to achieve different results, or to compliment different data sets. The most common scales are provided as built-in model and editor pairs, but adding a new scale type to be available for selection is also a fairly straighforward task. All scales are based on scale types available in the @visx/scale library, which are in turn based on scale types from the popular d3-scale library. The official d3-scales documetation can be consulted for information on any of the built-in types or as a reference when attempting to implement a custom type. Time Scale UTC Scale Band Scale Linear Scale To implement a new scale, add both a ScaleModel and ScaleModelEditor plugin to allow a user to customize any scale options: Model Setup File LogScaleModel.js . const TYPE = 'graph.scale.log' function create () { return { type : TYPE , visxScaleType : 'log' , ... otherOptions } } export default { create , TYPE } Scale Types Each scale model must have a property called visxScaleType which indicates the type of scale from among the available scale types found here in the @visx/scale library. File PluginSetup.js molten . addPlugin ( 'ScaleModel' , { type : LogScaleModel . TYPE , name : 'Logarithmic' , model : LogScaleModel } ) molten . addPlugin ( 'ScaleModelEditor' , { type : LogScaleModel . TYPE , editor : LogScaleModelEditor } ) Tip Adding your ScaleModel and ScaleModelEditor plugins will automatically register those plugins with the Model and ModelEditor plugin points. Scale Editor Note: Not shown above is the logarithm scale editor. You can provide an editor to allow users to set any of the available options on the particular d3-scale type you are implementing.","title":"Scale"},{"location":"docs/graphs/plugin-points/scale/#scale","text":"Graphs can be drawn using various scales to achieve different results, or to compliment different data sets. The most common scales are provided as built-in model and editor pairs, but adding a new scale type to be available for selection is also a fairly straighforward task. All scales are based on scale types available in the @visx/scale library, which are in turn based on scale types from the popular d3-scale library. The official d3-scales documetation can be consulted for information on any of the built-in types or as a reference when attempting to implement a custom type. Time Scale UTC Scale Band Scale Linear Scale To implement a new scale, add both a ScaleModel and ScaleModelEditor plugin to allow a user to customize any scale options: Model Setup File LogScaleModel.js . const TYPE = 'graph.scale.log' function create () { return { type : TYPE , visxScaleType : 'log' , ... otherOptions } } export default { create , TYPE } Scale Types Each scale model must have a property called visxScaleType which indicates the type of scale from among the available scale types found here in the @visx/scale library. File PluginSetup.js molten . addPlugin ( 'ScaleModel' , { type : LogScaleModel . TYPE , name : 'Logarithmic' , model : LogScaleModel } ) molten . addPlugin ( 'ScaleModelEditor' , { type : LogScaleModel . TYPE , editor : LogScaleModelEditor } ) Tip Adding your ScaleModel and ScaleModelEditor plugins will automatically register those plugins with the Model and ModelEditor plugin points. Scale Editor Note: Not shown above is the logarithm scale editor. You can provide an editor to allow users to set any of the available options on the particular d3-scale type you are implementing.","title":"Scale"},{"location":"docs/graphs/plugin-points/series-renderers/","text":"Series Renderers \u00b6 A series renderer is a component that displays XY series data visually. the UI Attributes Graphs library has several built-in renderers and allows you to register your own renderer if you so desire. Most of the built-in renderers are simply wrappers around the base series renderer types supported by the @visx/xychart library, but a renderer is simple a component which is given access to the DataContext of the graph (including the graph's dimensions, it's X and Y scales, and its data) and can return any valid SVG for display. Built-In Types \u00b6 Line \u00b6 A line series renderer renders series data using a line. The only option for the line series is stroke opacity. Area \u00b6 Similar to a line series, except that the area beneath the line is shaded the same color as the line's stroke. Bar \u00b6 Graphs data as a series of bars. Area Stack \u00b6 Similar to an Area graph, but data points from different series with the same x coordinate are stacked on top of each other for a cumulative effect. This graph type is only useful when all of your series data shares the same X coordinates. Bar Stack \u00b6 A bar graph where datum with the same X coordinate are stacked cumulatively on top of each other, just as in an AreaStack renderer. Bar Group \u00b6 Also only useful for data sets that share the same set of X coordinates, the Bar Group displays series of data side-by-side grouped by their X coodrinate, rather than overlapping each other or stacking as in Bar and Bar Stack. Glyph Line \u00b6 Like a line graph, but with user-customizable glyphs at each data point. Custom Series \u00b6 It is possible to create your own custom Series Renderer by registering SeriesModel, SeriesModelEditor and SeriesRender plugins for your series type. Again, a Series Renderer need only return valid svg, so any manner of visualization is possible. As an example, let's look at the Glyph Line Renderer, which is a conglomeration of LineSeries and GlyphSeries types from @visx/xychart Tip Registering your SeriesModel and SeriesModelEditor plugins will automatically register those plugins as Models and ModelEditors as well, which will make them available in UI Plugins that use the ModelFactory and ModelEditorFactory Example \u00b6 Model Editor Renderer Setup File LineGlyphModel.js . import ModelUtil from '@leverege/model-util' import DotGlyphModel from '../glyph/DotGlyphModel' const TYPE = 'graph.series.glyphLine' const name = 'Glyph Line' function create ( extend ) { return { type : TYPE , name , strokeOpacity : 1 , glyph : DotGlyphModel . create (), ... extend } } const base = { ... ModelUtil . createAllValue ( 'strokeOpacity' ), ... ModelUtil . createAllValue ( 'glyph' ) } export default { create , TYPE , name , type : TYPE , getSeriesProps : ( model ) => { return { strokeOpacity : base . getStrokeOpacity ( model ) } }, ... base } getSeriesProps Note that this model type has a getSeriesProps function. This function will take an instance of your model and should return any props that should be passed to your renderer component, such as stroke colors, opacity or anything else you need to customize your renderer's look and feel. Your renderer will also be passed your entire model object as well, but getSeriesProps is designed to allow you to use components not designed with the model, editor and renderer paradigm in mind. It is, for example, how the appropriate props are passed to @visx/xychart's built-in series types without them needing to know about the model that is powering their appearance. Filename GlyphLineSeriesEditor.jsx . import React from 'react' import { PropertyGrid , Pane , NumericInput } from '@leverege/ui-elements' import { useValueChange } from '@leverege/ui-hooks' import { ModelTypeSelector } from '@leverege/ui-plugin' import { Plugins } from '@leverege/plugin' import GlyphLineSeriesModel from '../../models/series/GlyphLineSeriesModel' export default function GlyphLineSeriesEditor ( props ) { const { value , objectType } = props const onModelChange = useValueChange ( GlyphLineSeriesModel , props ) return ( < Pane style = {{ '--propertyGrid-numColumns' : 2 }} > < PropertyGrid variant = \"seriesEditor|editor\" > < PropertyGrid . Header title = \"Line\" /> < PropertyGrid . Item label = \"Stroke Opacity\" > < NumericInput value = { GlyphLineSeriesModel . getStrokeOpacity ( value )} eventData = \"setStrokeOpacity\" min = { 0 } max = { 1 } float onChange = { onModelChange } /> < /PropertyGrid.Item> < PropertyGrid . Header title = \"Glyph\" /> { ModelTypeSelector . createSelectorAndEditor ( { values : Plugins . get ( 'GlyphModel' ), value : GlyphLineSeriesModel . getGlyph ( value ), eventData : 'setGlyph' , onChange : onModelChange , allowNone : false , isPropertyGrid : true , modelKey : 'model' , propertyGridOpts : { fill : true }, editorProps : { objectType } } ) } < /PropertyGrid> < /Pane> ) } Filename GlyphLineSeries.jsx . import React , { useCallback } from 'react' import { GlyphSeries , LineSeries } from '@visx/xychart' import GlyphLineSeriesModel from '../../models/series/GlyphLineSeriesModel' import { GlyphRendererFactory } from '../Factory' export default function GlyphLineSeries ( props ) { const { dataKey , data , xAccessor , yAccessor , strokeOpacity , model } = props const glyphModel = GlyphLineSeriesModel . getGlyph ( model ) const renderGlyph = useCallback ( ( glyphProps ) => { return GlyphRendererFactory . create ( glyphModel , { ... glyphProps } ) }, [ glyphModel ] ) return ( < React . Fragment > < LineSeries dataKey = { dataKey } data = { data } xAccessor = { xAccessor } yAccessor = { yAccessor } strokeOpacity = { strokeOpacity } /> < GlyphSeries dataKey = { dataKey } data = { data } xAccessor = { xAccessor } yAccessor = { yAccessor } renderGlyph = { renderGlyph } /> < /React.Fragment> ) } Filename PluginSetup.js . import GlyphLineSeriesModel from './GlyphLineSeriesModel' import GlyphLineSeriesEditor from './GlyphLineSeriesEditor' import GlyphLineSeries from './GlyphLineSeries' Plugins . add ( 'SeriesModel' , { type : GlyphLineSeriesModel . TYPE , name : GlyphLineSeriesModel . name , model : GlyphLineSeriesModel } ) Plugins . add ( 'SeriesModelEditor' , { type : GlyphLineSeriesModel . TYPE , editor : GlyphLineSeriesEditor } ) Plugins . add ( 'SeriesRenderer' , { type : GlyphLineSeriesModel . TYPE , renderer : GlyphLineSeries } ) Tip As you can see, this model encapsulates a Glyph Model inside of it, this editor provides the ability to edit the model using a model editor factory and this renderer uses a glyph renderer factory to render the glyph portion of the renderer. This composition is a common pattern and can save a great deal of code.","title":"Series Renderers"},{"location":"docs/graphs/plugin-points/series-renderers/#series-renderers","text":"A series renderer is a component that displays XY series data visually. the UI Attributes Graphs library has several built-in renderers and allows you to register your own renderer if you so desire. Most of the built-in renderers are simply wrappers around the base series renderer types supported by the @visx/xychart library, but a renderer is simple a component which is given access to the DataContext of the graph (including the graph's dimensions, it's X and Y scales, and its data) and can return any valid SVG for display.","title":"Series Renderers"},{"location":"docs/graphs/plugin-points/series-renderers/#built-in-types","text":"","title":"Built-In Types"},{"location":"docs/graphs/plugin-points/series-renderers/#line","text":"A line series renderer renders series data using a line. The only option for the line series is stroke opacity.","title":"Line"},{"location":"docs/graphs/plugin-points/series-renderers/#area","text":"Similar to a line series, except that the area beneath the line is shaded the same color as the line's stroke.","title":"Area"},{"location":"docs/graphs/plugin-points/series-renderers/#bar","text":"Graphs data as a series of bars.","title":"Bar"},{"location":"docs/graphs/plugin-points/series-renderers/#area-stack","text":"Similar to an Area graph, but data points from different series with the same x coordinate are stacked on top of each other for a cumulative effect. This graph type is only useful when all of your series data shares the same X coordinates.","title":"Area Stack"},{"location":"docs/graphs/plugin-points/series-renderers/#bar-stack","text":"A bar graph where datum with the same X coordinate are stacked cumulatively on top of each other, just as in an AreaStack renderer.","title":"Bar Stack"},{"location":"docs/graphs/plugin-points/series-renderers/#bar-group","text":"Also only useful for data sets that share the same set of X coordinates, the Bar Group displays series of data side-by-side grouped by their X coodrinate, rather than overlapping each other or stacking as in Bar and Bar Stack.","title":"Bar Group"},{"location":"docs/graphs/plugin-points/series-renderers/#glyph-line","text":"Like a line graph, but with user-customizable glyphs at each data point.","title":"Glyph Line"},{"location":"docs/graphs/plugin-points/series-renderers/#custom-series","text":"It is possible to create your own custom Series Renderer by registering SeriesModel, SeriesModelEditor and SeriesRender plugins for your series type. Again, a Series Renderer need only return valid svg, so any manner of visualization is possible. As an example, let's look at the Glyph Line Renderer, which is a conglomeration of LineSeries and GlyphSeries types from @visx/xychart Tip Registering your SeriesModel and SeriesModelEditor plugins will automatically register those plugins as Models and ModelEditors as well, which will make them available in UI Plugins that use the ModelFactory and ModelEditorFactory","title":"Custom Series"},{"location":"docs/graphs/plugin-points/series-renderers/#example","text":"Model Editor Renderer Setup File LineGlyphModel.js . import ModelUtil from '@leverege/model-util' import DotGlyphModel from '../glyph/DotGlyphModel' const TYPE = 'graph.series.glyphLine' const name = 'Glyph Line' function create ( extend ) { return { type : TYPE , name , strokeOpacity : 1 , glyph : DotGlyphModel . create (), ... extend } } const base = { ... ModelUtil . createAllValue ( 'strokeOpacity' ), ... ModelUtil . createAllValue ( 'glyph' ) } export default { create , TYPE , name , type : TYPE , getSeriesProps : ( model ) => { return { strokeOpacity : base . getStrokeOpacity ( model ) } }, ... base } getSeriesProps Note that this model type has a getSeriesProps function. This function will take an instance of your model and should return any props that should be passed to your renderer component, such as stroke colors, opacity or anything else you need to customize your renderer's look and feel. Your renderer will also be passed your entire model object as well, but getSeriesProps is designed to allow you to use components not designed with the model, editor and renderer paradigm in mind. It is, for example, how the appropriate props are passed to @visx/xychart's built-in series types without them needing to know about the model that is powering their appearance. Filename GlyphLineSeriesEditor.jsx . import React from 'react' import { PropertyGrid , Pane , NumericInput } from '@leverege/ui-elements' import { useValueChange } from '@leverege/ui-hooks' import { ModelTypeSelector } from '@leverege/ui-plugin' import { Plugins } from '@leverege/plugin' import GlyphLineSeriesModel from '../../models/series/GlyphLineSeriesModel' export default function GlyphLineSeriesEditor ( props ) { const { value , objectType } = props const onModelChange = useValueChange ( GlyphLineSeriesModel , props ) return ( < Pane style = {{ '--propertyGrid-numColumns' : 2 }} > < PropertyGrid variant = \"seriesEditor|editor\" > < PropertyGrid . Header title = \"Line\" /> < PropertyGrid . Item label = \"Stroke Opacity\" > < NumericInput value = { GlyphLineSeriesModel . getStrokeOpacity ( value )} eventData = \"setStrokeOpacity\" min = { 0 } max = { 1 } float onChange = { onModelChange } /> < /PropertyGrid.Item> < PropertyGrid . Header title = \"Glyph\" /> { ModelTypeSelector . createSelectorAndEditor ( { values : Plugins . get ( 'GlyphModel' ), value : GlyphLineSeriesModel . getGlyph ( value ), eventData : 'setGlyph' , onChange : onModelChange , allowNone : false , isPropertyGrid : true , modelKey : 'model' , propertyGridOpts : { fill : true }, editorProps : { objectType } } ) } < /PropertyGrid> < /Pane> ) } Filename GlyphLineSeries.jsx . import React , { useCallback } from 'react' import { GlyphSeries , LineSeries } from '@visx/xychart' import GlyphLineSeriesModel from '../../models/series/GlyphLineSeriesModel' import { GlyphRendererFactory } from '../Factory' export default function GlyphLineSeries ( props ) { const { dataKey , data , xAccessor , yAccessor , strokeOpacity , model } = props const glyphModel = GlyphLineSeriesModel . getGlyph ( model ) const renderGlyph = useCallback ( ( glyphProps ) => { return GlyphRendererFactory . create ( glyphModel , { ... glyphProps } ) }, [ glyphModel ] ) return ( < React . Fragment > < LineSeries dataKey = { dataKey } data = { data } xAccessor = { xAccessor } yAccessor = { yAccessor } strokeOpacity = { strokeOpacity } /> < GlyphSeries dataKey = { dataKey } data = { data } xAccessor = { xAccessor } yAccessor = { yAccessor } renderGlyph = { renderGlyph } /> < /React.Fragment> ) } Filename PluginSetup.js . import GlyphLineSeriesModel from './GlyphLineSeriesModel' import GlyphLineSeriesEditor from './GlyphLineSeriesEditor' import GlyphLineSeries from './GlyphLineSeries' Plugins . add ( 'SeriesModel' , { type : GlyphLineSeriesModel . TYPE , name : GlyphLineSeriesModel . name , model : GlyphLineSeriesModel } ) Plugins . add ( 'SeriesModelEditor' , { type : GlyphLineSeriesModel . TYPE , editor : GlyphLineSeriesEditor } ) Plugins . add ( 'SeriesRenderer' , { type : GlyphLineSeriesModel . TYPE , renderer : GlyphLineSeries } ) Tip As you can see, this model encapsulates a Glyph Model inside of it, this editor provides the ability to edit the model using a model editor factory and this renderer uses a glyph renderer factory to render the glyph portion of the renderer. This composition is a common pattern and can save a great deal of code.","title":"Example"},{"location":"docs/graphs/plugin-points/glyphs/","text":"Glyphs \u00b6 Glyphs are symbols that you can use in your graphs. Like most graph components, a Glyph can be any valid svg, including shapes, images or text. UI Attribute Graphs has a number of built in Glyph types , and you can extend these types by implementing a Glyph Symbolizer or Glyph Renderer .","title":"Glyphs"},{"location":"docs/graphs/plugin-points/glyphs/#glyphs","text":"Glyphs are symbols that you can use in your graphs. Like most graph components, a Glyph can be any valid svg, including shapes, images or text. UI Attribute Graphs has a number of built in Glyph types , and you can extend these types by implementing a Glyph Symbolizer or Glyph Renderer .","title":"Glyphs"},{"location":"docs/graphs/plugin-points/glyphs/glyph-renderers/","text":"Glyph Renderers \u00b6 Glyph Renderers are plugins that know how to render a glyph, which is a visual indicator at a point on an XYChart. Glyphs can be shapes, text or more complex constructions. Since they are based on svg, any element type supported by that standard can be rendered as a glyph. UI Attributes Graphs comes with several built in Glyph Renderer types that can be used to render series data or rollover tooltip markers. Dot \u00b6 The Dot renderer renders a circle of a configurable size, stroke and fill at a point. Square \u00b6 The Square renderer renders a square of a configurable size, stroke and fill at a point. Text \u00b6 The Text renderer renders a given text string of a configurable font size and stroke at a point. The Text renderer can use Glyph Symbolizers to customize the glyph that is rendered based on object data. Custom Glyph Renderers \u00b6 Let's take a look at the library's implementation of the Dot glyph renderer as an example of how one might add their own custom Glyph type: Model Editor DotGlyphRenderer Setup File DotGlyphModel.js . import ModelUtil from '@leverege/model-util' const TYPE = 'graph.glyph.dot' function create ( extend ) { return { type : TYPE , stroke : null , fill : null , size : 14 } } export default { TYPE , create , ... ModelUtil . createAllValue ( 'stroke' ), ... ModelUtil . createAllValue ( 'fill' ), ... ModelUtil . createAllValue ( 'size' ), name : 'Dot' } File DotGlyphEditor.js . import React from 'react' import { PropertyGrid , Pane , NumericInput , Label } from '@leverege/ui-elements' import { useValueChange } from '@leverege/ui-hooks' import { ModelTypeSelector } from '@leverege/ui-plugin' import { Colorizers } from '@leverege/ui-attributes' import DotGlyphModel from '../../models/glyph/DotGlyphModel' export default function DotGlyphEditor ( props ) { const { value , objectType } = props const onModelChange = useValueChange ( DotGlyphModel , props ) return ( < Pane style = {{ '--propertyGrid-numColumns' : 2 }} > < PropertyGrid variant = \"glyphEditor|editor\" > < PropertyGrid . Item label = \"Size\" > < NumericInput value = { DotGlyphModel . getSize ( value )} eventData = \"setSize\" onChange = { onModelChange } /> < /PropertyGrid.Item> { ModelTypeSelector . createSelectorAndEditor ( { modelKey : 'colorizer' , values : Colorizers . getColorizersFor ( objectType ), value : DotGlyphModel . getStroke ( value ), eventData : 'setStroke' , onChange : onModelChange , isPropertyGrid : true , propertyGridOpts : { preLabel : < Label > Stroke Color < /Label>, } } )} { ModelTypeSelector . createSelectorAndEditor ( { modelKey : 'colorizer' , values : Colorizers . getColorizersFor ( objectType ), value : DotGlyphModel . getFill ( value ), eventData : 'setFill' , onChange : onModelChange , isPropertyGrid : true , propertyGridOpts : { preLabel : < Label > Fill Color < /Label> } } )} < /PropertyGrid> < /Pane> ) } File DotGlyphRenderer.jsx . import React from 'react' import { GlyphDot } from '@visx/glyph' import { Colorizers } from '@leverege/ui-attributes' import DotGlyphModel from '../../models/glyph/DotGlyphModel' export default function DotGlyphRenderer ( props ) { const { model , size : pSize , color , x , y , datum , context } = props const size = DotGlyphModel . getSize ( model ) || pSize const strokeModel = DotGlyphModel . getStroke ( model ) const fillModel = DotGlyphModel . getFill ( model ) const stroke = Colorizers . getColor ( strokeModel , datum , { ... context , seriesColor : color } ) || color const fill = Colorizers . getColor ( fillModel , datum , { ... context , seriesColor : color } ) || color return ( < GlyphDot left = { x } top = { y } r = { size / 2 } stroke = { stroke } fill = { fill } /> ) } File PluginSetup.js . import DotGlyphModel from './DotGlyphModel' import DotGlyphEditor from './DotGlyphEditor' import DotGlyphRenderer from './DotGlyphRenderer' molten . addPlugin ( 'GlyphModel' , { type : DotGlyphModel . TYPE , name : DotGlyphModel . name , model : DotGlyphModel } ) molten . addPlugin ( 'GlyphModelEditor' , { type : DotGlyphModel . TYPE , editor : DotGlyphEditor } ) molten . addPlugin ( 'GlyphRenderer' , { type : DotGlyphModel . TYPE , renderer : DotGlyphRenderer } ) Tip Registering your model and editor using the 'GlyphModel' and 'GlyphModelEditor' will automatically register those plugins with the 'Model' and 'ModelEditor' plugin points, which is an important step that allows various generic model selectors and factories to know about your model and editor. You can see that the DotGlyphRenderer returns an instance of DotGlyph from the @visx/glyph library, but that component in turn just renders plain svg and is not much more than a convenience wrapper. A Glyph Renderer can return any valid svg.","title":"Glyph Renderers"},{"location":"docs/graphs/plugin-points/glyphs/glyph-renderers/#glyph-renderers","text":"Glyph Renderers are plugins that know how to render a glyph, which is a visual indicator at a point on an XYChart. Glyphs can be shapes, text or more complex constructions. Since they are based on svg, any element type supported by that standard can be rendered as a glyph. UI Attributes Graphs comes with several built in Glyph Renderer types that can be used to render series data or rollover tooltip markers.","title":"Glyph Renderers"},{"location":"docs/graphs/plugin-points/glyphs/glyph-renderers/#dot","text":"The Dot renderer renders a circle of a configurable size, stroke and fill at a point.","title":"Dot"},{"location":"docs/graphs/plugin-points/glyphs/glyph-renderers/#square","text":"The Square renderer renders a square of a configurable size, stroke and fill at a point.","title":"Square"},{"location":"docs/graphs/plugin-points/glyphs/glyph-renderers/#text","text":"The Text renderer renders a given text string of a configurable font size and stroke at a point. The Text renderer can use Glyph Symbolizers to customize the glyph that is rendered based on object data.","title":"Text"},{"location":"docs/graphs/plugin-points/glyphs/glyph-renderers/#custom-glyph-renderers","text":"Let's take a look at the library's implementation of the Dot glyph renderer as an example of how one might add their own custom Glyph type: Model Editor DotGlyphRenderer Setup File DotGlyphModel.js . import ModelUtil from '@leverege/model-util' const TYPE = 'graph.glyph.dot' function create ( extend ) { return { type : TYPE , stroke : null , fill : null , size : 14 } } export default { TYPE , create , ... ModelUtil . createAllValue ( 'stroke' ), ... ModelUtil . createAllValue ( 'fill' ), ... ModelUtil . createAllValue ( 'size' ), name : 'Dot' } File DotGlyphEditor.js . import React from 'react' import { PropertyGrid , Pane , NumericInput , Label } from '@leverege/ui-elements' import { useValueChange } from '@leverege/ui-hooks' import { ModelTypeSelector } from '@leverege/ui-plugin' import { Colorizers } from '@leverege/ui-attributes' import DotGlyphModel from '../../models/glyph/DotGlyphModel' export default function DotGlyphEditor ( props ) { const { value , objectType } = props const onModelChange = useValueChange ( DotGlyphModel , props ) return ( < Pane style = {{ '--propertyGrid-numColumns' : 2 }} > < PropertyGrid variant = \"glyphEditor|editor\" > < PropertyGrid . Item label = \"Size\" > < NumericInput value = { DotGlyphModel . getSize ( value )} eventData = \"setSize\" onChange = { onModelChange } /> < /PropertyGrid.Item> { ModelTypeSelector . createSelectorAndEditor ( { modelKey : 'colorizer' , values : Colorizers . getColorizersFor ( objectType ), value : DotGlyphModel . getStroke ( value ), eventData : 'setStroke' , onChange : onModelChange , isPropertyGrid : true , propertyGridOpts : { preLabel : < Label > Stroke Color < /Label>, } } )} { ModelTypeSelector . createSelectorAndEditor ( { modelKey : 'colorizer' , values : Colorizers . getColorizersFor ( objectType ), value : DotGlyphModel . getFill ( value ), eventData : 'setFill' , onChange : onModelChange , isPropertyGrid : true , propertyGridOpts : { preLabel : < Label > Fill Color < /Label> } } )} < /PropertyGrid> < /Pane> ) } File DotGlyphRenderer.jsx . import React from 'react' import { GlyphDot } from '@visx/glyph' import { Colorizers } from '@leverege/ui-attributes' import DotGlyphModel from '../../models/glyph/DotGlyphModel' export default function DotGlyphRenderer ( props ) { const { model , size : pSize , color , x , y , datum , context } = props const size = DotGlyphModel . getSize ( model ) || pSize const strokeModel = DotGlyphModel . getStroke ( model ) const fillModel = DotGlyphModel . getFill ( model ) const stroke = Colorizers . getColor ( strokeModel , datum , { ... context , seriesColor : color } ) || color const fill = Colorizers . getColor ( fillModel , datum , { ... context , seriesColor : color } ) || color return ( < GlyphDot left = { x } top = { y } r = { size / 2 } stroke = { stroke } fill = { fill } /> ) } File PluginSetup.js . import DotGlyphModel from './DotGlyphModel' import DotGlyphEditor from './DotGlyphEditor' import DotGlyphRenderer from './DotGlyphRenderer' molten . addPlugin ( 'GlyphModel' , { type : DotGlyphModel . TYPE , name : DotGlyphModel . name , model : DotGlyphModel } ) molten . addPlugin ( 'GlyphModelEditor' , { type : DotGlyphModel . TYPE , editor : DotGlyphEditor } ) molten . addPlugin ( 'GlyphRenderer' , { type : DotGlyphModel . TYPE , renderer : DotGlyphRenderer } ) Tip Registering your model and editor using the 'GlyphModel' and 'GlyphModelEditor' will automatically register those plugins with the 'Model' and 'ModelEditor' plugin points, which is an important step that allows various generic model selectors and factories to know about your model and editor. You can see that the DotGlyphRenderer returns an instance of DotGlyph from the @visx/glyph library, but that component in turn just renders plain svg and is not much more than a convenience wrapper. A Glyph Renderer can return any valid svg.","title":"Custom Glyph Renderers"},{"location":"docs/graphs/plugin-points/glyphs/glyph-symbolizers/","text":"Glyph Symbolizers \u00b6 Similar to Colorizers , Glyph Symbolizers can be used to conditionally render a glyph at a data point based on the data data in the target object. They allow you to define a function which can return a symbol to be used by a glyph renderer (either for a series data point or a rollover tooltip indicator). UI Attributes Graphs comes with one built-in Glyph Symbolizer, the Value Glyph Symbolizer which simple allows a user to choose a static string of text to be rendered at every point. Custom Glyph Symbolizers \u00b6 Here is an example of an Alert Symbolizer that shows a particular symbol when a given temperature threshold has been exceeded: Example \u00b6 Symbolizer Editor Setup File AlertGlyphSymbolizer.js . import ModelUtil from '@leverege/model-util' import { Attributes } from '@leverege/ui-attributes' const TYPE = 'symbolizer.test.history.Alert' export default { create () { return { type : TYPE , value : 30 , symbol : '\ud83d\ude03' , alertSymbol : '\ud83d\ude08' } }, symbolFor ( model , obj , context ) { const temp = Attributes . get ( 'test.history.temperature' , obj . type , obj . data ) if ( temp . value > model . value ) { return model . alertSymbol } return model . symbol }, ... ModelUtil . createAllValue ( 'value' ), ... ModelUtil . createAllValue ( 'symbol' ), ... ModelUtil . createAllValue ( 'alertSymbol' ), TYPE } File AlertSymbolizerEditor.jsx . import { NumericInput , TextInput , PropertyGrid } from '@leverege/ui-elements' import { useValueChange } from '@leverege/ui-hooks' import AlertGlyphSymbolizer from './AlertGlyphSymbolizer' export default function AlertSymbolizerEditor ( props ) { const { value } = props const onModelChange = useValueChange ( AlertGlyphSymbolizer , props ) return ( < PropertyGrid > < PropertyGrid . Item label = \"Alert Value\" > < NumericInput value = { AlertGlyphSymbolizer . getValue ( value )} hint = \"Alert Value\" float eventData = \"setValue\" onChange = { onModelChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Symbol\" > < TextInput value = { AlertGlyphSymbolizer . getSymbol ( value )} hint = \"Symbol\" eventData = \"setSymbol\" onChange = { onModelChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Alert Symbol\" > < TextInput value = { AlertGlyphSymbolizer . getAlertSymbol ( value )} hint = \"Alert Symbol\" eventData = \"setAlertSymbol\" onChange = { onModelChange } /> < /PropertyGrid.Item> < /PropertyGrid> ) } File PluginSetup.js . import AlertGlyphSymbolizer from './AlertGlyphSymbolizer' import AlertSymbolizerEditor from './AlertSymbolizerEditor' molten . addPlugin ( 'Model' , { type : AlertGlyphSymbolizer . TYPE , model : AlertGlyphSymbolizer } ) molten . addPlugin ( 'ModelEditor' , { type : AlertGlyphSymbolizer . TYPE , editor : AlertSymbolizerEditor } ) molten . addPlugin ( 'GlyphSymbolizer' , { type : AlertGlyphSymbolizer . TYPE , name : 'Alert Symbolizer' , symbolizer : AlertGlyphSymbolizer } ) This Glyph Symbolizer will render a \ud83d\ude03 when an object's temperature is less than or equal to a ceratin threshold and a \ud83d\ude08 when the temperature is greater. You are encouraged to use Glyph Symbolizers in your own plugins when applicable to increase potential customization by users.","title":"Glyph Symbolizers"},{"location":"docs/graphs/plugin-points/glyphs/glyph-symbolizers/#glyph-symbolizers","text":"Similar to Colorizers , Glyph Symbolizers can be used to conditionally render a glyph at a data point based on the data data in the target object. They allow you to define a function which can return a symbol to be used by a glyph renderer (either for a series data point or a rollover tooltip indicator). UI Attributes Graphs comes with one built-in Glyph Symbolizer, the Value Glyph Symbolizer which simple allows a user to choose a static string of text to be rendered at every point.","title":"Glyph Symbolizers"},{"location":"docs/graphs/plugin-points/glyphs/glyph-symbolizers/#custom-glyph-symbolizers","text":"Here is an example of an Alert Symbolizer that shows a particular symbol when a given temperature threshold has been exceeded:","title":"Custom Glyph Symbolizers"},{"location":"docs/graphs/plugin-points/glyphs/glyph-symbolizers/#example","text":"Symbolizer Editor Setup File AlertGlyphSymbolizer.js . import ModelUtil from '@leverege/model-util' import { Attributes } from '@leverege/ui-attributes' const TYPE = 'symbolizer.test.history.Alert' export default { create () { return { type : TYPE , value : 30 , symbol : '\ud83d\ude03' , alertSymbol : '\ud83d\ude08' } }, symbolFor ( model , obj , context ) { const temp = Attributes . get ( 'test.history.temperature' , obj . type , obj . data ) if ( temp . value > model . value ) { return model . alertSymbol } return model . symbol }, ... ModelUtil . createAllValue ( 'value' ), ... ModelUtil . createAllValue ( 'symbol' ), ... ModelUtil . createAllValue ( 'alertSymbol' ), TYPE } File AlertSymbolizerEditor.jsx . import { NumericInput , TextInput , PropertyGrid } from '@leverege/ui-elements' import { useValueChange } from '@leverege/ui-hooks' import AlertGlyphSymbolizer from './AlertGlyphSymbolizer' export default function AlertSymbolizerEditor ( props ) { const { value } = props const onModelChange = useValueChange ( AlertGlyphSymbolizer , props ) return ( < PropertyGrid > < PropertyGrid . Item label = \"Alert Value\" > < NumericInput value = { AlertGlyphSymbolizer . getValue ( value )} hint = \"Alert Value\" float eventData = \"setValue\" onChange = { onModelChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Symbol\" > < TextInput value = { AlertGlyphSymbolizer . getSymbol ( value )} hint = \"Symbol\" eventData = \"setSymbol\" onChange = { onModelChange } /> < /PropertyGrid.Item> < PropertyGrid . Item label = \"Alert Symbol\" > < TextInput value = { AlertGlyphSymbolizer . getAlertSymbol ( value )} hint = \"Alert Symbol\" eventData = \"setAlertSymbol\" onChange = { onModelChange } /> < /PropertyGrid.Item> < /PropertyGrid> ) } File PluginSetup.js . import AlertGlyphSymbolizer from './AlertGlyphSymbolizer' import AlertSymbolizerEditor from './AlertSymbolizerEditor' molten . addPlugin ( 'Model' , { type : AlertGlyphSymbolizer . TYPE , model : AlertGlyphSymbolizer } ) molten . addPlugin ( 'ModelEditor' , { type : AlertGlyphSymbolizer . TYPE , editor : AlertSymbolizerEditor } ) molten . addPlugin ( 'GlyphSymbolizer' , { type : AlertGlyphSymbolizer . TYPE , name : 'Alert Symbolizer' , symbolizer : AlertGlyphSymbolizer } ) This Glyph Symbolizer will render a \ud83d\ude03 when an object's temperature is less than or equal to a ceratin threshold and a \ud83d\ude08 when the temperature is greater. You are encouraged to use Glyph Symbolizers in your own plugins when applicable to increase potential customization by users.","title":"Example"},{"location":"docs/graphs/xychart/","text":"XYChart \u00b6 Purpose \u00b6 An XYChart is a type of graph that renders a series or multiple series of data on an X-Y coordinate plane. It can for instance, render something like temperature or battery level of a sensor over time. To do this, the XYChart needs a model, some formatted data and a renderer. Model \u00b6 The XYChartModel describes the type of graph that the XYChart will produce, from the type of series (Line, Bar, Area, etc.) to which datum should be used for the x and y coordinates (based on UI Attributes ), to the scale that each axis should be rendered on (Linear, Time, Band, etc.) When running in a Molten environment, attributes will be created for all Blueprint attributes in your Imagine project and the UI Attributes Graphs library will automatically create coordinate types for each of your attributes and assign them an appropriate default scale for their data type. For instance, an attribute with the value type of 'timestamp' will be graphable by default and will automatically be assigned a 'Time' scale type. Data \u00b6 Data for the XYChart graph is simply an object with unique keys and values comprised of arrays of object refs representing the various series that you wish to graph. UI Atttributes Graphs exports a useSeriesData hook as a convenience in order to take data in a single array format and separate it into series chunks given an attribute to chunk on. For instance, the following data array: const dataArray = [ { \"type\" : \"test.history\" , \"id\" : \"1\" , \"data\" : { \"time\" : 1642444110759 , \"name\" : \"Device 1\" , \"data\" : { \"temperature\" : 45.7891 } } }, { \"type\" : \"test.history\" , \"id\" : \"2\" , \"data\" : { \"time\" : 1642461033498 , \"name\" : \"Device 1\" , \"data\" : { \"temperature\" : 40.7705 } } }, { \"type\" : \"test.history\" , \"id\" : \"3\" , \"data\" : { \"time\" : 1642411955689 , \"name\" : \"Device 1\" , \"data\" : { \"temperature\" : 48.7092 } } }, { \"type\" : \"test.history\" , \"id\" : \"7\" , \"data\" : { \"time\" : 1642474048199 , \"name\" : \"Device 2\" , \"data\" : { \"temperature\" : 12.299 } } }, { \"type\" : \"test.history\" , \"id\" : \"8\" , \"data\" : { \"time\" : 1642407220379 , \"name\" : \"Device 2\" , \"data\" : { \"temperature\" : 5.4862 } } }, { \"type\" : \"test.history\" , \"id\" : \"9\" , \"data\" : { \"time\" : 1642478679300 , \"name\" : \"Device 2\" , \"data\" : { \"temperature\" : 4.5652 } } } ] can be passed to the useSeriesData hook with a chunk attribute of 'name' (and an optional sortAttribute of 'test.time' in order to produce arrays sorted by that attribute) in order to produce a chunked data object like so: const seriesData = useSeriesData ( dataArray , 'name' , { sortAttribute : 'test.time' } ) /* seriesData => { \"Device 2\": [ { \"type\": \"test.history\", \"id\": \"8\", \"data\": { \"time\": 1642407220379, \"name\": \"Device 2\", \"data\": { \"temperature\": 5.4862 } } }, { \"type\": \"test.history\", \"id\": \"7\", \"data\": { \"time\": 1642474048199, \"name\": \"Device 2\", \"data\": { \"temperature\": 12.299 } } }, { \"type\": \"test.history\", \"id\": \"9\", \"data\": { \"time\": 1642478679300, \"name\": \"Device 2\", \"data\": { \"temperature\": 4.5652 } } } ], \"Device 1\": [ { \"type\": \"test.history\", \"id\": \"3\", \"data\": { \"time\": 1642411955689, \"name\": \"Device 1\", \"data\": { \"temperature\": 48.7092 } } }, { \"type\": \"test.history\", \"id\": \"1\", \"data\": { \"time\": 1642444110759, \"name\": \"Device 1\", \"data\": { \"temperature\": 45.7891 } } }, { \"type\": \"test.history\", \"id\": \"2\", \"data\": { \"time\": 1642461033498, \"name\": \"Device 1\", \"data\": { \"temperature\": 40.7705 } } } ] } */ If you can't use the hook because of the complexity of your data or formatting needs, a normal object keyed on some unique property will work fine, just remember to memoize the data yourself. Renderer \u00b6 The last thing we need to render an XYChart is... a renderer. Luckily this is the simplest part of the equation. UI Attributes Graphs provides an XYChart component which takes a model instance, some data and an objectType string and will render your data in stunning color. import { XYChartModel , XYChartRenderer , useSeriesData } from '@leverege/ui-attributes-graphs' const [ model , setModel ] = useState ( XYChartModel . create () ) const seriesData = useSeriesData ( myUnformattedData , 'name' , { sortAttribute : 'test.time' } ) return ( < XYChartRenderer data = { seriesData } objectType = \"test.history\" model = { model } /> )","title":"XYChart"},{"location":"docs/graphs/xychart/#xychart","text":"","title":"XYChart"},{"location":"docs/graphs/xychart/#purpose","text":"An XYChart is a type of graph that renders a series or multiple series of data on an X-Y coordinate plane. It can for instance, render something like temperature or battery level of a sensor over time. To do this, the XYChart needs a model, some formatted data and a renderer.","title":"Purpose"},{"location":"docs/graphs/xychart/#model","text":"The XYChartModel describes the type of graph that the XYChart will produce, from the type of series (Line, Bar, Area, etc.) to which datum should be used for the x and y coordinates (based on UI Attributes ), to the scale that each axis should be rendered on (Linear, Time, Band, etc.) When running in a Molten environment, attributes will be created for all Blueprint attributes in your Imagine project and the UI Attributes Graphs library will automatically create coordinate types for each of your attributes and assign them an appropriate default scale for their data type. For instance, an attribute with the value type of 'timestamp' will be graphable by default and will automatically be assigned a 'Time' scale type.","title":"Model"},{"location":"docs/graphs/xychart/#data","text":"Data for the XYChart graph is simply an object with unique keys and values comprised of arrays of object refs representing the various series that you wish to graph. UI Atttributes Graphs exports a useSeriesData hook as a convenience in order to take data in a single array format and separate it into series chunks given an attribute to chunk on. For instance, the following data array: const dataArray = [ { \"type\" : \"test.history\" , \"id\" : \"1\" , \"data\" : { \"time\" : 1642444110759 , \"name\" : \"Device 1\" , \"data\" : { \"temperature\" : 45.7891 } } }, { \"type\" : \"test.history\" , \"id\" : \"2\" , \"data\" : { \"time\" : 1642461033498 , \"name\" : \"Device 1\" , \"data\" : { \"temperature\" : 40.7705 } } }, { \"type\" : \"test.history\" , \"id\" : \"3\" , \"data\" : { \"time\" : 1642411955689 , \"name\" : \"Device 1\" , \"data\" : { \"temperature\" : 48.7092 } } }, { \"type\" : \"test.history\" , \"id\" : \"7\" , \"data\" : { \"time\" : 1642474048199 , \"name\" : \"Device 2\" , \"data\" : { \"temperature\" : 12.299 } } }, { \"type\" : \"test.history\" , \"id\" : \"8\" , \"data\" : { \"time\" : 1642407220379 , \"name\" : \"Device 2\" , \"data\" : { \"temperature\" : 5.4862 } } }, { \"type\" : \"test.history\" , \"id\" : \"9\" , \"data\" : { \"time\" : 1642478679300 , \"name\" : \"Device 2\" , \"data\" : { \"temperature\" : 4.5652 } } } ] can be passed to the useSeriesData hook with a chunk attribute of 'name' (and an optional sortAttribute of 'test.time' in order to produce arrays sorted by that attribute) in order to produce a chunked data object like so: const seriesData = useSeriesData ( dataArray , 'name' , { sortAttribute : 'test.time' } ) /* seriesData => { \"Device 2\": [ { \"type\": \"test.history\", \"id\": \"8\", \"data\": { \"time\": 1642407220379, \"name\": \"Device 2\", \"data\": { \"temperature\": 5.4862 } } }, { \"type\": \"test.history\", \"id\": \"7\", \"data\": { \"time\": 1642474048199, \"name\": \"Device 2\", \"data\": { \"temperature\": 12.299 } } }, { \"type\": \"test.history\", \"id\": \"9\", \"data\": { \"time\": 1642478679300, \"name\": \"Device 2\", \"data\": { \"temperature\": 4.5652 } } } ], \"Device 1\": [ { \"type\": \"test.history\", \"id\": \"3\", \"data\": { \"time\": 1642411955689, \"name\": \"Device 1\", \"data\": { \"temperature\": 48.7092 } } }, { \"type\": \"test.history\", \"id\": \"1\", \"data\": { \"time\": 1642444110759, \"name\": \"Device 1\", \"data\": { \"temperature\": 45.7891 } } }, { \"type\": \"test.history\", \"id\": \"2\", \"data\": { \"time\": 1642461033498, \"name\": \"Device 1\", \"data\": { \"temperature\": 40.7705 } } } ] } */ If you can't use the hook because of the complexity of your data or formatting needs, a normal object keyed on some unique property will work fine, just remember to memoize the data yourself.","title":"Data"},{"location":"docs/graphs/xychart/#renderer","text":"The last thing we need to render an XYChart is... a renderer. Luckily this is the simplest part of the equation. UI Attributes Graphs provides an XYChart component which takes a model instance, some data and an objectType string and will render your data in stunning color. import { XYChartModel , XYChartRenderer , useSeriesData } from '@leverege/ui-attributes-graphs' const [ model , setModel ] = useState ( XYChartModel . create () ) const seriesData = useSeriesData ( myUnformattedData , 'name' , { sortAttribute : 'test.time' } ) return ( < XYChartRenderer data = { seriesData } objectType = \"test.history\" model = { model } /> )","title":"Renderer"},{"location":"docs/routes/","text":"Adding a Screen \u00b6 Molten will by default, analyze your Imagine project's Blueprints and create Screens and Routes to the screens based off of their hierarchies. Custom Screens can be added, however. There are normally three parts to this process: creation of the Screen component, registering a Route to a URL, and making a Link to take the user to the URL. Molten uses React Router and Plugins define which screens are presented at a particular URL. The screen presented at a URL may actually be composed of several subscreens, depending on how the Routes are specific. For example, a URL of /Group/5/Children may actually present a screen for Group/5 , which has some links, widgets, information, etc, but also has a Dynamic Route mechanism it it that would also present the Children screen. Route Plugins are evaluated and installed when the getRoutesFor() call is invoked. This can occur in multiple screens in your application. The DesktopMainScreen , for example calls: <Switch> {Routes.getRoutesFor( 'Main', null, { client : 'Main' } )} </Switch> This is asking for all Routes that wish to be installed at the 'Main' client level. Route Plugins should specify a matches object that indicates where it wishes to be installed.","title":"Adding a Screen"},{"location":"docs/routes/#adding-a-screen","text":"Molten will by default, analyze your Imagine project's Blueprints and create Screens and Routes to the screens based off of their hierarchies. Custom Screens can be added, however. There are normally three parts to this process: creation of the Screen component, registering a Route to a URL, and making a Link to take the user to the URL. Molten uses React Router and Plugins define which screens are presented at a particular URL. The screen presented at a URL may actually be composed of several subscreens, depending on how the Routes are specific. For example, a URL of /Group/5/Children may actually present a screen for Group/5 , which has some links, widgets, information, etc, but also has a Dynamic Route mechanism it it that would also present the Children screen. Route Plugins are evaluated and installed when the getRoutesFor() call is invoked. This can occur in multiple screens in your application. The DesktopMainScreen , for example calls: <Switch> {Routes.getRoutesFor( 'Main', null, { client : 'Main' } )} </Switch> This is asking for all Routes that wish to be installed at the 'Main' client level. Route Plugins should specify a matches object that indicates where it wishes to be installed.","title":"Adding a Screen"},{"location":"docs/routes/links/","text":"Links \u00b6 Links to a Screen can be done in many ways. Any standard component can change the URL when told to do so by the user. In the case of the default Molten Desktop Screen, toolbars are install to allow th user to put custom actions to perform a variety of commands such as logging out, changing persona, bring up a dialog, or going to a URL. To got to our new Route and Screen using the toolbars, we can use the LinkAction.create() to create an action that will integrate with the existing menus. The following options can be given to the create function: Field Type Description id String The unique plugin id matches Object An object specifying where the the Action should appear. Normally, the client is specified and in come cases an even finer criteria layout Object The Plugins Layout object that can specify where the action should appear, including submenuing, section names and sorting. See Layout path String The URL path to take the user to name String or funciton The name of string to show the user icon String The font icon or url to use as an icon for the action iconOn String The font icon or url to use as an icon for the action when the user is at the path. iconOff String The font icon or url to use as an icon for the action when the user is not at the path handles function The action handles method that can be used to further refined if this action is visible Example \u00b6 Plugin Setup File IncredibleLink.js . export default LinkAction . create ( { id : 'my.link.IncredibleScreen' , matches : { use : 'userBar' , client : 'Main' }, name : 'Incredible' , icon : 'fa fa-snowflake-o fa-fw' , path : '/iscreen' } ) In this case, we are going to put the link to /iscreen into the Main Screen's user profile toolbar (targeted by using use : \"userBar\" ) with the name \"Incredible\" and a snowfake icon. Be sure to install your plugin in your PluginSetup.js file. exports . install = ( molten ) => { molten . addPlugin ( 'Action' , IncredibleLink ) }","title":"Links"},{"location":"docs/routes/links/#links","text":"Links to a Screen can be done in many ways. Any standard component can change the URL when told to do so by the user. In the case of the default Molten Desktop Screen, toolbars are install to allow th user to put custom actions to perform a variety of commands such as logging out, changing persona, bring up a dialog, or going to a URL. To got to our new Route and Screen using the toolbars, we can use the LinkAction.create() to create an action that will integrate with the existing menus. The following options can be given to the create function: Field Type Description id String The unique plugin id matches Object An object specifying where the the Action should appear. Normally, the client is specified and in come cases an even finer criteria layout Object The Plugins Layout object that can specify where the action should appear, including submenuing, section names and sorting. See Layout path String The URL path to take the user to name String or funciton The name of string to show the user icon String The font icon or url to use as an icon for the action iconOn String The font icon or url to use as an icon for the action when the user is at the path. iconOff String The font icon or url to use as an icon for the action when the user is not at the path handles function The action handles method that can be used to further refined if this action is visible","title":"Links"},{"location":"docs/routes/links/#example","text":"Plugin Setup File IncredibleLink.js . export default LinkAction . create ( { id : 'my.link.IncredibleScreen' , matches : { use : 'userBar' , client : 'Main' }, name : 'Incredible' , icon : 'fa fa-snowflake-o fa-fw' , path : '/iscreen' } ) In this case, we are going to put the link to /iscreen into the Main Screen's user profile toolbar (targeted by using use : \"userBar\" ) with the name \"Incredible\" and a snowfake icon. Be sure to install your plugin in your PluginSetup.js file. exports . install = ( molten ) => { molten . addPlugin ( 'Action' , IncredibleLink ) }","title":"Example"},{"location":"docs/routes/routes/","text":"Routes \u00b6 The Routes defines what to render, where. The what is a React component, and the where is a URL. The route is a directive to tell Molten to render a particular React component at a mathcing url pattern when certain criteria are met. The criteria is captured in the matches object defined by the plugin, and follows the rules of the Plugin Matches system. To define a Route, add a Route Plugin that has the following properties: Field Type Description id String The unique plugin id exact boolean If true , the URL must match exactly the path. This should be true in the case of a leaf screen, false in the case where the screen manages deeper parts of the url. For example, our /Group/5 screen above would set this to false and then render its own Switch Component useing the Routes object. path String or Array The path expression used to match eg. /group/:groupId matches Object An object specifying where the the route should appear. Normally, the client is specified component ReactComponent or Function The component to render render function Optional React function to render props Object or null Extra props to send into the component. These can be overriden by extra props sent into the getRoutesFor function strict boolean If true, the path will compare trailing slashes Example \u00b6 Plugin Setup File IncredibleRoute.js . export default { id : 'my.route.IncredibleScreen' , exact : true , path : '/iscreen/' , matches : { client : 'Main' }, component : IncredibleScreen , props : { hello : 'world' } } This plugin is asking Molten to render the IncredibleScreen when the URL path is exactly /iscreen/ . It will only be matched at the top level Switch, managed by the Main client. Extra prop will be given to the screen. Be sure to install your plugin in your PluginSetup.js file. exports . install = ( molten ) => { molten . addPlugin ( 'Route' , IncredibleRoute ) } Dynamic Plugin Addition \u00b6 The Routing mechanism is listening for changes to the routes, so Routes added during execution will be used the next time the Switch/getRoutesFor() is called. The order in which the plugins are added does not matter. The order in which Routes are returned are based on a specificity. Sorting Paths The routes are turned into strings of 'A's, 'C's, 'E's and 'R's, where 'A' are explicit path components, and 'C's are variable (changeable) parameters, 'E's are extact match and 'R's indicates the rest matches too. These will then be sorted first by length, then by string sort on the ACER strings.","title":"Routes"},{"location":"docs/routes/routes/#routes","text":"The Routes defines what to render, where. The what is a React component, and the where is a URL. The route is a directive to tell Molten to render a particular React component at a mathcing url pattern when certain criteria are met. The criteria is captured in the matches object defined by the plugin, and follows the rules of the Plugin Matches system. To define a Route, add a Route Plugin that has the following properties: Field Type Description id String The unique plugin id exact boolean If true , the URL must match exactly the path. This should be true in the case of a leaf screen, false in the case where the screen manages deeper parts of the url. For example, our /Group/5 screen above would set this to false and then render its own Switch Component useing the Routes object. path String or Array The path expression used to match eg. /group/:groupId matches Object An object specifying where the the route should appear. Normally, the client is specified component ReactComponent or Function The component to render render function Optional React function to render props Object or null Extra props to send into the component. These can be overriden by extra props sent into the getRoutesFor function strict boolean If true, the path will compare trailing slashes","title":"Routes"},{"location":"docs/routes/routes/#example","text":"Plugin Setup File IncredibleRoute.js . export default { id : 'my.route.IncredibleScreen' , exact : true , path : '/iscreen/' , matches : { client : 'Main' }, component : IncredibleScreen , props : { hello : 'world' } } This plugin is asking Molten to render the IncredibleScreen when the URL path is exactly /iscreen/ . It will only be matched at the top level Switch, managed by the Main client. Extra prop will be given to the screen. Be sure to install your plugin in your PluginSetup.js file. exports . install = ( molten ) => { molten . addPlugin ( 'Route' , IncredibleRoute ) }","title":"Example"},{"location":"docs/routes/routes/#dynamic-plugin-addition","text":"The Routing mechanism is listening for changes to the routes, so Routes added during execution will be used the next time the Switch/getRoutesFor() is called. The order in which the plugins are added does not matter. The order in which Routes are returned are based on a specificity. Sorting Paths The routes are turned into strings of 'A's, 'C's, 'E's and 'R's, where 'A' are explicit path components, and 'C's are variable (changeable) parameters, 'E's are extact match and 'R's indicates the rest matches too. These will then be sorted first by length, then by string sort on the ACER strings.","title":"Dynamic Plugin Addition"},{"location":"docs/routes/screens/","text":"Screens \u00b6 A Screen is just a React Component. It can pretty much do what it wants. It can connect to Redux, it can call external APIs, it can use its own custom Plugins, it can other Plugins mechanism that already exist such as attributes or toolbars, it can use Routes.getRoutesFor() to have its own sub registered Routes/Screens with a custom navigation mechanism. The only real consideration is that the screen will be given an area to render in, and it should manage it own rendering and scroll areas. This is good place to use ui-elements' Content , but other mechanism can work as well. React Components We highly recommend using @leverege/ui-elements for your components, as they will inherit the theme used for the rest of the screens. You can also use the css variables that the theme exports to aid with this theme consistency if using the ui-elements library is not feasible. Example \u00b6 In the following example, our IncredibleScreen will have a title bar, and action toolbar to accept plugins, and a greeting. File IncredibleRoute.js . import React from 'react' import { connect } from 'react-redux' import { Text , Content } from '@leverege/ui-elements' import { Config } from '@leverege/plugin' import { TitleBar , Toolbar } from '@leverege/ui-plugin' class IncredibleScreen extends React . Component { render () { const { hello = '-' } = this . props // Putting welcome into the matchContext for the // tool bar is not required, but would all actions // to only appear if welcome is a certain value this . matchContext = { client : 'IncredibleScreen' , welcome : hello } return ( < Content > < Content . Header > < TitleBar variant = \"screenTitle\" title = \"Incredible Screen\" icon = { Config . get ( 'IncredibleScreen' , 'screenIcon' , 'fa fa-snowflake-o fa-fw' )} > < Toolbar variant = \"actionBar\" prefer = \"icon\" hasContextMenu = { false } matchContext = { this . matchContext } context = {{}} /> < /TitleBar> < /Content.Header> < Content . Area variant = \"screenContent\" > < Text variant = \"caption\" icon = \"fa fa-snowflake fa-fw\" > My incredible Screen ! < /Text> < Text variant = \"smallCaption\" icon = \"fa fa-snowflake fa-fw\" > Hello { hello } ! < /Text> < /Content.Area> < /Content> ) } } export default connect ( state => ( { } ) )( IncredibleScreen )","title":"Screens"},{"location":"docs/routes/screens/#screens","text":"A Screen is just a React Component. It can pretty much do what it wants. It can connect to Redux, it can call external APIs, it can use its own custom Plugins, it can other Plugins mechanism that already exist such as attributes or toolbars, it can use Routes.getRoutesFor() to have its own sub registered Routes/Screens with a custom navigation mechanism. The only real consideration is that the screen will be given an area to render in, and it should manage it own rendering and scroll areas. This is good place to use ui-elements' Content , but other mechanism can work as well. React Components We highly recommend using @leverege/ui-elements for your components, as they will inherit the theme used for the rest of the screens. You can also use the css variables that the theme exports to aid with this theme consistency if using the ui-elements library is not feasible.","title":"Screens"},{"location":"docs/routes/screens/#example","text":"In the following example, our IncredibleScreen will have a title bar, and action toolbar to accept plugins, and a greeting. File IncredibleRoute.js . import React from 'react' import { connect } from 'react-redux' import { Text , Content } from '@leverege/ui-elements' import { Config } from '@leverege/plugin' import { TitleBar , Toolbar } from '@leverege/ui-plugin' class IncredibleScreen extends React . Component { render () { const { hello = '-' } = this . props // Putting welcome into the matchContext for the // tool bar is not required, but would all actions // to only appear if welcome is a certain value this . matchContext = { client : 'IncredibleScreen' , welcome : hello } return ( < Content > < Content . Header > < TitleBar variant = \"screenTitle\" title = \"Incredible Screen\" icon = { Config . get ( 'IncredibleScreen' , 'screenIcon' , 'fa fa-snowflake-o fa-fw' )} > < Toolbar variant = \"actionBar\" prefer = \"icon\" hasContextMenu = { false } matchContext = { this . matchContext } context = {{}} /> < /TitleBar> < /Content.Header> < Content . Area variant = \"screenContent\" > < Text variant = \"caption\" icon = \"fa fa-snowflake fa-fw\" > My incredible Screen ! < /Text> < Text variant = \"smallCaption\" icon = \"fa fa-snowflake fa-fw\" > Hello { hello } ! < /Text> < /Content.Area> < /Content> ) } } export default connect ( state => ( { } ) )( IncredibleScreen )","title":"Example"},{"location":"docs/startup/","text":"Startup \u00b6 There are many phases to startup. Plugins are used to drive as many of these as possible. The startup flow looks like: flowchart TB subgraph Providers E[Run Reducer Plugins] --> F[Run Middleware Plugins]; end subgraph Prerender direction LR; PRA[Verify Current User] --> PRB[Load OIDC Clients]; end subgraph OnLogin [Run On Login Plugins ] LA[Role Downloading] --> LB[Blueprint Analysis]; LB --> LC[Custom]; end A[Load Plugins] --> B[Run Initializers Plugins]; B -->C[Run Support Component Plugins]; C --> D[Run Provider Plugins]; D --> Providers; Providers --> Prerender; Prerender --> Auth{Valid User?}; Auth -- Yes --> Render[Render Main React App]; Auth -- No --> Login[Render Login Screen]; Login --> Auth; Render --> OnLogin; click B href \"./initializers/\" \"Run the Initializer Plugins\" _self click C href \"./support-components/\" \"Run the Component Support Plugins\" _self Init Molten This loads the default Plugins Load custom plugins Implemented by custom application Run all Initializer Plugins Run all Support Component Plugins Run all Provider Plugins Reducer Plugins run from ReduxStore plugin Middleware Plugins run from ReduxStore plugin Run all Prerender Plugins Auth verify run by Auth plugin Oidc loaded here to be ready for login screen by Auth plugin Render React application Login/Authentication LoggedIn Plugins run Role downloading Blueprint Analysis Auto plugins created","title":"Startup"},{"location":"docs/startup/#startup","text":"There are many phases to startup. Plugins are used to drive as many of these as possible. The startup flow looks like: flowchart TB subgraph Providers E[Run Reducer Plugins] --> F[Run Middleware Plugins]; end subgraph Prerender direction LR; PRA[Verify Current User] --> PRB[Load OIDC Clients]; end subgraph OnLogin [Run On Login Plugins ] LA[Role Downloading] --> LB[Blueprint Analysis]; LB --> LC[Custom]; end A[Load Plugins] --> B[Run Initializers Plugins]; B -->C[Run Support Component Plugins]; C --> D[Run Provider Plugins]; D --> Providers; Providers --> Prerender; Prerender --> Auth{Valid User?}; Auth -- Yes --> Render[Render Main React App]; Auth -- No --> Login[Render Login Screen]; Login --> Auth; Render --> OnLogin; click B href \"./initializers/\" \"Run the Initializer Plugins\" _self click C href \"./support-components/\" \"Run the Component Support Plugins\" _self Init Molten This loads the default Plugins Load custom plugins Implemented by custom application Run all Initializer Plugins Run all Support Component Plugins Run all Provider Plugins Reducer Plugins run from ReduxStore plugin Middleware Plugins run from ReduxStore plugin Run all Prerender Plugins Auth verify run by Auth plugin Oidc loaded here to be ready for login screen by Auth plugin Render React application Login/Authentication LoggedIn Plugins run Role downloading Blueprint Analysis Auto plugins created","title":"Startup"},{"location":"docs/startup/initializers/","text":"Initializer Plugins \u00b6 The Plugins installed at Constants.INITIALIZER or 'Molten.Initializer' are invoked after as the first step in Molten.create() . These plugins should have an id , sort , and init( molten ) function as properties. This function can be async and the next initializer in the chain will not be called until the one before it finishes. Initializers can initialize objects from the config options ( molten.getConfig() ) and make them available to other steps by calling molten.set( key, value ) or molten.setThunk( key, ) . Example \u00b6 Plugin Setup File MyInitializer.js . export default { id : 'my.Initializer' , sort : - 5 , // defaults to 0, init : ( molten ) => { const api = new Api ( molten . getConfig ( 'api' ) ) molten . set ( 'api' ) molten . setThunkArg ( 'api' , api ) } } Be sure to install your plugin in your PluginSetup.js file. Plugin . add ( 'Molten.Initializer' , MyInitialize ) Default Initializers \u00b6 The inital Molten setup will install the following plugins as Initializer Plugins. Type Sort Description molten.LoadConfig -1000000 This will take values from config.plugins.config and call Config.set( resource, key, value ). The config.plugins.config should be configured with as { : { : } } molten.Splash -100000 This will create a splash screen based on the config's molten.splashClass , if present. molten.ApiInit -100 This will create an Api object to interface to Leverege's platform and advertise it as a the 'api' thunk argument and the value 'api' in Molten's values. molten.RouterInit -30 Creates a history object and sets it as 'history' in molten's values.","title":"Initializers"},{"location":"docs/startup/initializers/#initializer-plugins","text":"The Plugins installed at Constants.INITIALIZER or 'Molten.Initializer' are invoked after as the first step in Molten.create() . These plugins should have an id , sort , and init( molten ) function as properties. This function can be async and the next initializer in the chain will not be called until the one before it finishes. Initializers can initialize objects from the config options ( molten.getConfig() ) and make them available to other steps by calling molten.set( key, value ) or molten.setThunk( key, ) .","title":"Initializer Plugins"},{"location":"docs/startup/initializers/#example","text":"Plugin Setup File MyInitializer.js . export default { id : 'my.Initializer' , sort : - 5 , // defaults to 0, init : ( molten ) => { const api = new Api ( molten . getConfig ( 'api' ) ) molten . set ( 'api' ) molten . setThunkArg ( 'api' , api ) } } Be sure to install your plugin in your PluginSetup.js file. Plugin . add ( 'Molten.Initializer' , MyInitialize )","title":"Example"},{"location":"docs/startup/initializers/#default-initializers","text":"The inital Molten setup will install the following plugins as Initializer Plugins. Type Sort Description molten.LoadConfig -1000000 This will take values from config.plugins.config and call Config.set( resource, key, value ). The config.plugins.config should be configured with as { : { : } } molten.Splash -100000 This will create a splash screen based on the config's molten.splashClass , if present. molten.ApiInit -100 This will create an Api object to interface to Leverege's platform and advertise it as a the 'api' thunk argument and the value 'api' in Molten's values. molten.RouterInit -30 Creates a history object and sets it as 'history' in molten's values.","title":"Default Initializers"},{"location":"docs/startup/redux/","text":"Redux here","title":"Redux"},{"location":"docs/startup/support-components/","text":"Support Component Plugins \u00b6 The Plugins installed at Constants.SUPPORT_COMPONENTS or 'Molten.SupportComponent' are invoked just before the Providers. These plugins should have an id , sort , and createSupportComponents( molten ) function as properties. This function should an array of components to be placed beside the Application. Support components like Toast and Dialogs can use this. In the React world, these components are used to install components to support the final app. They are siblings of the Main application and exist within the providers: < X . Provider > < AuthCheckScreen /> < MySypportComponent /> < Toast /> < Dialogs /> < ... other Support Components ... > < /X.Provider> The plugin should have a createSupportComponents( molten ) function that returns an array of support components to install. Example \u00b6 Plugin Setup File MySupportComponent.js . export default { id : 'molten.Theme' , sort : 0 , createSupportComponents : ( molten ) => { return [ React . createElement ( Toast , { key : 'theme.toast' , containerId : 'default' } ), React . createElement ( Dialogs , { key : 'theme.dialogs' } ) ] } } Be sure to install your plugin in your PluginSetup.js file. Plugin . add ( 'Molten.SupportComponents' , MySupportComponent ) Default Support Components \u00b6 Type Sort Description molten.Theme 0 This will install Toast and Dialogs support","title":"Support Components"},{"location":"docs/startup/support-components/#support-component-plugins","text":"The Plugins installed at Constants.SUPPORT_COMPONENTS or 'Molten.SupportComponent' are invoked just before the Providers. These plugins should have an id , sort , and createSupportComponents( molten ) function as properties. This function should an array of components to be placed beside the Application. Support components like Toast and Dialogs can use this. In the React world, these components are used to install components to support the final app. They are siblings of the Main application and exist within the providers: < X . Provider > < AuthCheckScreen /> < MySypportComponent /> < Toast /> < Dialogs /> < ... other Support Components ... > < /X.Provider> The plugin should have a createSupportComponents( molten ) function that returns an array of support components to install.","title":"Support Component Plugins"},{"location":"docs/startup/support-components/#example","text":"Plugin Setup File MySupportComponent.js . export default { id : 'molten.Theme' , sort : 0 , createSupportComponents : ( molten ) => { return [ React . createElement ( Toast , { key : 'theme.toast' , containerId : 'default' } ), React . createElement ( Dialogs , { key : 'theme.dialogs' } ) ] } } Be sure to install your plugin in your PluginSetup.js file. Plugin . add ( 'Molten.SupportComponents' , MySupportComponent )","title":"Example"},{"location":"docs/startup/support-components/#default-support-components","text":"Type Sort Description molten.Theme 0 This will install Toast and Dialogs support","title":"Default Support Components"},{"location":"docs/table/","text":"Table \u00b6 Purpose \u00b6 Unsurprisingly, the purpose of the Table module is to render tabular data. To do so, it needs a model, some data and a renderer. Model \u00b6 The TableModel from the @leverege/ui-attributes library provides all of the configuration options necessary to render a table component. THe only top-level option is whether each table row should be selectable, meaning whether a checkbox should be rendered to the left most side of each row to allow selection. The rest of the table model is dedicated to a list of Columns, each of which has their own options which are documented elsewhere . It is worth noting here however that ColumnCreators (objects that are capable of creating table column models) are automatically generated for each Attribute that is created, making attributes eligible for inclusion in a table by default. Data \u00b6 The data for a table instance is simply an array of object refs . Renderer \u00b6 The renderer for a Table is the TableView , found in @leverege/molten . Actions Match \u00b6 There are four toolbars within each table view that you can target to install Actions with the following match contexts: Location Match Context Top Left { use : 'filterBar', client : 'TableDataViewer | HistoryTableViewer', objectType, path } Top Right { use : 'actionBar', client : 'TableDataViewer | HistoryTableViewer', objectType, path } Bottom Left { use : 'footerLeft', client : 'TableDataViewer | HistoryTableViewer', objectType, path } Bottom Right { use : 'footerRight', client : 'TableDataViewer | HistoryTableViewer', objectType, path }","title":"Table"},{"location":"docs/table/#table","text":"","title":"Table"},{"location":"docs/table/#purpose","text":"Unsurprisingly, the purpose of the Table module is to render tabular data. To do so, it needs a model, some data and a renderer.","title":"Purpose"},{"location":"docs/table/#model","text":"The TableModel from the @leverege/ui-attributes library provides all of the configuration options necessary to render a table component. THe only top-level option is whether each table row should be selectable, meaning whether a checkbox should be rendered to the left most side of each row to allow selection. The rest of the table model is dedicated to a list of Columns, each of which has their own options which are documented elsewhere . It is worth noting here however that ColumnCreators (objects that are capable of creating table column models) are automatically generated for each Attribute that is created, making attributes eligible for inclusion in a table by default.","title":"Model"},{"location":"docs/table/#data","text":"The data for a table instance is simply an array of object refs .","title":"Data"},{"location":"docs/table/#renderer","text":"The renderer for a Table is the TableView , found in @leverege/molten .","title":"Renderer"},{"location":"docs/table/#actions-match","text":"There are four toolbars within each table view that you can target to install Actions with the following match contexts: Location Match Context Top Left { use : 'filterBar', client : 'TableDataViewer | HistoryTableViewer', objectType, path } Top Right { use : 'actionBar', client : 'TableDataViewer | HistoryTableViewer', objectType, path } Bottom Left { use : 'footerLeft', client : 'TableDataViewer | HistoryTableViewer', objectType, path } Bottom Right { use : 'footerRight', client : 'TableDataViewer | HistoryTableViewer', objectType, path }","title":"Actions Match"},{"location":"docs/table/columns/","text":"Columns \u00b6 Most of the available customization in the Table module is in tweaking and customizing the way that columns are rendered. By default, each attribute you create will automatically have a ColumnCreator generated for it. This column creator is capable of generating an AttributeColumnModel or UnitAttributeColumnModel depending upon whether your attribute represents a unit type or not. AttributeColumnModel and UnitAttributeColumnModel instances each have built in editors and renderers that are capable of allowing a user to customize things like text color, font style, background color, unit and value formatting, unit conversion and more. Customization \u00b6 You can also customize the behavior and appearance of table columns using the available table Plugin Points .","title":"Columns"},{"location":"docs/table/columns/#columns","text":"Most of the available customization in the Table module is in tweaking and customizing the way that columns are rendered. By default, each attribute you create will automatically have a ColumnCreator generated for it. This column creator is capable of generating an AttributeColumnModel or UnitAttributeColumnModel depending upon whether your attribute represents a unit type or not. AttributeColumnModel and UnitAttributeColumnModel instances each have built in editors and renderers that are capable of allowing a user to customize things like text color, font style, background color, unit and value formatting, unit conversion and more.","title":"Columns"},{"location":"docs/table/columns/#customization","text":"You can also customize the behavior and appearance of table columns using the available table Plugin Points .","title":"Customization"},{"location":"docs/table/plugin-points/","text":"Plugin Points \u00b6 Table plugin points allow you to customize the look and feel of your table in various ways.","title":"Plugin Points"},{"location":"docs/table/plugin-points/#plugin-points","text":"Table plugin points allow you to customize the look and feel of your table in various ways.","title":"Plugin Points"},{"location":"docs/table/plugin-points/attribute-cell-renderer/","text":"AttributeCellRenderer \u00b6 Registering an AttributeCellRenderer plugin give you the chance to replace the default cell renderer for a particular table column. The best way to demonstrate is through a simple example. Example \u00b6 Renderer Setup File DoubleNameRenderer.jsx import React from 'react' function DoubleNameRenderer ( props ) { const { data : { value } } = props return ` ${ value } ${ value } ` } export default { objectType : 'test' , attrName : 'name' , renderer : ( data , props , context ) => { return React . createElement ( DoubleNameRenderer , { ... props , data , context } ) } } File PluginSetup.js import DoubleNameRenderer from './DoubleNameRenderer' export default { install ( molten ) { molten . addPlugin ( 'AttributeCellRenderer' , DoubleNameRenderer ) } } As you can see, the process is simply to register a renderer against a particular object type and attribute name. This will cause any cells rendered for that objectType ane attribute name combination to use our renderer instead of the default. The three arguments passed to the renderer function are as follows: Prop Purpose data This is the data that is passed to each cell by the parent table. It includes almost all of the state of the entire table, including that of the current cell, the current row and all other rows. Notably though, data contains a property called \"value\" which is the actual value for this table cell. context This is the context that the table passes to each cell containing it's props under the clientProps key, the current row object under target and the original column renderer under the key renderer . This last property allows you to use the original renderer conditionally if you'd like to make some cells appear in their default state but for others to have a customized look by calling renderer.renderCell( data, props, context ) . props These are additional style props that are passed to the cell component and are generally undefined. The TableView uses react-table internally, and for very custom table implementations, additional cell props can be provided to each cell through the react-table apis .","title":"AttributeCellRenderer"},{"location":"docs/table/plugin-points/attribute-cell-renderer/#attributecellrenderer","text":"Registering an AttributeCellRenderer plugin give you the chance to replace the default cell renderer for a particular table column. The best way to demonstrate is through a simple example.","title":"AttributeCellRenderer"},{"location":"docs/table/plugin-points/attribute-cell-renderer/#example","text":"Renderer Setup File DoubleNameRenderer.jsx import React from 'react' function DoubleNameRenderer ( props ) { const { data : { value } } = props return ` ${ value } ${ value } ` } export default { objectType : 'test' , attrName : 'name' , renderer : ( data , props , context ) => { return React . createElement ( DoubleNameRenderer , { ... props , data , context } ) } } File PluginSetup.js import DoubleNameRenderer from './DoubleNameRenderer' export default { install ( molten ) { molten . addPlugin ( 'AttributeCellRenderer' , DoubleNameRenderer ) } } As you can see, the process is simply to register a renderer against a particular object type and attribute name. This will cause any cells rendered for that objectType ane attribute name combination to use our renderer instead of the default. The three arguments passed to the renderer function are as follows: Prop Purpose data This is the data that is passed to each cell by the parent table. It includes almost all of the state of the entire table, including that of the current cell, the current row and all other rows. Notably though, data contains a property called \"value\" which is the actual value for this table cell. context This is the context that the table passes to each cell containing it's props under the clientProps key, the current row object under target and the original column renderer under the key renderer . This last property allows you to use the original renderer conditionally if you'd like to make some cells appear in their default state but for others to have a customized look by calling renderer.renderCell( data, props, context ) . props These are additional style props that are passed to the cell component and are generally undefined. The TableView uses react-table internally, and for very custom table implementations, additional cell props can be provided to each cell through the react-table apis .","title":"Example"},{"location":"docs/table/plugin-points/column-renderer/","text":"ColumnRenderer \u00b6 In most cases, when you want to replace the default renderer for a column, an AttributeCellRenderer plugin will suffice. However, perhaps your custom data type has an Attribute with a valueType that the table does not support out of the box. For instance, the table does not have an image column renderer by default. Let's take a look at what you'd need to do to implement such a renderer. Requirements \u00b6 Each column renderer needs its own column model which defines all of the options that can be configured for that column. It can also optionally provide an editor to allow a user to change and tweak model options. And finally, it requires a renderer that knows how to convert a model and object ref data into a visualization of an attribute. Example \u00b6 Model Renderer Setup File ImageAttributeColumnModel.js . import { ColumnModel , Attributes } from '@leverege/ui-attributes' /* Initialize Constants */ const VALUE_TYPE = 'image' const TYPE = `attr.column. ${ VALUE_TYPE } ` /** * Gets name from data. */ function getName ( data ) { return Attributes . getDisplayName ( data . attrName , data . objectType ) } /* Initialize Model Base */ const base = { ... ColumnModel , getName , } delete base . create /** * Creates an attribute detail model instance. */ function create ( attrName , objectType ) { return ColumnModel . create ( TYPE , { attrName , objectType , } ) } /* Export Modules */ module . exports = { TYPE , create , ... base } File ImageAttributeColumnRenderer.jsx import React from 'react' import { AttributeColumnRenderer } from '@leverege/ui-attributes' export default class ImageColumnRenderer extends AttributeColumnRenderer { renderCell = ( data ) => { const { value } = data return ( < img alt = { value } src = { value } /> ) } } File PluginSetup.js import { Plugins } from '@leverege/plugin' import AttributeColumnEditor from '@leverege/ui-attributes' import ImageColumnModel from './ImageColumnModel' import ImageColumnRenderer from './ImageColumnRenderer' export default { install ( molten ) { molten . addPlugin ( 'Model' , { type : ImageColumnModel . TYPE , model : ImageColumnModel } ) molten . addPlugin ( 'ModelEditor' , { type : ImageColumnModel . TYPE , editor : AttributeColumnEditor } ) molten . addPlugin ( 'ColumnRenderer' , { type : ImageColumnModel . TYPE , renderer : ImageColumnRenderer } ) } } As you can see, this is a very simple example that simply extends the AttributeColumnModel, AttributeColumnEditor and AttributeColumnRenderer from @leverege/ui-attributes . In a real-life situation, you'd likely want to add additional parameters like a width and height for the image to the model and either extend or completely replace the column editor. More details on models and model editors can be found here .","title":"ColumnRenderer"},{"location":"docs/table/plugin-points/column-renderer/#columnrenderer","text":"In most cases, when you want to replace the default renderer for a column, an AttributeCellRenderer plugin will suffice. However, perhaps your custom data type has an Attribute with a valueType that the table does not support out of the box. For instance, the table does not have an image column renderer by default. Let's take a look at what you'd need to do to implement such a renderer.","title":"ColumnRenderer"},{"location":"docs/table/plugin-points/column-renderer/#requirements","text":"Each column renderer needs its own column model which defines all of the options that can be configured for that column. It can also optionally provide an editor to allow a user to change and tweak model options. And finally, it requires a renderer that knows how to convert a model and object ref data into a visualization of an attribute.","title":"Requirements"},{"location":"docs/table/plugin-points/column-renderer/#example","text":"Model Renderer Setup File ImageAttributeColumnModel.js . import { ColumnModel , Attributes } from '@leverege/ui-attributes' /* Initialize Constants */ const VALUE_TYPE = 'image' const TYPE = `attr.column. ${ VALUE_TYPE } ` /** * Gets name from data. */ function getName ( data ) { return Attributes . getDisplayName ( data . attrName , data . objectType ) } /* Initialize Model Base */ const base = { ... ColumnModel , getName , } delete base . create /** * Creates an attribute detail model instance. */ function create ( attrName , objectType ) { return ColumnModel . create ( TYPE , { attrName , objectType , } ) } /* Export Modules */ module . exports = { TYPE , create , ... base } File ImageAttributeColumnRenderer.jsx import React from 'react' import { AttributeColumnRenderer } from '@leverege/ui-attributes' export default class ImageColumnRenderer extends AttributeColumnRenderer { renderCell = ( data ) => { const { value } = data return ( < img alt = { value } src = { value } /> ) } } File PluginSetup.js import { Plugins } from '@leverege/plugin' import AttributeColumnEditor from '@leverege/ui-attributes' import ImageColumnModel from './ImageColumnModel' import ImageColumnRenderer from './ImageColumnRenderer' export default { install ( molten ) { molten . addPlugin ( 'Model' , { type : ImageColumnModel . TYPE , model : ImageColumnModel } ) molten . addPlugin ( 'ModelEditor' , { type : ImageColumnModel . TYPE , editor : AttributeColumnEditor } ) molten . addPlugin ( 'ColumnRenderer' , { type : ImageColumnModel . TYPE , renderer : ImageColumnRenderer } ) } } As you can see, this is a very simple example that simply extends the AttributeColumnModel, AttributeColumnEditor and AttributeColumnRenderer from @leverege/ui-attributes . In a real-life situation, you'd likely want to add additional parameters like a width and height for the image to the model and either extend or completely replace the column editor. More details on models and model editors can be found here .","title":"Example"},{"location":"docs/table/plugin-points/model-configurer/","text":"TableModelConfigurer \u00b6 The TableModelConfigurer Plugin Point allows you to register a function which will generate the default table model for a given matchContext. For instance, if you have an object type of \"vehicle\" in your application, you can register a TableModelConfigurer like this and it will be invoked for generating the default model for all tables whose Match context includes objectType : 'vehicle' : Configurer Setup File UnselectableTableModelConfigurer.js import { TableModel } from '@leverege/ui-attributes' export default { id : 'unselectable.vehicle.TableModelConfigurer' sort : 'aaa' , configure : ( tableModel , objectType , addName , cxt ) => { return TableModel . setSelectable ( tableModel , false ) } } File PluginSetup.js import UnselectableTableModelConfigurer from './UnselectableTableModelConfigurer' export default { install ( molten ) { molten . addPlugin ( 'TableModelConfigurer' , UnselectableTableModelConfigurer ) } } Each TableModelConfigurer plugin is passed the model instance from the configurer before it and is expected to return a model instance in turn. The first configurer will recieve a freshly initialized default model (the result of TableModel.create() ). The order that each configurer is called in depends on the \"sort\" property of the plugin itself. Tip Molten comes with a default table model configurer for Imagine objects, the BlueprintTableModelConfigurerer .","title":"TableModelConfigurer"},{"location":"docs/table/plugin-points/model-configurer/#tablemodelconfigurer","text":"The TableModelConfigurer Plugin Point allows you to register a function which will generate the default table model for a given matchContext. For instance, if you have an object type of \"vehicle\" in your application, you can register a TableModelConfigurer like this and it will be invoked for generating the default model for all tables whose Match context includes objectType : 'vehicle' : Configurer Setup File UnselectableTableModelConfigurer.js import { TableModel } from '@leverege/ui-attributes' export default { id : 'unselectable.vehicle.TableModelConfigurer' sort : 'aaa' , configure : ( tableModel , objectType , addName , cxt ) => { return TableModel . setSelectable ( tableModel , false ) } } File PluginSetup.js import UnselectableTableModelConfigurer from './UnselectableTableModelConfigurer' export default { install ( molten ) { molten . addPlugin ( 'TableModelConfigurer' , UnselectableTableModelConfigurer ) } } Each TableModelConfigurer plugin is passed the model instance from the configurer before it and is expected to return a model instance in turn. The first configurer will recieve a freshly initialized default model (the result of TableModel.create() ). The order that each configurer is called in depends on the \"sort\" property of the plugin itself. Tip Molten comes with a default table model configurer for Imagine objects, the BlueprintTableModelConfigurerer .","title":"TableModelConfigurer"},{"location":"getting-started/","text":"Getting Started \u00b6 Overview \u00b6 Molten is a React-based plugin framework for rapid UI development. Simply write and register a plugin and Molten will make it available throughout your application exactly where you need it--without requiring changes to existing code. At its core, Molten is a plugin registry with update and access mechanisms. It also includes an extensive suite of pre-built plugins that solve common data patterns and visualizations. Molten's default plugins are designed to make it easy to build powerful IoT applications using the Leverege Stack, but Molten can be used on its own to make your codebase more modular, dynamic, and flexible. Molten gives you the ability register new plugins--code to be accessed elsewhere in the app--and to add new plugin points that call your custom code. This means you have maximum control over the data and displays driving your app. Add a button that appears on select toolbars. Call a function that conditionally colors icons based on external data. Query an API and render items on a table and a map. You can use Molten to make small changes to an existing app, or as a starting point for a totally custom product. Tip To learn more about Molten's key concepts before jumping in, see the Concepts section for an overview of plugins, models, and attributes. Using Molten with Leverege's IoT Stack \u00b6 Leverege's IoT Stack provides a powerful, flexible system for working with internet connected devices, and the businesses built around them. Molten's default settings and plugins make working with your Leverege project simple. It handles user authentication and dynamically creates routes and views based on your Imagine project configuration. Molten uses Leverege's Builder tool for advanced themeing allowing you to dial in the look and feel of your app. You can learn more about configuring your Imagine project in the tutorials on the Leverege Admin Configuration Academy . To get started: Install Molten: npm i @leverege/molten Export your Builder theme [link-to-instructions-here] (for our example, we'll export it to './Theme') Molten uses Mapbox for geographic utilities (map displays, geocoding). You will need to add a Mapbox API key to your .env MAPBOX_APIKEY = your-api-key-here Initialize Molten in your startup script index.js import Molten from '@leverege/molten' import Theme from './Theme' // path to your exported theme function start () { const theme = { theme : Theme , appearanceProjectId : '<your-Builder-appearance-id>' , useActiveTheme : true // if true, Molten will pull theme data from Builder in real time, immediately reflecting design change. Set to false for production or to improve performance. } const api = { host : 'https://example-api.leverege.com' , // your Leverege API host systemId : '<your-system-id>' , // system in your Leverege Project projectId : '<your-project-id>' , // your Leverege Project ID storeToken : true } const config = { theme , api } Molten . init ( config ) Molten . create () } window . Application = { start } Configure your html to start the application index.html <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" > < title > My Leverege Project With Molten </ title > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1, minimum-scale=1\" /> < link rel = \"stylesheet\" href = \"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\" /> </ head > < body > < div id = \"root\" style = \"z-index:0\" > < script src = \"/index.js\" ></ script > < script > Application . start ( ) </ script > </ div > </ body > </ html > Start your application: npm start Using Molten without Leverege's IoT Stack \u00b6 You do not need to use Leverege's IoT Stack to benefit from using Molten. Its plugin framework can make any codebase simpler and more extensible. Because the default plugins are designed for working with the Leverege Stack, we just need to take some extra steps to exclude those plugins. Install Molten: npm i @leverege/molten Initialize Molten in your startup script import Molten from '@leverege/molten' import Theme from './Theme' // path to your exported theme import MyCustomScreen from './MyCustomScreen' // Path to the component you want to display on load function start () { // Molten renders the authScreenClass component on startup. By default, it's a login to a Leverege project, but you can replace it with whatever want in your config. const authScreenClass = MyCustomScreen // The excludes array in your config lists all the plugin IDs of any registered plugins (including default plugins) you want to exclude. Here we are taking out plugins related to authenticating to Leverege's API and theme engine. const excludes = [ 'molten.ApiInit' , 'molten.ThemeInit' , 'molten.ApiLogin' , 'molten.ApiUserSettings' , 'molten.AuthInit' , ] const config = { molten : { authScreenClass }, plugins : { excludes } } Molten . init ( config ) Molten . create () } window . Application = { start } Start the web server: npm start These steps will get a Molten enabled system running displaying only your custom code. To take advantage of Molten's plugin framework, you will need to add plugin points (and probably some plugins) to your code. See the plugins concepts page for a high level overview of plugins.","title":"Installation"},{"location":"getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"getting-started/#overview","text":"Molten is a React-based plugin framework for rapid UI development. Simply write and register a plugin and Molten will make it available throughout your application exactly where you need it--without requiring changes to existing code. At its core, Molten is a plugin registry with update and access mechanisms. It also includes an extensive suite of pre-built plugins that solve common data patterns and visualizations. Molten's default plugins are designed to make it easy to build powerful IoT applications using the Leverege Stack, but Molten can be used on its own to make your codebase more modular, dynamic, and flexible. Molten gives you the ability register new plugins--code to be accessed elsewhere in the app--and to add new plugin points that call your custom code. This means you have maximum control over the data and displays driving your app. Add a button that appears on select toolbars. Call a function that conditionally colors icons based on external data. Query an API and render items on a table and a map. You can use Molten to make small changes to an existing app, or as a starting point for a totally custom product. Tip To learn more about Molten's key concepts before jumping in, see the Concepts section for an overview of plugins, models, and attributes.","title":"Overview"},{"location":"getting-started/#using-molten-with-levereges-iot-stack","text":"Leverege's IoT Stack provides a powerful, flexible system for working with internet connected devices, and the businesses built around them. Molten's default settings and plugins make working with your Leverege project simple. It handles user authentication and dynamically creates routes and views based on your Imagine project configuration. Molten uses Leverege's Builder tool for advanced themeing allowing you to dial in the look and feel of your app. You can learn more about configuring your Imagine project in the tutorials on the Leverege Admin Configuration Academy . To get started: Install Molten: npm i @leverege/molten Export your Builder theme [link-to-instructions-here] (for our example, we'll export it to './Theme') Molten uses Mapbox for geographic utilities (map displays, geocoding). You will need to add a Mapbox API key to your .env MAPBOX_APIKEY = your-api-key-here Initialize Molten in your startup script index.js import Molten from '@leverege/molten' import Theme from './Theme' // path to your exported theme function start () { const theme = { theme : Theme , appearanceProjectId : '<your-Builder-appearance-id>' , useActiveTheme : true // if true, Molten will pull theme data from Builder in real time, immediately reflecting design change. Set to false for production or to improve performance. } const api = { host : 'https://example-api.leverege.com' , // your Leverege API host systemId : '<your-system-id>' , // system in your Leverege Project projectId : '<your-project-id>' , // your Leverege Project ID storeToken : true } const config = { theme , api } Molten . init ( config ) Molten . create () } window . Application = { start } Configure your html to start the application index.html <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" > < title > My Leverege Project With Molten </ title > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1, minimum-scale=1\" /> < link rel = \"stylesheet\" href = \"https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css\" /> </ head > < body > < div id = \"root\" style = \"z-index:0\" > < script src = \"/index.js\" ></ script > < script > Application . start ( ) </ script > </ div > </ body > </ html > Start your application: npm start","title":"Using Molten with Leverege's IoT Stack"},{"location":"getting-started/#using-molten-without-levereges-iot-stack","text":"You do not need to use Leverege's IoT Stack to benefit from using Molten. Its plugin framework can make any codebase simpler and more extensible. Because the default plugins are designed for working with the Leverege Stack, we just need to take some extra steps to exclude those plugins. Install Molten: npm i @leverege/molten Initialize Molten in your startup script import Molten from '@leverege/molten' import Theme from './Theme' // path to your exported theme import MyCustomScreen from './MyCustomScreen' // Path to the component you want to display on load function start () { // Molten renders the authScreenClass component on startup. By default, it's a login to a Leverege project, but you can replace it with whatever want in your config. const authScreenClass = MyCustomScreen // The excludes array in your config lists all the plugin IDs of any registered plugins (including default plugins) you want to exclude. Here we are taking out plugins related to authenticating to Leverege's API and theme engine. const excludes = [ 'molten.ApiInit' , 'molten.ThemeInit' , 'molten.ApiLogin' , 'molten.ApiUserSettings' , 'molten.AuthInit' , ] const config = { molten : { authScreenClass }, plugins : { excludes } } Molten . init ( config ) Molten . create () } window . Application = { start } Start the web server: npm start These steps will get a Molten enabled system running displaying only your custom code. To take advantage of Molten's plugin framework, you will need to add plugin points (and probably some plugins) to your code. See the plugins concepts page for a high level overview of plugins.","title":"Using Molten without Leverege's IoT Stack"},{"location":"getting-started/i18n/","text":"Localization \u00b6 i18n.md Installing Bundler \u00b6 Checking for translations \u00b6","title":"Localization"},{"location":"getting-started/i18n/#localization","text":"i18n.md","title":"Localization"},{"location":"getting-started/i18n/#installing-bundler","text":"","title":"Installing Bundler"},{"location":"getting-started/i18n/#checking-for-translations","text":"","title":"Checking for translations"},{"location":"plugins/","text":"Plugins \u00b6 These plugins are automatically installed with Molten.","title":"Plugins"},{"location":"plugins/#plugins","text":"These plugins are automatically installed with Molten.","title":"Plugins"}]}